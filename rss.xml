<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>VonBrank</title><description>Blog</description><link>https://blog.vonbrank.com/</link><language>zh_CN</language><item><title>macOS 配置指南</title><link>https://blog.vonbrank.com/posts/macos-setup/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/macos-setup/</guid><pubDate>Sat, 21 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;众所周知，macOS 只在 Apple 想给予你的体验范围内开箱即用，Apple 认为你不需要的功能，大都做得非常糟糕。本篇记录了一台新 Mac 到手后，或者重装 macOS 后，如何将其配置得易于使用.&lt;/p&gt;
&lt;h2&gt;下载 App 的好去处&lt;/h2&gt;
&lt;h3&gt;Github&lt;/h3&gt;
&lt;p&gt;与想象中的不同，macOS 其实是比较开放的，像 Windows 一样，macOS 事实上对侧载应用没有限制（只有你要开发 macOS App 才需要注册 Apple 开发者账号并付费），许多 App Store 中的付费 App 实际上都在 &lt;a href=&quot;https://github.com&quot;&gt;Github&lt;/a&gt; 上提供免费分发，因此不推荐使用 App Store 安装软件.&lt;/p&gt;
&lt;h3&gt;MacKed&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://macked.app/&quot;&gt;macked.app&lt;/a&gt; 提供了许多付费 App 的学习版.&lt;/p&gt;
&lt;h2&gt;App 推荐&lt;/h2&gt;
&lt;h3&gt;Maccy&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://macked.app/maccy.html&quot;&gt;Maccy&lt;/a&gt; 是一款剪贴板工具.&lt;/p&gt;
&lt;h3&gt;Mos&lt;/h3&gt;
&lt;p&gt;默认配置下，MacBook 的触摸板有多爽，那鼠标就有多反人类，因为 macOS 默认不提供单独反转鼠标滚轮方向的功能.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Caldis/Mos&quot;&gt;Mos&lt;/a&gt; 能够用于解决这个问题. 除了翻转鼠标滚轮方向，Mos 还提供其他鼠标配置相关的有用功能.&lt;/p&gt;
&lt;h3&gt;Keka&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://macked.app/keka.html&quot;&gt;Keka&lt;/a&gt; 为 macOS 带来了方便的解压缩文件功能.&lt;/p&gt;
&lt;h3&gt;IINA&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/iina/iina&quot;&gt;IINA&lt;/a&gt; 是 macOS 上最有名的音视频播放器之一.&lt;/p&gt;
&lt;h3&gt;Ghostty&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ghostty-org/ghostty&quot;&gt;Ghostty&lt;/a&gt; 一个跨平台的终端，可以用于替换掉 macOS 的默认终端.&lt;/p&gt;
&lt;h3&gt;Stats&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/exelban/stats&quot;&gt;Stats&lt;/a&gt; 是适用于 macOS 的系统监视器，可以实时监控系统各个进程，以及各个硬件的状态.&lt;/p&gt;
&lt;h3&gt;Bartender&lt;/h3&gt;
&lt;p&gt;个人认为被刘海截断的状态栏是 MacBook 最逆天的设计之一，特别是状态栏上的 App 图标比较多的时候，左边的图标居然会被刘海挡住.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://macked.app/bartender-5-crack.html&quot;&gt;Bartender 5&lt;/a&gt; 通过让你设置哪些 App 图标可以被折叠，从而解决上述问题.&lt;/p&gt;
</content:encoded></item><item><title>Simple Guides for Fuwari</title><link>https://blog.vonbrank.com/posts/guide/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/guide/</guid><description>How to use this blog template.</description><pubDate>Mon, 01 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;Cover image source: &lt;a href=&quot;https://image.civitai.com/xG1nkqKTMzGDvpLrqFT7WA/208fc754-890d-4adb-9753-2c963332675d/width=2048/01651-1456859105-(colour_1.5),girl,_Blue,yellow,green,cyan,purple,red,pink,_best,8k,UHD,masterpiece,male%20focus,%201boy,gloves,%20ponytail,%20long%20hair,.jpeg&quot;&gt;Source&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This blog template is built with &lt;a href=&quot;https://astro.build/&quot;&gt;Astro&lt;/a&gt;. For the things that are not mentioned in this guide, you may find the answers in the &lt;a href=&quot;https://docs.astro.build/&quot;&gt;Astro Docs&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Front-matter of Posts&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;---
title: My First Blog Post
published: 2023-09-09
description: This is the first post of my new Astro blog.
image: ./cover.jpg
tags: [Foo, Bar]
category: Front-end
draft: false
---
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Attribute&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;title&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The title of the post.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;published&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The date the post was published.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;description&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A short description of the post. Displayed on index page.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;image&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The cover image path of the post.&amp;lt;br/&amp;gt;1. Start with &lt;code&gt;http://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt;: Use web image&amp;lt;br/&amp;gt;2. Start with &lt;code&gt;/&lt;/code&gt;: For image in &lt;code&gt;public&lt;/code&gt; dir&amp;lt;br/&amp;gt;3. With none of the prefixes: Relative to the markdown file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;tags&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The tags of the post.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;category&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The category of the post.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;draft&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If this post is still a draft, which won&apos;t be displayed.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Where to Place the Post Files&lt;/h2&gt;
&lt;p&gt;Your post files should be placed in &lt;code&gt;src/content/posts/&lt;/code&gt; directory. You can also create sub-directories to better organize your posts and assets.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;src/content/posts/
├── post-1.md
└── post-2/
    ├── cover.png
    └── index.md
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Unity 可配置鼠标指针与 UI 射线检测</title><link>https://blog.vonbrank.com/posts/unity-configurable-cursors-and-raycastable-ui/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/unity-configurable-cursors-and-raycastable-ui/</guid><pubDate>Fri, 25 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;在游戏开发中，使用鼠标指针与场景进行互动是很常见的需求。我们可能需要使用鼠标来选中场景中的物体，为主角选择一个移动目标点，或是一款建造游戏中玩家选择关卡中的某个点来放置建筑等；进一步地我们可能需要让鼠标悬浮在不同物体上时显示不同外观的光标，如鼠标悬浮在敌人上方时将光标显示为一把剑、悬浮在 UI 按钮上时改变光标颜色、悬浮在主角不可到达的位置时显示为一个红叉等。&lt;/p&gt;
&lt;p&gt;本文将介绍一种实现可灵活配置光标的技巧，其能便于我们在制作 Unity 游戏时方便地配置不同场景下光标的外观，同时介绍检查鼠标是否悬浮 UI 控件上的方法。后者旨在系统性解决以往我和我的朋友们使用 Unity 开发游戏过程中，我们常常遇到的射线检测穿透 UI 导致 UI 点击事件和光标与场景交互事件相互干扰的问题。&lt;/p&gt;
&lt;h2&gt;最终效果&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Unity 版本：2021.3.29f1&lt;/li&gt;
&lt;li&gt;源码：
&lt;ul&gt;
&lt;li&gt;地址：https://wwit.lanzout.com/iQxWh16lfkcb&lt;/li&gt;
&lt;li&gt;密码：&lt;code&gt;5zm9&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://vonbrank-images.oss-cn-hangzhou.aliyuncs.com/20230826-Blog-Image/unity-configurable-cursors-and-raycastable-ui/unity-cursor-final-effect.gif&quot; alt=&quot;unity-cursor-final-effect&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，可以想象这是一个 RPG 或者 RTS 游戏的场景，玩家需要用点击 UI 或场景中的物体来指示主角或单位进行移动与战斗。在本例中，白色的平面表示地面，主角可以在上面进行移动；红色的方块表示敌人，点击它表示指示主角攻击敌人；鼠标移动到白色平面之外的虚空并点击则让主角返回 Idle 状态。&lt;/p&gt;
&lt;p&gt;从上图可以看到，我们要实现的最终效果是，当鼠标悬浮在地面上时为普通白色指针；悬浮在敌人上时显示一把剑；悬浮在虚空上时显示一个红叉；悬浮在 UI 上时显示为蓝色指针。鼠标悬浮在非虚空物体上时 UI 将显示对应位置的坐标；点击任何非虚空物体时将显示点击事件对应的行为；如果鼠标悬浮在 UI 上，那么任何点击场景中物体的事件都不会被触发。&lt;/p&gt;
&lt;h2&gt;基于光标位置的场景射线检测&lt;/h2&gt;
&lt;p&gt;首先我们定义好场景中的每一类物体，以便稍后进行射线检测时我们能区分一个 &lt;code&gt;GameObject&lt;/code&gt; 是地面还是敌人，或是其他物体。&lt;/p&gt;
&lt;p&gt;为地面添加 &lt;code&gt;Landmass&lt;/code&gt; 脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using UnityEngine;

namespace Environment
{
    public class Landmass : MonoBehaviour
    {
        
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为敌人添加 &lt;code&gt;CombatTarget&lt;/code&gt; 脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using UnityEngine;

namespace Combat
{
    public class CombatTarget : MonoBehaviour
    {
        
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，我们需要一个 &lt;code&gt;PlayerController&lt;/code&gt;，它将在每帧对场景进行一次射线检测。由于这个项目仅仅是为了演示鼠标的相关内容，因此场景中的 &lt;code&gt;Player&lt;/code&gt; 游戏对象除了挂上了 &lt;code&gt;PlayerController&lt;/code&gt; 脚本，几乎只是一个空的 &lt;code&gt;GameObject&lt;/code&gt; 而已。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// ...
using UnityEngine;

namespace Control
{
    public class PlayerController : MonoBehaviour
    {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们将使用 &lt;code&gt;Physics.Raycast&lt;/code&gt; 函数进行场景的射线检测，其声明如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool Raycast(Ray ray, out RaycastHit hitInfo);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见我们需要从屏幕空间鼠标悬浮的位置获得一个 &lt;code&gt;Ray&lt;/code&gt; 实例来做射线检测。可以使用 &lt;code&gt;Camera&lt;/code&gt; 的 &lt;code&gt;ScreenPointToRay&lt;/code&gt; 方法实现这一点，它需要传入一个 &lt;code&gt;Vector3&lt;/code&gt;，即当前鼠标在屏幕空间中的坐标，这可以通过 &lt;code&gt;Input.mousePosition&lt;/code&gt; 获取。&lt;/p&gt;
&lt;p&gt;以上逻辑可以抽象到一个 &lt;code&gt;GetMouseRay&lt;/code&gt; 中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private Ray GetMouseRay()
{
    return mainCamera.ScreenPointToRay(Input.mousePosition);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在此之前，我们需要先获取当前的摄像机对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private Camera mainCamera;

private void Start()
{
    mainCamera = Camera.main;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，我们将创建一个 &lt;code&gt;InteractWithComponent&lt;/code&gt; 方法，在 &lt;code&gt;Update&lt;/code&gt; 函数中调用，方法内先从鼠标的位置对下方的场景做射线检测，再根据检测到的物体是否拥有 &lt;code&gt;Landmass&lt;/code&gt; 或 &lt;code&gt;CombatTarget&lt;/code&gt; 组件来确定当前鼠标指针悬浮在什么物体上。&lt;/p&gt;
&lt;p&gt;这部分最终的的 &lt;code&gt;PlayerController&lt;/code&gt; 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using System;
using System.Collections;
using System.Collections.Generic;
using Combat;
using Environment;
using UnityEngine;

namespace Control
{
    public class PlayerController : MonoBehaviour
    {
        private Camera mainCamera;

        private void Start()
        {
            mainCamera = Camera.main;
        }

        private void Update()
        {
            InteractWithComponent();
        }

        private bool InteractWithComponent()
        {
            bool hasHit = Physics.Raycast(GetMouseRay(), out var raycastHit);

            if (hasHit)
            {
                var landmass = raycastHit.transform.GetComponent&amp;lt;Landmass&amp;gt;();
                var combatTarget = raycastHit.transform.GetComponent&amp;lt;CombatTarget&amp;gt;();

                if (landmass != null)
                {
                    Debug.Log($&quot;hovering landmass&quot;);
                }
                else if (combatTarget != null)
                {
                    Debug.Log($&quot;hovering combatTarget&quot;);
                }
                else
                {
                    Debug.Log($&quot;hovering nothing&quot;);
                }
            }
            else
            {
                Debug.Log($&quot;hovering nothing&quot;);
            }

            return true;
        }

        private Ray GetMouseRay()
        {
            return mainCamera.ScreenPointToRay(Input.mousePosition);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;可配置的鼠标指针样式&lt;/h2&gt;
&lt;p&gt;接下来我们来实现鼠标悬浮在不同物体上时，显示为不同的图标。&lt;/p&gt;
&lt;p&gt;要想更改鼠标指针显示的图案，可以使用 &lt;code&gt;Cursor.SetCursor&lt;/code&gt; 方法，其函数签名为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void SetCursor(Texture2D texture, Vector2 hotspot, CursorMode cursorMode)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见调用该函数我们首先需要传入一份 &lt;code&gt;Texture2D&lt;/code&gt; 纹理数据，再设置一个偏移量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://assetstorev1-prd-cdn.unity3d.com/key-image/99486ba9-7a67-4ad2-9bad-40ee0aa91c3d.jpg&quot; alt=&quot;Unity Pixel Cursors&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里我们使用 Pixel Cursors 这个素材包来进行演示，该素材包在 Unity 素材商店中是免费的。将素材包导入项目后，注意将素材的 &lt;code&gt;Texture Type&lt;/code&gt; 修改为 &lt;code&gt;Cursor&lt;/code&gt;，&lt;code&gt;Advanced&lt;/code&gt; 选项中的 &lt;code&gt;Read/Write&lt;/code&gt; 也需要勾上。&lt;/p&gt;
&lt;p&gt;我们需要一个 &lt;code&gt;struct&lt;/code&gt; 来指明鼠标指向的每一种物体和图标的对应关系。在 &lt;code&gt;PlayerController&lt;/code&gt; 中创建一个内部类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[System.Serializable]
struct CursorMapping
{
    public CursorType cursorType;
    public Texture2D texture;
    public Vector2 hotspot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;CursorType&lt;/code&gt; 是一个枚举类型，其定义为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;namespace Control
{
    public enum CursorType
    {
        None,
        Movement,
        Combat,
        UI,
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;足以用于表示目前我们需要的每一种光标类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CursorMapping&lt;/code&gt; 建立起了每一种 &lt;code&gt;CursorType&lt;/code&gt; 到对应鼠标指针样式的映射。一个 &lt;code&gt;CursorMapping&lt;/code&gt; 实例可以解读为 &lt;code&gt;cursorType&lt;/code&gt; 这种类型的光标对应的哪一个图片（Texture 2D）资产、&lt;code&gt;hotspot&lt;/code&gt; 的值是多少。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;PlayerController&lt;/code&gt; 中添加一个字段：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[SerializeField] private CursorMapping[] cursorMappings = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这可以方便地让我们在编辑器中配置每一种 &lt;code&gt;CursorType&lt;/code&gt; 对应哪一张纹理，形成一张映射表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://vonbrank-images.oss-cn-hangzhou.aliyuncs.com/20230826-Blog-Image/unity-configurable-cursors-and-raycastable-ui/unity-cursor-mapping-editor.jpg&quot; alt=&quot;unity-cursor-mapping-editor&quot; /&gt;&lt;/p&gt;
&lt;p&gt;映射表建立好后，下面的工作就是实现一组函数，能让我们方便地通过传入一个 &lt;code&gt;CursorType&lt;/code&gt; 来更新鼠标指针样式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private void SetCursor(CursorType cursorType)
{
    CursorMapping? mapping = GetCursorMapping(cursorType);
    if (mapping != null)
    {
        Cursor.SetCursor(mapping?.texture, mapping?.hotspot ?? Vector2.zero, CursorMode.Auto);
    }
}

private CursorMapping? GetCursorMapping(CursorType cursorType)
{
    if (cursorMappings == null) return null;
    foreach (var cursorMapping in cursorMappings)
    {
        if (cursorMapping.cursorType == cursorType)
        {
            return cursorMapping;
        }
    }

    return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SetCursor&lt;/code&gt; 通过接受一个 &lt;code&gt;CursorType&lt;/code&gt;、查找对应的鼠标指针纹理，最后调用 &lt;code&gt;Cursor.SetCursor&lt;/code&gt; 来传入对应的纹理和偏移坐标，从而实现更新鼠标指针样式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GetCursorMapping&lt;/code&gt; 则用来通过 &lt;code&gt;CursorType&lt;/code&gt; 从 &lt;code&gt;cursorMappings&lt;/code&gt; 中遍历找出所需要的 &lt;code&gt;cursorMapping&lt;/code&gt; 对象，返回对应的 &lt;code&gt;texture&lt;/code&gt; 和 &lt;code&gt;hotspot&lt;/code&gt; 配置，以供 &lt;code&gt;SetCursor&lt;/code&gt; 中调用。&lt;/p&gt;
&lt;p&gt;值得注意的是，如果用户没有为某一种 &lt;code&gt;CursorType&lt;/code&gt; 做配置，却在调用 &lt;code&gt;SetCursor&lt;/code&gt; 时传入了这种 &lt;code&gt;CursorType&lt;/code&gt;，&lt;code&gt;GetCursorMapping&lt;/code&gt; 将会返回 &lt;code&gt;null&lt;/code&gt;，这就是它的返回类型是 &lt;code&gt;CursorMapping?&lt;/code&gt; 而不是 &lt;code&gt;CursorMapping&lt;/code&gt; 的原因。&lt;/p&gt;
&lt;p&gt;然而在 &lt;code&gt;SetCursor&lt;/code&gt; 中，即使我们已经中 &lt;code&gt;if&lt;/code&gt; 语句中判断了 &lt;code&gt;mapping != null&lt;/code&gt;、保证它在 &lt;code&gt;if&lt;/code&gt; 块内不是 &lt;code&gt;null&lt;/code&gt;，C# 的编译器依然强制要求我们在稍后引用 &lt;code&gt;CursorMapping&lt;/code&gt; 中的字段时，使用 &lt;code&gt;?.&lt;/code&gt; 语法，可见 C# 静态检查器在自动类型推导方面仍有不少提升空间。&lt;/p&gt;
&lt;p&gt;最后，在 &lt;code&gt;InteractWithComponent&lt;/code&gt; 中，我们将先前的简单执行 &lt;code&gt;Debug.Log&lt;/code&gt; 改为使用 &lt;code&gt;SetCursor&lt;/code&gt;，从而实现根据鼠标下方的物体类型变更鼠标指针的图标样式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PlayerController&lt;/code&gt; 在这部分最终做了如下修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// ...
using UnityEngine;

namespace Control
{
    public class PlayerController : MonoBehaviour
    {
        // ...

        [System.Serializable]
        struct CursorMapping
        {
            public CursorType cursorType;
            public Texture2D texture;
            public Vector2 hotspot;
        }

        [SerializeField] private CursorMapping[] cursorMappings = null;

        // ...

        private void Update()
        {
            InteractWithComponent();
        }

        private bool InteractWithComponent()
        {
            bool hasHit = Physics.Raycast(GetMouseRay(), out var raycastHit);

            if (hasHit)
            {
                var landmass = raycastHit.transform.GetComponent&amp;lt;Landmass&amp;gt;();
                var combatTarget = raycastHit.transform.GetComponent&amp;lt;CombatTarget&amp;gt;();

                if (landmass != null)
                {
                    SetCursor(CursorType.Movement);
                }
                else if (combatTarget != null)
                {
                    SetCursor(CursorType.Combat);
                }
                else
                {
                    SetCursor(CursorType.None);
                }
            }
            else
            {
                SetCursor(CursorType.None);
            }

            return true;
        }

        // ...

        private void SetCursor(CursorType cursorType)
        {
            CursorMapping? mapping = GetCursorMapping(cursorType);
            if (mapping != null)
            {
                Cursor.SetCursor(mapping?.texture, mapping?.hotspot ?? Vector2.zero, CursorMode.Auto);
            }
        }

        private CursorMapping? GetCursorMapping(CursorType cursorType)
        {
            if (cursorMappings == null) return null;
            foreach (var cursorMapping in cursorMappings)
            {
                if (cursorMapping.cursorType == cursorType)
                {
                    return cursorMapping;
                }
            }

            return null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;UI 遮挡的检测&lt;/h2&gt;
&lt;p&gt;为了演示游戏在有 UI 的情况下，如何防止点击 UI 的操作同时被解读为玩家与场景中的物体交互，从而造成相互干扰的现象，我们需要先简单设计一个 UI：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://vonbrank-images.oss-cn-hangzhou.aliyuncs.com/20230826-Blog-Image/unity-configurable-cursors-and-raycastable-ui/unity-cursor-ui-design.jpg&quot; alt=&quot;unity-cursor-ui-design&quot; /&gt;&lt;/p&gt;
&lt;p&gt;为了防止 UI 点击事件影响到用户与场景的交互，很明显，我们需要在 &lt;code&gt;PlayerController&lt;/code&gt; 的 &lt;code&gt;Update&lt;/code&gt; 函数里调用 &lt;code&gt;InteractWithComponent&lt;/code&gt; 先行检测当前鼠标是否悬浮在 UI 上。&lt;/p&gt;
&lt;p&gt;该功能的实现实际上非常简单，只需要执行如下语句、检查其返回值即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EventSystem.current.IsPointerOverGameObject();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;IsPointerOverGameObject&lt;/code&gt; 函数的命名存在一定误导性，其中的 &lt;code&gt;GameObject&lt;/code&gt; 指的是是某一个 UI 对象而不是场景中某一个其他类型的 &lt;code&gt;GameObject&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;若 &lt;code&gt;IsPointerOverGameObject&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 则表明鼠标当前悬浮在一个 &lt;code&gt;UI&lt;/code&gt; 对象上，反之表明当前鼠标下方没有任何 UI。如果希望某一个 UI 元素不被 &lt;code&gt;IsPointerOverGameObject&lt;/code&gt; 检测到，可以通过为其添加 &lt;code&gt;Canvas Group&lt;/code&gt; 组件、取消勾选 &lt;code&gt;Interactable&lt;/code&gt; 和 &lt;code&gt;Blocks Raycasts&lt;/code&gt; 选项即可。&lt;/p&gt;
&lt;p&gt;最终我们需要将 &lt;code&gt;PlayerController&lt;/code&gt; 修改为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// ...
using UnityEngine;
using UnityEngine.EventSystems;

namespace Control
{
    public class PlayerController : MonoBehaviour
    {
        // ...

        private void Update()
        {
            if (InteractWithUI())
            {
                return;
            }

            if (InteractWithComponent())
            {
                return;
            }
        }

        // ...

        private bool InteractWithUI()
        {
            if (EventSystem.current.IsPointerOverGameObject())
            {
                SetCursor(CursorType.UI);
                return true;
            }

            return false;
        }

        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意，在 Unity 场景中创建 UI 时，一般会一并创建一个 &lt;code&gt;EventSystem&lt;/code&gt; 游戏对象，这对我们实现 UI 遮挡检测的功能十分重要。&lt;code&gt;EventSystem.current&lt;/code&gt; 实际上就是场景中的这一个 &lt;code&gt;EventSystem&lt;/code&gt; 对象，如果缺少这个对象，执行该语句会抛出空指针异常。&lt;/p&gt;
&lt;h2&gt;通用的 &lt;code&gt;Raycastable&lt;/code&gt; 接口&lt;/h2&gt;
&lt;p&gt;到目前为止，我们其实已经实现了 &lt;a href=&quot;#%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C&quot;&gt;最终效果&lt;/a&gt; 中展示的全部功能了。但是还有优化空间。&lt;/p&gt;
&lt;p&gt;我们注意到在 &lt;code&gt;InteractWithComponent&lt;/code&gt; 方法中，我们直接依赖了 &lt;code&gt;Landmass&lt;/code&gt; 和 &lt;code&gt;CombatTarget&lt;/code&gt; 类，并通过若干 &lt;code&gt;if-else&lt;/code&gt; 语句来判断被选择的游戏对象是什么类型的。这在未来的开发中可能导致几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果需要检测的物体类型增多，&lt;code&gt;if-else-if&lt;/code&gt; 语句序列会进一步加长，降低代码可维护性。&lt;/li&gt;
&lt;li&gt;形如 &lt;code&gt;Landmass&lt;/code&gt; 或 &lt;code&gt;CombatTarget&lt;/code&gt; 等类型可能需要反过来与 &lt;code&gt;PlayerController&lt;/code&gt; 进行交互，毕竟存在敌人需要锁定玩家等需求。这将导致对象间的循环依赖，提升项目不同模块的耦合程度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意到 &lt;code&gt;InteractWithComponent&lt;/code&gt; 中，我们实际并不关心 &lt;code&gt;Landmass&lt;/code&gt; 和 &lt;code&gt;CombatTaget&lt;/code&gt; 具体是什么，只关心它们是否能被射线检测到，以及对应的 &lt;code&gt;CursorType&lt;/code&gt; 是什么，因此我们可以抽象出一个 &lt;code&gt;IRaycastable&lt;/code&gt; 接口，让 &lt;code&gt;Landmass&lt;/code&gt; 和 &lt;code&gt;CombatTarget&lt;/code&gt; 去实现，让它们自己去定义被鼠标悬浮或点击后，自身与 &lt;code&gt;PlayerController&lt;/code&gt; 的交互行为，并返回对应的 &lt;code&gt;CursorType&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IRaycastable&lt;/code&gt; 定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;namespace Control
{
    public interface IRaycastable
    {
        bool HandleRaycast(PlayerController playerController);
        CursorType GetCursorType();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;HandleRaycast&lt;/code&gt; 用于生成物体被射线检测时的反馈；&lt;code&gt;GetCursorType&lt;/code&gt; 用于定义物体被鼠标指针指向时应显示哪一种类型的指针。&lt;/p&gt;
&lt;p&gt;让 &lt;code&gt;Landmass&lt;/code&gt; 和 &lt;code&gt;CombatTarget&lt;/code&gt; 实现该接口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using Control;
using UnityEngine;

namespace Environment
{
    public class Landmass : MonoBehaviour, IRaycastable
    {
        public bool HandleRaycast(PlayerController playerController)
        {
            if (Input.GetMouseButton(0))
            {
                playerController.CurrentActionText = &quot;Moving&quot;;
            }

            return true;
        }

        public CursorType GetCursorType()
        {
            return CursorType.Movement;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;using Control;
using UnityEngine;

namespace Combat
{
    public class CombatTarget : MonoBehaviour, IRaycastable
    {
        public bool HandleRaycast(PlayerController playerController)
        {
            if (Input.GetMouseButton(0))
            {
                playerController.CurrentActionText = &quot;Fighting&quot;;
            }

            return true;
        }

        public CursorType GetCursorType()
        {
            return CursorType.Combat;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并修改 &lt;code&gt;PlayerController&lt;/code&gt; 的 &lt;code&gt;InteractWithComponent&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// ...
using UnityEngine;
// ...

namespace Control
{
    public class PlayerController : MonoBehaviour
    {
        // ...

        public string CurrentActionText
        {
            get { return currentActionText; }
            set { currentActionText = value; }
        }

        // ...

        private bool InteractWithComponent()
        {
            bool hasHit = Physics.Raycast(GetMouseRay(), out var raycastHit);

            if (hasHit)
            {
                var raycastables = raycastHit.transform.GetComponents&amp;lt;IRaycastable&amp;gt;();

                currentHoveringPosition = raycastHit.point;

                foreach (var raycastable in raycastables)
                {
                    if (raycastable.HandleRaycast(this))
                    {
                        SetCursor(raycastable.GetCursorType());
                        return true;
                    }
                }

                SetCursor(CursorType.None);
                if (Input.GetMouseButton(0))
                    currentActionText = &quot;Idle&quot;;
            }
            else
            {
                SetCursor(CursorType.None);
                currentHoveringPosition = Vector3.zero;
                if (Input.GetMouseButton(0))
                    currentActionText = &quot;Idle&quot;;
            }

            return true;
        }

        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此，我们实现了一个可灵活配置的鼠标指针系统，同时解决了在有 UI 的情况下，如何防止玩家点击 UI 的行为导致的逻辑上的歧义的问题。&lt;/p&gt;
&lt;p&gt;除此之外我们还实现了 &lt;code&gt;PlayerController&lt;/code&gt; 类与 &lt;code&gt;Landmass&lt;/code&gt;、&lt;code&gt;CombatTaget&lt;/code&gt; 类之间的控制反转，降低了模块间的耦合程度、提升了 &lt;code&gt;InteractWithComponent&lt;/code&gt; 方法的代码质量。&lt;/p&gt;
</content:encoded></item><item><title>GAMES 202 作业代码框架剖析</title><link>https://blog.vonbrank.com/posts/games-202-assignment-framework-analysis/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/games-202-assignment-framework-analysis/</guid><pubDate>Wed, 23 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;《GAMES202：高质量实时渲染》是由闫令琪老师开设的计算机图形学进阶课程。相比 GAMES 101，GAMES 202 不仅作业内容的难度更高，其代码框架也更难以理解。由于对代码框架、尤其是 WebGL API 的理解直接影响到完成作业的思路，并且 GAMES 202 代码框架也是使用 WebGL 封装简易图形渲染引擎的一次很好的实践，因此本文将对 GAMES 202 使用了 WebGL 的部分作业代码框架进行剖析，尝试解释代码框架中每一个文件、每一行代码做了什么，从而为更好更深入地理解和完成作业内容打下坚实基础。&lt;/p&gt;
&lt;h2&gt;WebGL 使用方法回顾&lt;/h2&gt;
&lt;p&gt;WebGL 是 OpenGL 的一个子集，是一套光栅化 API。浏览器在底层实现了 OpenGL 标准接口并在以 JavaScript 封装的方式提供给开发者使用，开发者首先通过 &lt;code&gt;canvas&lt;/code&gt; 元素获取 WebGL 上下文对象，通过操作该对象上的 WebGL 接口并输出到画布上，从而实现各类渲染功能。&lt;/p&gt;
&lt;p&gt;要在 WebGL 中实现渲染物体，比如渲染一个三角形，需要向着色器提供以下几类数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Attributes&lt;/code&gt; 和 &lt;code&gt;Buffer&lt;/code&gt;：Buffer 通常是一个类似数组的东西，里面按顺序存储了物体的顶点、法线、纹理坐标、颜色等信息。将一组 Buffer 提供给着色器，通过 &lt;code&gt;Attributes&lt;/code&gt; 来告诉着色器如何理解这些数据（如多少个数表示第一个顶点，一次渲染中这一组数据在着色器中对应的变量名称是什么等）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Uniforms&lt;/code&gt;：可以认为是渲染一帧过程中，着色器程序每次运行过程中都不变的常量，如摄像机的参数、光源的位置等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Textures&lt;/code&gt;：纹理数据在渲染过程中的数据不必多说，WebGL 提供 &lt;code&gt;Textures&lt;/code&gt; 数据类型及其相关方法专门用于传递纹理数据，当然，这也只是一种数据类型而已，开发者也可以向其中存储任意类型的数据，并以自己理解的方式进行读取和使用，前提是使用 &lt;code&gt;Textures&lt;/code&gt; 数据类型提供的数据操作方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;WebGL 在运行过程中，首先将顶点数据输入顶点着色器（Vertex Shader），以由 &lt;code&gt;Attributes&lt;/code&gt; 和 &lt;code&gt;Buffer&lt;/code&gt; 提供的顶点数据为单位将顶点坐标变换到裁剪空间，接着根据顶点进行光栅化和插值，以插值得到的每一个结果作为片元着色器（Fragment Shader）的输入，运行该着色器以获得一个像素的值。该过程中渲染所需的其他参数，如变换规则、摄像机的位置、光源位置等，需通过 &lt;code&gt;Uniforms&lt;/code&gt; 和 &lt;code&gt;Textures&lt;/code&gt; 得到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://webglfundamentals.org/webgl/lessons/resources/vertex-shader-anim.gif&quot; alt=&quot;顶点着色器运行过程&quot; /&gt;&lt;/p&gt;
&lt;p&gt;更多关于 WebGL 使用方法的内容，请参考 &lt;a href=&quot;https://webglfundamentals.org/&quot;&gt;WebGL Fundamentals&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;将官方代码框架引入现代前端开发流的说明&lt;/h2&gt;
&lt;p&gt;GAMES202 课程作业大都基于 WebGL 实现。得益于 WebGL 简单易用的特点，这免去了我们手动配置 OpenGL 的麻烦。&lt;/p&gt;
&lt;p&gt;然而原代码框架使用传统 Web 前端技术与原生 JavaScript 进行编写，缺乏代码提示与静态检查，使得完成作业、调试 bug 较为困难。&lt;/p&gt;
&lt;p&gt;因此笔者针对 GAMES202 官方作业代码框架进行了简单修改，将原代码框架迁移至 TypeScript，使用 Vite 进行打包，并引入 ES Module 模块化，同时实现类型声明与静态检查，期望能提升开发体验。项目链接：&lt;a href=&quot;https://github.com/vonbrank/GAMES202-Assignment-Framework-with-TypeScript-Support&quot;&gt;GAMES202 Assignment Framework with TypeScript Support&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文针对代码框架的剖析都将基于迁移到 TypeScript 的版本进行。&lt;/p&gt;
&lt;h2&gt;作业 0 代码框架详解&lt;/h2&gt;
&lt;h3&gt;GAMES 202 作业代码框架体系结构&lt;/h3&gt;
&lt;p&gt;作业 0 的代码框架目录结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+
|   .gitignore
|   index.html
|   package.json
|   tsconfig.json
|   vite.config.ts
|   yarn.lock
|
+---public
|   |   vite.svg
|   |
|   \---assets
|       \---mary
|               Marry.mtl
|               Marry.obj
|               MC003_Kozakura_Mari.png
|
\---src
    |   engine.ts
    |   main.ts
    |   style.css
    |   typescript.svg
    |   vite-env.d.ts
    |
    +---lights
    |       Light.ts
    |       PointLight.ts
    |
    +---loads
    |       loadOBJ.ts
    |       loadShader.ts
    |
    +---materials
    |       Material.ts
    |
    +---objects
    |       Mesh.ts
    |
    +---renderers
    |       MeshRender.ts
    |       WebGLRenderer.ts
    |
    +---shaders
    |   |   Shader.ts
    |   |
    |   +---InternalShader
    |   |       FragmentShader.glsl
    |   |       index.ts
    |   |       LightCubeFragmentShader.glsl
    |   |       LightCubeVertexShader.glsl
    |   |       VertexShader.glsl
    |   |
    |   +---lightShader
    |   |       fragment.glsl
    |   |       vertex.glsl
    |   |
    |   \---phongShader
    |           fragment.glsl
    |           vertex.glsl
    |
    \---textures
            Texture.ts
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;index.html&lt;/code&gt;：描述网页的布局文件，这里只需要一个充满屏幕的 &lt;code&gt;canvas&lt;/code&gt; 元素即可，用来获取 WebGL 的上下文&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt; 文件夹：存放各类公共资源，如网页 logo，要渲染的模型等，在 JavaScript 中引入本地静态资源时使用的相对路径可以被认为是以此为根目录的相对路径。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;assets&lt;/code&gt;：这里一般存放要渲染的模型资产，如要在 JavaScript 中访问 &lt;code&gt;marry&lt;/code&gt; 文件夹，使用 &lt;code&gt;assets/marry&lt;/code&gt; 进行访问即可&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;src&lt;/code&gt;：这是存放各类代码的地方，包括 TypeScript 文件和 GLSL 文件
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;main.ts&lt;/code&gt;：程序的入口，从这里调用来自 &lt;code&gt;engine.ts&lt;/code&gt; 的 &lt;code&gt;GAMES202Main&lt;/code&gt; 来初始化 WebGL 配置、加载并渲染模型等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;engine.ts&lt;/code&gt;：定义了 &lt;code&gt;GAMES202Main&lt;/code&gt; 函数和摄像机的初始位置，在该函数中，首先从 DOM 树中获取在 &lt;code&gt;index.html&lt;/code&gt; 定义的 &lt;code&gt;canvas&lt;/code&gt; 元素，创建一个用于操作 WebGL 的上下文；接着使用 &lt;code&gt;THREE.js&lt;/code&gt; 创建摄像机对象用于生成可以在 Shader 中使用的各类摄像机参数；然后创建光源数据，和一个自定义的、使用 WebGL 接口封装的 Mesh Renderer，用以渲染从资产文件中加载出来的包含顶点、纹理坐标、法线数据的模型；最后进入消息循环，监听镜头移动并持续刷新渲染场景。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;renders&lt;/code&gt;：通过传入摄像机数据、光源位置，和定义了顶点、纹理坐标、法线等信息的 Mesh 来向 &lt;code&gt;engine.ts&lt;/code&gt; 提供两种渲染功能
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WebGLRenderer.ts&lt;/code&gt;：总的渲染器，通过保存若干光源、Mesh 和摄像机的信息，调用内置 Shader 的 MeshRender 实例的 &lt;code&gt;draw&lt;/code&gt; 方法、传入摄像机、光源参数，以实现渲染整个场景中渲染所有 Mesh 和光源的功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MeshRenderer.ts&lt;/code&gt;：提供渲染一个 Mesh 的功能，通过保存一个模型的所有顶点、法线、材质、纹理坐标、缓冲等数据，在 &lt;code&gt;draw&lt;/code&gt; 函数中根据传入的 Transform、摄像机参数等实现在场景中渲染单个 Mesh&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;objects&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Mesh.ts&lt;/code&gt;：直接存储一个 Mesh 的各类数据，包括所有顶点坐标、顶点对应的法线方向、顶点对应的纹理坐标、每个三角形对应三个顶点的索引&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;materials&lt;/code&gt;：定义了各种项目所需的 Material，在作业 0 中只有 Blinn-Phong 模型的 Material 及其 Shader
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Materials.ts&lt;/code&gt;：保存了对赋予了该材质的表面进行渲染/着色的过程中所使用的着色器的源码，以及渲染管线中需要从外部传入的 &lt;code&gt;Uniforms&lt;/code&gt; 数据的名称，将要输入顶点着色器的各类 &lt;code&gt;Attributes&lt;/code&gt; 在顶点着色器中的变量名等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shaders&lt;/code&gt;：保存了项目所需的各类着色器的源码，以及从 WebGL 封装的着色器类
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Shader.ts&lt;/code&gt;：通过传入顶点着色器与片元着色器的源码、该源码需要关注的 &lt;code&gt;Attributes&lt;/code&gt; 与 &lt;code&gt;Uniforms&lt;/code&gt; 名称列表，编译着色器，并整理出所有需要关注的 &lt;code&gt;Attributes&lt;/code&gt; 的顶点着色器中的索引和 &lt;code&gt;Uniforms&lt;/code&gt; 在整个渲染管线中的 &lt;code&gt;WebGLUniformLocation&lt;/code&gt; 值，以便为 &lt;code&gt;Material&lt;/code&gt; 提供编译着色器与快速设置 &lt;code&gt;Attributes&lt;/code&gt; 和 &lt;code&gt;Uniforms&lt;/code&gt; 值的服务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;textures&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Texture.ts&lt;/code&gt;：向 &lt;code&gt;OBJ Loader&lt;/code&gt; 和 &lt;code&gt;Material&lt;/code&gt; 模块提供将 &lt;code&gt;HTMLImageElement&lt;/code&gt; 转换为 &lt;code&gt;WebGLTexture&lt;/code&gt; 的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loads&lt;/code&gt;：几种外部资源加载器
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;loadOBJ.ts&lt;/code&gt;：提供从本地加载模型资产的功能，通过传入 &lt;code&gt;WebGLRenderer&lt;/code&gt; 和文件路径，借助 &lt;code&gt;THREE.js&lt;/code&gt; 提供的 &lt;code&gt;MTLLoader&lt;/code&gt; 来从本地加载模型资产、纹理等数据，自动为 &lt;code&gt;MeshRender&lt;/code&gt; 创建 &lt;code&gt;Mesh&lt;/code&gt;，&lt;code&gt;Material&lt;/code&gt;，&lt;code&gt;Texture&lt;/code&gt; 数据并添加到 &lt;code&gt;WebGLRenderer&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loadShader.ts&lt;/code&gt;：允许用户从本地加载着色器源码，但因为我们使用 Vite 进行打包，可以在项目编译期直接以字符串形式在 JavaScript 代码中引入着色器源码，故 &lt;code&gt;loadShader&lt;/code&gt; 功能可弃用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;GAMES 202 Engine&lt;/h3&gt;
&lt;p&gt;这部分主要讲述程序入口处调用的第一个，也是唯一一个函数 &lt;code&gt;GAMES202Main&lt;/code&gt; 与包含这个函数的 &lt;code&gt;engine.ts&lt;/code&gt; 的功能。&lt;/p&gt;
&lt;h4&gt;总体功能&lt;/h4&gt;
&lt;p&gt;先总体说一下 &lt;code&gt;GAMES202Main&lt;/code&gt; 的功能：当浏览器打开本项目的页面时，Chrome 自动加载一同随 Web 应用打包的 JavaScript 文件，接着就会调用 &lt;code&gt;GAMES202Main&lt;/code&gt; 函数，在调用前，由 &lt;code&gt;index.html&lt;/code&gt; 定义的页面所对应的 DOM 树就已经生成。因此在 &lt;code&gt;GAMES202Main&lt;/code&gt; 中可以直接获取到页面中定义的 &lt;code&gt;canvas&lt;/code&gt; 元素，进而获取对应的 &lt;code&gt;WebGLRenderingContext&lt;/code&gt; 以便操作该 &lt;code&gt;canvas&lt;/code&gt; 的渲染。&lt;/p&gt;
&lt;p&gt;获取完 &lt;code&gt;WebGLRenderingContext&lt;/code&gt; 实例后就要准备渲染所需要的一系列参数了，&lt;code&gt;GAMES202Main&lt;/code&gt; 首先准备的是摄像机的参数。我们知道，不论是光栅化还是光线追踪渲染，定义摄像机实际上就是在定义摄像机位置、屏幕长宽比、场视角（FOV）、屏幕到摄像机的距离等，这些数据将用于定义光栅化渲染中的 MVP 矩阵或光线追踪中发射光线的范围限制，总之这些数据最终会转换为 GLSL 中某些 &lt;code&gt;Uniforms&lt;/code&gt; 参数。&lt;code&gt;GAMES202Main&lt;/code&gt; 使用 &lt;code&gt;THREE.js&lt;/code&gt; 的 &lt;code&gt;PerspectiveCamera&lt;/code&gt; 来构造摄像机实例，&lt;code&gt;PerspectiveCamera&lt;/code&gt; 可以仅通过 FOV、长宽比、最近最远距离来定义摄像机，进而计算 MVP 矩阵；此外程序还构造了一个同样由 &lt;code&gt;THREE.js&lt;/code&gt; 提供的 &lt;code&gt;OrbitControls&lt;/code&gt; 摄像机控制组件实例，可以通过修改该实例来控制摄像机的运动、朝向等，从而无需手动通过修改摄像机参数的方式来处理摄像机的运动。&lt;/p&gt;
&lt;p&gt;除了摄像机，&lt;code&gt;GAMES202Main&lt;/code&gt; 还会创建一个 &lt;code&gt;WebGLRenderer&lt;/code&gt; 对象，如前文所述，该对象是自定义的，可以为其指定 &lt;code&gt;WebGLRenderingContext&lt;/code&gt; 和由 &lt;code&gt;THREE.js&lt;/code&gt; 创建的摄像机对象，并向其中添加 &lt;code&gt;MeshRender&lt;/code&gt; 对象、光源对象等来实现渲染场景中的多个物体和光源。&lt;/p&gt;
&lt;p&gt;接着程序创建好场景所需的一个光源、得到一个 &lt;code&gt;PointLight&lt;/code&gt;，再从 &lt;code&gt;loadOBJ&lt;/code&gt; 加载要渲染的模型、获得一个 &lt;code&gt;MeshRender&lt;/code&gt;，并将它们都添加到 &lt;code&gt;WebGLRenderer&lt;/code&gt; 的渲染列表中。&lt;/p&gt;
&lt;p&gt;然后使用 &lt;code&gt;THREE.js&lt;/code&gt; 提供的 &lt;code&gt;dat.gui&lt;/code&gt; 库来快速向页面上添加一个基于 &lt;code&gt;HTML&lt;/code&gt; 元素的 GUI。&lt;/p&gt;
&lt;p&gt;最后，&lt;code&gt;GAMES202Main&lt;/code&gt; 陷入循环，在每一轮循环首先通过 &lt;code&gt;cameraControls&lt;/code&gt; 来更新摄像机参数，再使用 &lt;code&gt;WebGLRenderer&lt;/code&gt; 来更新 &lt;code&gt;canvas&lt;/code&gt; 元素中的渲染内容。&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;engine.ts&lt;/code&gt; 代码注释&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// 导入依赖项
import * as THREE from &apos;three&apos;;
import { OrbitControls } from &apos;three/examples/jsm/controls/OrbitControls&apos;;
import { PointLight } from &apos;./lights/PointLight&apos;;
import * as dat from &apos;dat.gui&apos;;
import { WebGLRenderer } from &apos;./renderers/WebGLRenderer&apos;;
import { loadOBJ } from &apos;./loads/loadOBJ&apos;;

// 定义摄像机的初始位置
var cameraPosition = [-20, 180, 250];

export function GAMES202Main() {
  // document 对象是 JavaScript 与前端网页中的 HTML 元素进行交互的接口
  // 这里是从 DOM 树中获取 id 为 glcanvas 的 HTMLCanvasElement 对象
  // querySelector 函数通过传入一个 CSS 选择器 &apos;#glcanvas&apos; 来从 DOM 树中筛选出
  // 第一个 id 为 glcanvas 的元素
  // &amp;lt;HTMLCanvasElement&amp;gt; 泛型表明期望返回 HTMLCanvasElement | null 类型的对象
  const canvas = document.querySelector&amp;lt;HTMLCanvasElement&amp;gt;(&apos;#glcanvas&apos;);
  
  if(canvas === null) {
    // 如果返回了 null，表明不存在 id 为 glcanvas 的 HTMLCanvasElement 元素
    console.log(&quot;can not find #glcanvas&quot;);
    return;
  }

  // 将 canvas 的长宽更新为浏览器视口的长和宽
  canvas.width = window.screen.width;
  canvas.height = window.screen.height;
  // 从 canvas 对象中获取 WebGLRenderingContext，便于后续控制画布渲染
  const gl = canvas.getContext(&apos;webgl&apos;);
  if (!gl) {
     // 如果没有成功获取，说明浏览器可能不支持 WebGL
    alert(&apos;Unable to initialize WebGL. Your browser or machine may not support it.&apos;);
    return;
  }

  // 使用 THREE.js 创建了一个透视投影摄像机，FOV = 75，长宽比为 canvas 自己的长宽比
  // 远点和近点分别为 1000 和 0.1
  const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
  // 创建一个摄像机控制对象，并将其绑定到先前创建的摄像机上
  const cameraControls = new OrbitControls(camera, canvas);
  // 设置摄像机的控制参数：
  // 允许缩放、旋转、移动
  // 旋转、缩放、移动速度分别为 0.3, 1.0, 2.0
  cameraControls.enableZoom = true;
  cameraControls.enableRotate = true;
  cameraControls.enablePan = true;
  cameraControls.rotateSpeed = 0.3;
  cameraControls.zoomSpeed = 1.0;
  cameraControls.keyPanSpeed = 2.0;

  // 封装设置摄像机长宽比的功能
  function setSize(width: number, height: number) {
    // 重新计算长宽比
    camera.aspect = width / height;
    // 根据新的长宽比重新计算投影变换矩阵
    // 即 MVP 矩阵变换中的 P
    camera.updateProjectionMatrix();
  }

  // 用画布的长宽比更新摄像机的长宽比及其投影变换矩阵
  setSize(canvas.clientWidth, canvas.clientHeight);

  // 监听浏览器视口的 resize 事件，以便在用户缩放视口时摄像机参数仍实时正确更新
  window.addEventListener(&apos;resize&apos;, () =&amp;gt; setSize(canvas.clientWidth, canvas.clientHeight));

  // 初始化摄像机位置
  camera.position.set(cameraPosition[0], cameraPosition[1], cameraPosition[2]);

  // 通过 camaeraControls 设置摄像机的朝向位置
  cameraControls.target.set(0, 1, 0);

  // 创建一个光源，并初始化其亮度、位置
  const pointLight = new PointLight(250, [1, 1, 1]);

  // 创建一个 WebGLRenderer 渲染器对象，并将 WebGL 渲染上下文和摄像机对象绑定到其上
  const renderer = new WebGLRenderer(gl, camera);
  // 向渲染器中添加光源
  renderer.addLight(pointLight);
  // 从本地的 assets/mary 目录中加载名为 Marry 的资源模型，并添加到渲染器对象中
  loadOBJ(renderer, &apos;assets/mary/&apos;, &apos;Marry&apos;);


  // 以下涉及 dat.GUI 的基本使用
  // 简单来说，这里先定义了需要使用 dat.GUI 控制的数据 guiParams
  // 使用 dat.GUI 创建一个 GUI 的实例后，使用 addFolder 来添加数据面板
  // 每个面板可以包含若干用来调整数据的 UI
  // 调用面板的 add 方法可以通过传入要操控的数据对象引用、操控的对象名称、
  // 和在面板中显示的对象名字，来实现将对象的某一字段绑定到面板中

  // 定义需要使用 dat.GUI 控制的数据：模型的 translation 和 scale
  // 分别初始化为 (0, 0, 0) 和 (52, 52, 52)
  var guiParams = {
    modelTransX: 0,
    modelTransY: 0,
    modelTransZ: 0,
    modelScaleX: 52,
    modelScaleY: 52,
    modelScaleZ: 52,
  }
  function createGUI() {
    // 创建一个 dat.GUI 实例
    const gui = new dat.GUI();
    // 创建一个总的面板，名为 panelModel
    const panelModel = gui.addFolder(&apos;Model properties&apos;);
    // 在 panelModel 下创建两个子面板，分别名为 Translation 和 Scale
    const panelModelTrans = panelModel.addFolder(&apos;Translation&apos;);
    const panelModelScale = panelModel.addFolder(&apos;Scale&apos;);
    // 在 Translation 面板下添加一个参数输入框与控制杆，
    // 表示将这个控件的值与 guiParams 中名为 modelTransX 的字段绑定起来
    // 每次在 UI 中更新它的值，都将更新 guiParams 的值
    // 并在面板中将这个值的名称显示为 X
    panelModelTrans.add(guiParams, &apos;modelTransX&apos;).name(&apos;X&apos;);
    // 其他 add 语句的含义与上述相同
    panelModelTrans.add(guiParams, &apos;modelTransY&apos;).name(&apos;Y&apos;);
    panelModelTrans.add(guiParams, &apos;modelTransZ&apos;).name(&apos;Z&apos;);
    panelModelScale.add(guiParams, &apos;modelScaleX&apos;).name(&apos;X&apos;);
    panelModelScale.add(guiParams, &apos;modelScaleY&apos;).name(&apos;Y&apos;);
    panelModelScale.add(guiParams, &apos;modelScaleZ&apos;).name(&apos;Z&apos;);
    // 依次展开 panelModel，panelModelTrans 和 panelModelScale 面板
    panelModel.open();
    panelModelTrans.open();
    panelModelScale.open();
  }

  // 创建 dat.GUI 实例并将 guiParams 绑定到 GUI 上
  createGUI();

  // requestAnimationFrame 是由浏览器提供的动画 API，可以认为传入的函数将在下一次浏览器更新动画时被执行
  // 传入的 mainLoop 是用于在每一帧进行渲染的主循环函数
  function mainLoop(now: number) {
    // cameraControls 实际上提供了使用鼠标、滚轮更新其参数的功能
    // 因此每一帧其中的数据都可能更新
    // 需要调用 update 来更新 cameraControls 自身的某些参数
    // 和被其控制的摄像机的参数
    cameraControls.update();

    // 使用新的（可能被用户通过 dat.GUI 更新的）guiParams 来对场景和模型进行重新渲染
    renderer.render(guiParams);

    // 在主循环结尾再次将自身传入 requestAnimationFrame 可以实现浏览器每帧动画更新时都重新渲染 canvas 的内容
    requestAnimationFrame(mainLoop);
  }
  // 在引擎各参数初始化完成后手动调用第一次 requestAnimationFrame 来进入主渲染循环
  requestAnimationFrame(mainLoop);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Renderer&lt;/h3&gt;
&lt;p&gt;要想渲染一个场景，首先需要一个对象用来管理整个场景中的所有物体，如摄像机、可渲染的 Mesh、灯光等。在本例中，除了场景本身的表示，我们还需要一种方式来表示场景中可以被渲染的每一个 Mesh。&lt;/p&gt;
&lt;h4&gt;总体功能&lt;/h4&gt;
&lt;p&gt;GAMES 202 的代码框架提供了 &lt;code&gt;WebGLRenderer&lt;/code&gt; 类来存储和管理整个场景中的摄像机、灯光和 Mesh 等数据，在 &lt;code&gt;engine.ts&lt;/code&gt; 的 &lt;code&gt;GAMES202Main&lt;/code&gt; 函数中，我们曾通过调用 &lt;code&gt;WebGLRenderer&lt;/code&gt; 函数来重新渲染整个场景，其内部实际上是先清空整块画布，接着在有光源的情况下使用两重循环来遍历场景中的所有光源，针对某一个光源再遍历场景中的所有物体，在每个物体渲染前为 Shader 通过 &lt;code&gt;Uniforms&lt;/code&gt; 设置光源的位置、强度等信息，再绘制物体，从而实现渲染一个单光源甚至多光源的场景。&lt;/p&gt;
&lt;p&gt;单个 Mesh 的表示和渲染方面，代码框架提供了 &lt;code&gt;MeshRender&lt;/code&gt; 来保存渲染一个 Mesh 所需要的 &lt;code&gt;Mesh&lt;/code&gt; 对象（包含使用 JavaScript 原生数据类型保存的顶点、法线、纹理坐标等数据）、材质、着色器实例，以及提供与 WebGL 交换数据的 &lt;code&gt;WebGLBuffer&lt;/code&gt; 的引用。&lt;code&gt;MeshRender&lt;/code&gt; 还提供 &lt;code&gt;draw&lt;/code&gt; 方法，在其内先向 WebGL 通过设置 &lt;code&gt;Attributes&lt;/code&gt; 来传递各类顶点坐标、法线、纹理坐标等数据，接着通过 &lt;code&gt;gl.uniformXXX&lt;/code&gt; 系列方法从材质实例和 &lt;code&gt;draw&lt;/code&gt; 函数参数中读取并设置 Shader 的各类 &lt;code&gt;Uniforms&lt;/code&gt; 渲染参数，最后调用 &lt;code&gt;gl.drawElements&lt;/code&gt; 来实现渲染单个物体。&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;WebGLRenderer.ts&lt;/code&gt; 代码注释&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// 导入依赖项
import { MeshRender } from &quot;./MeshRender&quot;;
import * as THREE from &quot;three&quot;;
import { PointLight } from &quot;../lights/PointLight&quot;;
import { vec3 } from &quot;gl-matrix&quot;;

// 保存一组 Transform 参数，包含位移和缩放信息，但保持物体旋转不变
// Remain rotatation
export class TRSTransform {
    // 位移数据
    translate: vec3;
    // 缩放数据
    scale: vec3;

    constructor(translate: vec3 = [0, 0, 0], scale: vec3 = [1, 1, 1]) {
        this.translate = translate;
        this.scale = scale;
    }
}

export class WebGLRenderer {
    // 保存场景中所有的 MeshRender
    meshes: MeshRender[] = [];
    // 保存场景中所有的光源
    // 包含光源本身的数据，以及光源模型自己的 MeshRender
    lights: {
        entity: PointLight;
        meshRender: MeshRender;
    }[] = [];

    // 保存目标画布的 WebGL 渲染上下文
    gl: WebGLRenderingContext;
    // 保存先前创建的透视投影摄像机的引用
    camera: THREE.PerspectiveCamera;

    // 构造函数，需要传入 WebGL 渲染上下文和相应的透视投影摄像机
    constructor(gl: WebGLRenderingContext, camera: THREE.PerspectiveCamera) {
        this.gl = gl;
        this.camera = camera;
    }

    // 添加一组点光源，除了保存点光源外，并使用光源对应的 Mesh 和材质创建一个光源对应的 MeshRender
    addLight(light: PointLight) {
        this.lights.push({
            entity: light,
            meshRender: new MeshRender(this.gl, light.mesh, light.mat),
        });
    }

    // 为场景添加一个 MeshRender
    addMesh(mesh: MeshRender) {
        this.meshes.push(mesh);
    }

    // 以 guiParams 包含的位移、缩放参数来重新渲染整个场景
    render(guiParams: {
        modelTransX: number;
        modelTransY: number;
        modelTransZ: number;
        modelScaleX: number;
        modelScaleY: number;
        modelScaleZ: number;
    }) {
        const gl = this.gl;

        // 将画布清空，像素充值为不透明黑色，同时重置 Z 深度，并重新启用深度测试
        gl.clearColor(0.0, 0.0, 0.0, 1.0); // Clear to black, fully opaque
        gl.clearDepth(1.0); // Clear everything
        gl.enable(gl.DEPTH_TEST); // Enable depth testing
        gl.depthFunc(gl.LEQUAL); // Near things obscure far things

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // 让场景中的光源以一种特定的周期性空间曲线路径移动
        // Handle light
        const timer = Date.now() * 0.00025;
        let lightPos: vec3 = [
            Math.sin(timer * 6) * 100,
            Math.cos(timer * 4) * 150,
            Math.cos(timer * 2) * 100,
        ];

        if (this.lights.length != 0) {
            for (let l = 0; l &amp;lt; this.lights.length; l++) {
                // 遍历场景中每一个光源，用当前的新的 lightPos 更新并渲染其 Mesh
                let trans = new TRSTransform(lightPos);
                this.lights[l].meshRender.draw(this.camera, trans);

                for (let i = 0; i &amp;lt; this.meshes.length; i++) {
                    const mesh = this.meshes[i];

                    // 对场景中每一个 MeshRender
                    // 先使用 guiParams 设置其位移和缩放
                    const modelTranslation: vec3 = [
                        guiParams.modelTransX,
                        guiParams.modelTransY,
                        guiParams.modelTransZ,
                    ];
                    const modelScale: vec3 = [
                        guiParams.modelScaleX,
                        guiParams.modelScaleY,
                        guiParams.modelScaleZ,
                    ];
                    let meshTrans = new TRSTransform(
                        modelTranslation,
                        modelScale
                    );

                    // 应用当前 MeshRender 的着色器程序
                    this.gl.useProgram(mesh.shader.program.glShaderProgram);
                    // 使用当前光源位置设置着色器的参数
                    // 着色器中关于光源参数的 uLightPos: WebGLUniformLocation 是在着色器初始化时赋值的
                    // 这里可以认为是将着色器程序中第 uLightPos 号 uniforms 参数的值设置为 lightPos
                    this.gl.uniform3fv(
                        mesh.shader.program.uniforms.uLightPos,
                        lightPos
                    );
                    // 传入摄像机和对应的 trans 来渲染该 Mesh
                    mesh.draw(this.camera, meshTrans);
                }
            }
        } else {
            // 如果没有任何光源，则跳过灯光渲染，直接渲染 Mesh
            // Handle mesh(no light)
            for (let i = 0; i &amp;lt; this.meshes.length; i++) {
                const mesh = this.meshes[i];
                let trans = new TRSTransform();
                mesh.draw(this.camera, trans);
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;MeshRender.ts&lt;/code&gt; 代码注释&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;import { mat4 } from &quot;gl-matrix&quot;;
import { Mesh } from &quot;../objects/Mesh&quot;;
import { Material } from &quot;../materials/Material&quot;;
import { Shader } from &quot;../shaders/Shader&quot;;
import * as THREE from &quot;three&quot;;
import { TRSTransform } from &quot;./WebGLRenderer&quot;;

export class MeshRender {
    // 渲染一个 Mesh 所需要的几组向 WebGL 传递数据的 WebGLBuffer
    // 这些 WebGLBuffer 都将通过 Attributes 来将 JavaScript 端的数据
    // 传递给 WebGL
    private vertexBuffer;
    private normalBuffer;
    private texcoordBuffer;
    private indicesBuffer;

    // 保存 WebGL 渲染上下文
    gl: WebGLRenderingContext;
    // 保存 Mesh 本身的顶点坐标、法线、纹理坐标等数据的对象
    mesh: Mesh;
    // 保存要渲染 Mesh 所需要的各类参数，包括各种 Uniforms 和 Textures
    material: Material;
    // 保存渲染一个 Mesh 所使用的着色器程序，
    // 在 MeshRender 初始化时进行编译
    shader: Shader;

    constructor(gl: WebGLRenderingContext, mesh: Mesh, material: Material) {
        // 从传入的参数初始化 gl, mesh, material 等数据
        this.gl = gl;
        this.mesh = mesh;
        this.material = material;

        // 通过 gl 对象为每一种 buffer 创建实例 
        this.vertexBuffer = gl.createBuffer();
        this.normalBuffer = gl.createBuffer();
        this.texcoordBuffer = gl.createBuffer();
        this.indicesBuffer = gl.createBuffer();

        let extraAttribs = [];
        if (mesh.hasVertices) {
            // 如果 mesh 包含顶点坐标信息
            // 保存该顶点坐标序列在着色器中对应的 attribute 名字
            extraAttribs.push(mesh.verticesName);
            // 将 mesh 存储在 JavaScript 端的顶点数据拷贝到 WebGL 端的 vertexBuffer
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }

        if (mesh.hasNormals) {
            // 如果 mesh 包含法线信息
            // 保存该法线序列在着色器中对应的 attribute 名字
            extraAttribs.push(mesh.normalsName);
            // 将 mesh 存储在 JavaScript 端的法线数据拷贝到 WebGL 端的 normalBuffer
            gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, mesh.normals, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }

        if (mesh.hasTexcoords) {
            // 如果 mesh 包含纹理坐标信息
            // 保存该纹理坐标序列在着色器中对应的 attribute 名字
            extraAttribs.push(mesh.texcoordsName);
            // 将 mesh 存储在 JavaScript 端的纹理坐标数据拷贝到 WebGL 端的 texcoordBuffer
            gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, mesh.texcoords, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }

        // mesh 默认需要有顶点索引，用来描述每个三角形由顶点坐标序列中的哪几个顶点构成
        // 这里将 mesh 包含的顶点索引数据拷贝到 indicesBuffer
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
        gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(mesh.indices),
            gl.STATIC_DRAW
        );
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        // 将新收集到的 attribute 数据名字添加到材质对象的 attribute 列表中
        this.material.setMeshAttribs(extraAttribs);
        // 重新从 material 对象中编译着色器
        this.shader = this.material.compile(gl);
    }

    draw(camera: THREE.PerspectiveCamera, transform: TRSTransform) {
        const gl = this.gl;

        // 创建 MVP 变换矩阵，
        // 其中模型变换和视口变换直接综合到一个 modelViewMatrix 矩阵中
        let modelViewMatrix = mat4.create();
        let projectionMatrix = mat4.create();

        camera.updateMatrixWorld();

        // 坐标变换算法推导：
        // X 表示顶点原坐标，X‘ 表示变换空间的坐标
        // P 表示投影变换矩阵，V 表示视口变换矩阵，M 表示模型变换矩阵
        // T 表示位移变换矩阵，S 表示缩放变换矩阵
        // M = S(T) = S T
        // X&apos; = P(V(M(X))) = P V M X
        // 由矩阵满足交换律，上式可变换为：X&apos; = P (V S T) X
        // projectionMatrix = P
        // modelViewMatrix = V S T

        // 对摄像机世界坐标求逆即可得到视口变换矩阵 V
        mat4.invert(
            modelViewMatrix,
            new Float32Array(camera.matrixWorld.elements)
        );
        // modelViewMatrix = V S T
        mat4.translate(modelViewMatrix, modelViewMatrix, transform.translate);
        mat4.scale(modelViewMatrix, modelViewMatrix, transform.scale);
        // projectionMatrix = P
        mat4.copy(
            projectionMatrix,
            new Float32Array(camera.projectionMatrix.elements)
        );

        if (this.mesh.hasVertices) {
            const numComponents = 3;
            const type = gl.FLOAT;
            const normalize = false;
            const stride = 0;
            const offset = 0;
            // 指示 WebGL 我们系统从 vertexBuffer 中提供 ARRAY_BUFFER 类型数据
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            // 将 vertexBuffer 绑定到顶点坐标在 Shader 中对应的地址
            // 地址/位置由 shader.program.attribs 提供，在编译 shader 时确定
            gl.vertexAttribPointer(
                this.shader.program.attribs[this.mesh.verticesName],
                numComponents,
                type,
                normalize,
                stride,
                offset
            );
            // 启用 vertexBuffer 对应地址的数据
            gl.enableVertexAttribArray(
                this.shader.program.attribs[this.mesh.verticesName]
            );
        }

        if (this.mesh.hasNormals) {
            const numComponents = 3;
            const type = gl.FLOAT;
            const normalize = false;
            const stride = 0;
            const offset = 0;
            // 指示 WebGL 我们系统从 normalBuffer 中提供 ARRAY_BUFFER 类型数据
            gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
            // 将 normalBuffer 绑定到顶点坐标在 Shader 中对应的地址
            gl.vertexAttribPointer(
                this.shader.program.attribs[this.mesh.normalsName],
                numComponents,
                type,
                normalize,
                stride,
                offset
            );
            // 启用 normalBuffer 对应地址的数据
            gl.enableVertexAttribArray(
                this.shader.program.attribs[this.mesh.normalsName]
            );
        }

        if (this.mesh.hasTexcoords) {
            const numComponents = 2;
            const type = gl.FLOAT;
            const normalize = false;
            const stride = 0;
            const offset = 0;
            // 指示 WebGL 我们系统从 texcoordBuffer 中提供 ARRAY_BUFFER 类型数据
            gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
            // 将 texcoordBuffer 绑定到顶点坐标在 Shader 中对应的地址
            gl.vertexAttribPointer(
                this.shader.program.attribs[this.mesh.texcoordsName],
                numComponents,
                type,
                normalize,
                stride,
                offset
            );
            // 启用 texcoordBuffer 对应地址的数据
            gl.enableVertexAttribArray(
                this.shader.program.attribs[this.mesh.texcoordsName]
            );
        }
        // 指示 WebGL 我们系统从 indicesBuffer 中提供 ARRAY_BUFFER 类型数据
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
        // 将 indicesBuffer 绑定到顶点坐标在 Shader 中对应的地址
        gl.useProgram(this.shader.program.glShaderProgram);

        // 向 Shader 中对应地址设置投影变换矩阵
        // 视口变换数据在 Shader 中的地址，即 WebGLUniformLocation，
        // 同样由着色器编译时确定
        gl.uniformMatrix4fv(
            this.shader.program.uniforms.uProjectionMatrix,
            false,
            projectionMatrix
        );
        // 向 Shader 中对应地址设置模型-视口变换矩阵
        gl.uniformMatrix4fv(
            this.shader.program.uniforms.uModelViewMatrix,
            false,
            modelViewMatrix
        );

        // 向 Shader 中对应地址设置摄像机坐标
        // Specific the camera uniforms
        gl.uniform3fv(this.shader.program.uniforms.uCameraPos, [
            camera.position.x,
            camera.position.y,
            camera.position.z,
        ]);

        for (let k in this.material.uniforms) {
            // 遍历材质中包含的其余 uniforms 参数，判断其类型，
            // 并向 Shader 对应位置设置 Uniforms 参数的值
            // 本代码框架支持设置 1 维整数，1 维浮点数，3 维浮点数，4 维浮点数
            // 以及材质数据
            const uniform = this.material.uniforms[k];
            if (uniform.type == &quot;matrix4fv&quot;) {
                gl.uniformMatrix4fv(
                    this.shader.program.uniforms[k],
                    false,
                    uniform.value
                );
            } else if (uniform.type == &quot;3fv&quot;) {
                gl.uniform3fv(this.shader.program.uniforms[k], uniform.value);
            } else if (uniform.type == &quot;1f&quot;) {
                gl.uniform1f(this.shader.program.uniforms[k], uniform.value);
            } else if (uniform.type == &quot;1i&quot;) {
                gl.uniform1i(this.shader.program.uniforms[k], uniform.value);
            } else if (uniform.type == &quot;texture&quot;) {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, uniform.value.texture);
                gl.uniform1i(this.shader.program.uniforms[k], 0);
            }
        }

        {
            // 所有参数设置完成后，以 TRIANGLES 使用顶点索引渲染模型
            const vertexCount = this.mesh.count;
            const type = gl.UNSIGNED_SHORT;
            const offset = 0;
            gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Mesh&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Mesh&lt;/code&gt; 是直接存储模型网格体的数据类型。&lt;/p&gt;
&lt;h4&gt;总体功能&lt;/h4&gt;
&lt;p&gt;要使用 &lt;code&gt;Mesh&lt;/code&gt; 来存储一个网格体，需要传入四个参数：&lt;code&gt;verticesAttrib&lt;/code&gt;，&lt;code&gt;normalsAttrib&lt;/code&gt;，&lt;code&gt;texcoordsAttrib&lt;/code&gt; 和 &lt;code&gt;indices&lt;/code&gt; 前三个参数的数据类型为 &lt;code&gt;AttribType&lt;/code&gt;，其内的 &lt;code&gt;name&lt;/code&gt; 字段表明该 &lt;code&gt;Attribute&lt;/code&gt; 在 Shader 中的变量名称是什么，使用 &lt;code&gt;Float32Array&lt;/code&gt; 类型的 &lt;code&gt;array&lt;/code&gt; 来存储数据本身。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;number[]&lt;/code&gt; 类型的 &lt;code&gt;indices&lt;/code&gt; 则是网格体的顶点索引。网格体中两个三角形的某两个顶点可能是共用的，如果以三角形的三个顶点的顺序直接存储整个网格体，将导致某些顶点的数据重复存储，导致空间上的浪费，因此一般使用顶点索引来解决这个问题，顶点索引序列的每三个元素表示构成一个三角形的三个顶点在顶点、法线、纹理坐标数组中的索引是哪一个，以额外一次访存的代价实现大幅减少顶点存储数量的性能优化。&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;Mesh.ts&lt;/code&gt; 代码注释&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// 声明 Attribute 的类型
interface AttribType {
    // 表明该 Attribute 在 Shader 中的变量名
    name: string;
    // 将要作为 Attribute 的数据本身
    array: Float32Array;
}

export class Mesh {
    // 顶点索引
    indices: number[];
    // 顶点索引的长度
    count: number;
    // 是否包含顶点坐标
    hasVertices: boolean;
    // 是否包含法线
    hasNormals: boolean;
    // 是否包含纹理坐标
    hasTexcoords: boolean;

    // 顶点坐标数据序列
    vertices: Float32Array = new Float32Array();
    // 顶点坐标数据在 Shader 中的变量名
    verticesName: string = &quot;&quot;;

    // 法线数据序列
    normals: Float32Array = new Float32Array();
    // 法线数据在 Shader 中的变量名
    normalsName: string = &quot;&quot;;

    // 纹理坐标数据序列
    texcoords: Float32Array = new Float32Array();
    // 纹理坐标数据在 Shader 中的变量名
    texcoordsName: string = &quot;&quot;;

    constructor(
        verticesAttrib: AttribType,
        normalsAttrib: AttribType | null,
        texcoordsAttrib: AttribType | null,
        indices: number[]
    ) {
        // 初始化顶点索引数据
        this.indices = indices;
        this.count = indices.length;
        // 默认没有顶点坐标、法线、纹理坐标数据
        this.hasVertices = false;
        this.hasNormals = false;
        this.hasTexcoords = false;
        let extraAttribs = [];

        if (verticesAttrib != null) {
            // 如果有顶点坐标数据，则赋值
            this.hasVertices = true;
            this.vertices = verticesAttrib.array;
            this.verticesName = verticesAttrib.name;
        }
        if (normalsAttrib != null) {
            // 如果有法线数据，则赋值
            this.hasNormals = true;
            this.normals = normalsAttrib.array;
            this.normalsName = normalsAttrib.name;
        }
        if (texcoordsAttrib != null) {
            // 如果有纹理坐标数据，则赋值
            this.hasTexcoords = true;
            this.texcoords = texcoordsAttrib.array;
            this.texcoordsName = texcoordsAttrib.name;
        }
    }

    static cube() {
        // 预先定义一个边长为 1 的立方体 Mesh，方便后续使用
        const positions = [
            // Front face
            -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0,
            // Back face
            -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0,
            // Top face
            -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0,
            // Bottom face
            -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0,
            // Right face
            1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0,
            // Left face
            -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0,
        ];
        const indices = [
            0, 1, 2, 0, 2, 3, // front
            4, 5, 6, 4, 6, 7, // back 
            8, 9, 10, 8, 10, 11, // top
            12, 13, 14, 12, 14, 15, // bottom
            16, 17, 18, 16, 18, 19, // right
            20, 21, 22, 20, 22, 23, // left
        ];
        return new Mesh(
            { name: &quot;aVertexPosition&quot;, array: new Float32Array(positions) },
            null,
            null,
            indices
        );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Material&lt;/h3&gt;
&lt;p&gt;材质 &lt;code&gt;Material&lt;/code&gt; 的概念是本项目需要理解的重难点内容。&lt;/p&gt;
&lt;p&gt;在光线追踪渲染中，一种物体表面的材质定义了光线到达该表面时反射的方向与起始点，体现但不仅限于 BRDF 定义的双向反射分布情况，纹理则决定了某种颜色的光在经过该表面反射后的新光线是什么颜色的；而在光栅化渲染中，材质定义了为该表面某一个像素进行着色的过程中所需要的各类参数，以及如何使用这些参数和场景中的各类信息来计算该像素颜色的值。&lt;/p&gt;
&lt;h4&gt;总体功能&lt;/h4&gt;
&lt;p&gt;GAMES 202 代码框架的 &lt;code&gt;Material&lt;/code&gt; 类属于上述光栅化渲染的材质类，其内部的 &lt;code&gt;flatten_uniforms: string[]&lt;/code&gt; 变量存储了渲染该材质的着色器所需的所有 &lt;code&gt;Uniforms&lt;/code&gt; 变量的名称；&lt;code&gt;flatten_attribs: string[]&lt;/code&gt; 和 &lt;code&gt;attribs: string&lt;/code&gt; 则存储了所有 &lt;code&gt;Attributes&lt;/code&gt; 类型的顶点数据的名称；&lt;code&gt;uniforms&lt;/code&gt; 则以 &lt;code&gt;Uniforms&lt;/code&gt; 类型变量的名称为 &lt;code&gt;key&lt;/code&gt;，以具体的数据类型和数据本身构成的对象为 &lt;code&gt;value&lt;/code&gt;，存储渲染该材质所需的各类数值、纹理等数据参数。&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;Material.ts&lt;/code&gt; 代码注释&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;import { Shader } from &quot;../shaders/Shader&quot;;
import { vec3, mat4 } from &apos;gl-matrix&apos;;
import { Texture } from &quot;../textures/Texture&quot;;

// 定义 Uniforms 的复合类型，通过 type 来判断 uniform 的类型，并给出正确类型的值
type Uniform =
    | {
          type: &quot;texture&quot;;
          value: Texture;
      }
    | {
          type: &quot;1i&quot;;
          value: number;
      }
    | {
          type: &quot;1f&quot;;
          value: number;
      }
    | {
          type: &quot;3fv&quot;;
          value: vec3;
      }
    | {
          type: &quot;uKd&quot;;
          value: number[];
      }
    | {
          type: &quot;matrix4fv&quot;;
          value: mat4;
      };
export class Material {
    // 保存所有 uniform 变量的名称
    private flatten_uniforms;
    // 保存所有 attribute 变量的名称
    private flatten_attribs;
    // vertex shader 的源码
    private vsSrc;
    // fragment shader 的源码
    private fsSrc;

    // uniform 变量与值的对应关系
    uniforms;
    // 保存所有 attribute 变量的名称
    attribs;

    // Uniforms is a map, attribs is a Array
    constructor(
        uniforms: {
            [index: string]: Uniform;
        },
        attribs: string[],
        vsSrc: string,
        fsSrc: string
    ) {
        // 初始化 uniforms, attribs 与着色器源码
        this.uniforms = uniforms;
        this.attribs = attribs;
        this.vsSrc = vsSrc;
        this.fsSrc = fsSrc;

        // 所有材质着色器都默认具有
        // 位移-视口变换矩阵，投影变换矩阵
        // 摄像机位置，光源位置参数
        this.flatten_uniforms = [
            &quot;uModelViewMatrix&quot;,
            &quot;uProjectionMatrix&quot;,
            &quot;uCameraPos&quot;,
            &quot;uLightPos&quot;,
        ];
        // 将其他 uniforms 的参数名添加到 flatten_uniforms 中
        for (let k in uniforms) {
            this.flatten_uniforms.push(k);
        }
        // 保持 flatten_attribs 和 attribs 一致
        this.flatten_attribs = attribs;
    }

    setMeshAttribs(extraAttribs: string[]) {
        // 添加额外的 Attribute 变量名
        for (let i = 0; i &amp;lt; extraAttribs.length; i++) {
            this.flatten_attribs.push(extraAttribs[i]);
        }
    }

    compile(gl: WebGLRenderingContext) {
        // 从源码编译 Shader，返回着色器程序和各类 Attribute，Uniform 变量名与地址的对应关系
        return new Shader(gl, this.vsSrc, this.fsSrc, {
            uniforms: this.flatten_uniforms,
            attribs: this.flatten_attribs,
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Shader&lt;/h3&gt;
&lt;p&gt;本节是本项目中最接近底层的内容，我们将讲述如何通过传入源码来获得一个由 WebGL 编译好的着色器子程序的，理解这一切的成本仅仅是了解 WebGL 的基本使用方法。&lt;/p&gt;
&lt;h4&gt;总体功能&lt;/h4&gt;
&lt;p&gt;GAMES 202 代码框架中 &lt;code&gt;Shader&lt;/code&gt; 类型的基本任务是从 &lt;code&gt;Material&lt;/code&gt; 端调用 &lt;code&gt;Shader&lt;/code&gt; 的构造函数，通过传入 Vertex Shader 和 Fragment Shader 的源码来编译并链接形成完整的着色器程序。&lt;/p&gt;
&lt;p&gt;此外，由于在着色器程序之上设置 &lt;code&gt;Attributes&lt;/code&gt; 和 &lt;code&gt;Uniforms&lt;/code&gt; 值的操作是非常频繁的，而一般要设置它们的值，一般要先从 WebGL 上下文中获取它们的地址，再将值设置到对应的地址上。为了避免反复获取变量地址的过程带来的麻烦，&lt;code&gt;Shader&lt;/code&gt; 类还提供 &lt;code&gt;addShaderLocations&lt;/code&gt; 的功能，通过传入一组 &lt;code&gt;Attributes&lt;/code&gt; 和 &lt;code&gt;Uniforms&lt;/code&gt; 的名称，指示 &lt;code&gt;Shader&lt;/code&gt; 类将这些变量名称对应的地址（索引、位置）保存到 &lt;code&gt;ProgramInfo&lt;/code&gt; 类的 &lt;code&gt;uniforms&lt;/code&gt; 和 &lt;code&gt;attribs&lt;/code&gt; 字段中，&lt;code&gt;ProgramInfo&lt;/code&gt; 还通过 &lt;code&gt;glShaderProgram&lt;/code&gt; 字段保存编译好的着色器程序的引用。&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;Shader.ts&lt;/code&gt; 代码注释&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// 一组着色器 attributes 和 uniforms 变量名字的记录
// 用于指示从编译好的着色器中查找对变量对应的地址
interface ShaderLocations {
    uniforms: string[] | null;
    attribs: string[] | null;
}

// 存储着色器信息的一组变量
interface ProgramInfo {
    // 编译好的着色器程序的引用
    glShaderProgram: WebGLProgram;
    // key 表示着色器程序中某个 uniform 变量的名字
    // value 表示该名字对应的地址（位置）
    uniforms: { [index: string]: WebGLUniformLocation };
    // key 表示着色器程序中某个 attribute 变量的名字
    // value 表示该名字对应的索引
    attribs: { [index: string]: number };
}

export class Shader {
    gl: WebGLRenderingContext;
    program: ProgramInfo;

    constructor(
        gl: WebGLRenderingContext,
        vsSrc: string,
        fsSrc: string,
        shaderLocations: ShaderLocations
    ) {
        this.gl = gl;
        // 从传入的源码中分别编译顶点着色器和片元着色器
        const vs = this.compileShader(vsSrc, gl.VERTEX_SHADER);
        const fs = this.compileShader(fsSrc, gl.FRAGMENT_SHADER);

        // 将编译好的着色器进行链接操作，
        // 并根据 shaderLocations 中的变量名查找出这些变量名在着色器程序中的位置
        this.program = this.addShaderLocations(
            {
                glShaderProgram: this.linkShader(vs, fs),
                uniforms: {},
                attribs: {},
            },
            shaderLocations
        );
    }

    // 通过提供的源码与类型编译着色器
    compileShader(shaderSource: string, shaderType: number) {
        const gl = this.gl;
        // 创建一个 WebGL 着色器实例
        var shader = gl.createShader(shaderType);

        if (shader === null) throw &quot;shader creator error&quot;;

        // 设置着色器源码与类型
        gl.shaderSource(shader, shaderSource);
        // 编译着色器
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            // 编译出错时打印错误信息
            console.error(shaderSource);
            console.error(
                &quot;shader compiler error:\n&quot; + gl.getShaderInfoLog(shader)
            );
        }

        return shader;
    }

    // 通过提供的顶点和片元着色器来链接并返回一个完整的着色器程序
    linkShader(vs: WebGLShader, fs: WebGLShader) {
        const gl = this.gl;
        // 创建一个 WebGL 着色器程序实例
        var prog = gl.createProgram();

        if (!prog) {
            throw &quot;shader creator error&quot;;
        }

        // 添加顶点着色器
        gl.attachShader(prog, vs);
        // 添加片元着色器
        gl.attachShader(prog, fs);
        // 链接两个着色器
        gl.linkProgram(prog);

        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            // 链接出错时打印错误信息
            throw `shader linker error:\n ${gl.getProgramInfoLog(prog)}`;
        }
        return prog;
    }

    addShaderLocations(
        result: ProgramInfo,
        shaderLocations: ShaderLocations | null
    ) {
        const gl = this.gl;
        // 初始化存储 uniform, attribute 名称与地址的对象的索引
        result.uniforms = {};
        result.attribs = {};

        if (
            shaderLocations &amp;amp;&amp;amp;
            shaderLocations.uniforms &amp;amp;&amp;amp;
            shaderLocations.uniforms.length
        ) {
            for (let i = 0; i &amp;lt; shaderLocations.uniforms.length; ++i) {
                // 遍历 shaderLocations 中所有的 uniform，
                // 以其名称为 key，对应的地址（位置）为 value，存储这两组变量的对应关系
                result.uniforms = Object.assign(result.uniforms, {
                    [shaderLocations.uniforms[i]]: gl.getUniformLocation(
                        result.glShaderProgram,
                        shaderLocations.uniforms[i]
                    ),
                });
                //console.log(gl.getUniformLocation(result.glShaderProgram, &apos;uKd&apos;));
            }
        }
        if (
            shaderLocations &amp;amp;&amp;amp;
            shaderLocations.attribs &amp;amp;&amp;amp;
            shaderLocations.attribs.length
        ) {
            for (let i = 0; i &amp;lt; shaderLocations.attribs.length; ++i) {
                // 遍历 shaderLocations 中所有的 attribute
                // 以其名称为 key，对应的索引为 value，存储这两组变量的对应关系
                result.attribs = Object.assign(result.attribs, {
                    [shaderLocations.attribs[i]]: gl.getAttribLocation(
                        result.glShaderProgram,
                        shaderLocations.attribs[i]
                    ),
                });
            }
        }

        return result;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Texture&lt;/h3&gt;
&lt;p&gt;纹理是图形渲染过程中所需的重要数据，大部分时候它是每个像素点着色的重要参数，另一些时候它用于保存物体的法线、表明凹凸性等信息&lt;/p&gt;
&lt;h4&gt;总体功能&lt;/h4&gt;
&lt;p&gt;在 Web 应用中，存储图片数据最主要的容器是 &lt;code&gt;HTMLImageElement&lt;/code&gt;，WebGL 从 JavaScript 端获取 &lt;code&gt;WebGLTexture&lt;/code&gt; 数据同样依赖 &lt;code&gt;HTMLImageElement&lt;/code&gt;。GAMES 202 作业代码框架提供了 &lt;code&gt;Texture&lt;/code&gt; 类来通过传入 &lt;code&gt;WebGLRenderingContext&lt;/code&gt; 和 &lt;code&gt;HTMLImageElement&lt;/code&gt; 来构造 &lt;code&gt;WebGLTexture&lt;/code&gt;、设置一系列参数、拷贝纹理数据。&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;Texture.ts&lt;/code&gt; 代码注释&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;export class Texture {
    // 存储 WebGL 可直接访问的图片纹理数据
    texture: WebGLTexture;

    constructor(gl: WebGLRenderingContext, img: HTMLImageElement) {
        // 创建 WebGLTexture 实例
        const texture = gl.createTexture();
        if (texture === null) {
            throw &quot;failed to create texture&quot;;
        }
        this.texture = texture;
        // 将创建出的 WebGLTexture 实例与 gl.TEXTURE_2D 绑定
        // 之后用 gl.TEXTURE_2D 这个枚举来操作纹理
        // 都相当于操作当前绑定的 WebGLTexture 实例
        gl.bindTexture(gl.TEXTURE_2D, this.texture);

        // 为当前绑定的 WebGLTexture 设置一系列参数
        // Because images have to be download over the internet
        // they might take a moment until they are ready.
        // Until then put a single pixel in the texture so we can
        // use it immediately. When the image has finished downloading
        // we&apos;ll update the texture with the contents of the image.
        const level = 0;    // LOD 级别为 0，即不生成 mipmap
        const internalFormat = gl.RGBA; // 图片是 RGBA 图像
        const width = 1;    // 宽设为 1
        const height = 1;   // 高设为 1
        const border = 0;   // 边界必须设为 0
        const srcFormat = gl.RGBA;  // 像素格式为 RGBA
        const srcType = gl.UNSIGNED_BYTE;   // 每个像素的数据类型是 unsigned byte
        const pixel = new Uint8Array([0, 0, 255, 255]); // opaque blue
        gl.texImage2D(
            gl.TEXTURE_2D,
            level,
            internalFormat,
            width,
            height,
            border,
            srcFormat,
            srcType,
            pixel
        );

        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        // 将图像做上下翻转预处理
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        // 将 HTMLImageElement 图像数据拷贝到 WebGLTexture 纹理
        gl.texImage2D(
            gl.TEXTURE_2D,
            level,
            internalFormat,
            srcFormat,
            srcType,
            img
        );

        // 如果图像的长宽都是 2 的幂
        // WebGL1 has different requirements for power of 2 images
        // vs non power of 2 images so check if the image is a
        // power of 2 in both dimensions.
        if (isPowerOf2(img.width) &amp;amp;&amp;amp; isPowerOf2(img.height)) {
            // 则为其生成 mipmap
            // Yes, it&apos;s a power of 2. Generate mips.
            gl.generateMipmap(gl.TEXTURE_2D);
        } else {
            // 否则将其水平和垂直方向设置为重复纹理
            // 图像缩放过程使用线性插值
            // 从而实现绘制非 2 次幂边长的图像
            // No, it&apos;s not a power of 2. Turn of mips and set
            // wrapping to clamp to edge
            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        }
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
}

function isPowerOf2(value: number) {
    // 要判断一个数是不是 2 的幂次
    // 相当于判断它的二进制表示下，是否除了最高位是 1 其他位都是 0，
    // 可以用如下规律来判断：
    // 一个数 x 是 2 的幂次，当且仅当 x - 1 除了最高位是 0，其他低位都是 1
    return (value &amp;amp; (value - 1)) == 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Loader&lt;/h3&gt;
&lt;p&gt;作为一个渲染器，从外部加载模型、着色器源码资源是必要的功能之一。&lt;/p&gt;
&lt;h4&gt;总体功能&lt;/h4&gt;
&lt;p&gt;GAMES 202 代码框架封装了两种加载器，其中一种用于从本地加载 &lt;code&gt;.mtl&lt;/code&gt; 和 &lt;code&gt;.obj&lt;/code&gt; 格式的模型资源；另一种用于加载着色器源码。由于我们已经使用了 Vite 来在编译器打包外部着色器源码资源，因此后一种加载器的原理将不过多赘述。&lt;/p&gt;
&lt;p&gt;对于 &lt;code&gt;loadOBJ&lt;/code&gt; 函数，这是一个使用 &lt;code&gt;THREE.js&lt;/code&gt; 的 &lt;code&gt;MTLLoader&lt;/code&gt; 和 &lt;code&gt;OBJLoader&lt;/code&gt; 进行封装的函数。它首先创建了一个 &lt;code&gt;THREE.LoadingManager&lt;/code&gt; 来便于我们观察加载的进度；接着创建一个 &lt;code&gt;MTLLoader&lt;/code&gt; 用来加载 &lt;code&gt;.mtl&lt;/code&gt; 格式的材质库文件，并调用 &lt;code&gt;load&lt;/code&gt; 函数、传入加载完成后的回调函数，&lt;code&gt;MTLLoader&lt;/code&gt; 在加载完成后调用回调函数、传入加载好的材质（纹理）相关数据；传入 &lt;code&gt;MTLLoader&lt;/code&gt; 的回调函数里创建了一个 &lt;code&gt;OBJLoader&lt;/code&gt; 用于加载 &lt;code&gt;.obj&lt;/code&gt; 模型的顶点、法线、纹理坐标等信息，该加载器同样具有加载完成的回调函数，该回调函数中传入了加载完成的模型实例，包含顶点、纹理等数据，用这些数据创建 &lt;code&gt;Mesh&lt;/code&gt;，&lt;code&gt;Texture&lt;/code&gt;，&lt;code&gt;Material&lt;/code&gt; 等数据实例，最终创建出一个 &lt;code&gt;MeshRender&lt;/code&gt; 并添加到 &lt;code&gt;WebGLRenderer&lt;/code&gt; 中，从而完成了从外部静态资源中加载模型数据并添加到场景中的功能。&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;loadOBJ.ts&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;import * as THREE from &quot;three&quot;;
import { MTLLoader } from &quot;three/examples/jsm/loaders/MTLLoader&quot;;
import { OBJLoader } from &quot;three/examples/jsm/loaders/OBJLoader&quot;;
import { Mesh } from &quot;../objects/Mesh&quot;;
import { Material } from &quot;../materials/Material&quot;;
import VertexShader from &quot;../shaders/InternalShader/VertexShader.glsl?raw&quot;;
import FragmentShader from &quot;../shaders/InternalShader/FragmentShader.glsl?raw&quot;;
import { MeshRender } from &quot;../renderers/MeshRender&quot;;
import { Texture } from &quot;../textures/Texture&quot;;
import { WebGLRenderer } from &quot;../renderers/WebGLRenderer&quot;;
import { BufferAttribute } from &quot;three&quot;;

export function loadOBJ(renderer: WebGLRenderer, path: string, name: string) {
    // 创建一个加载管理器，可以添加到 MTLLoader 和 OBJLoader 中以追踪加载进度
    const manager = new THREE.LoadingManager();
    manager.onProgress = function (item, loaded, total) {
        console.log(item, loaded, total);
    };

    // 定义打印 OBJLoader 自身加载进度的回调函数 
    function onProgress(xhr: ProgressEvent&amp;lt;EventTarget&amp;gt;) {
        if (xhr.lengthComputable) {
            const percentComplete = (xhr.loaded / xhr.total) * 100;
            console.log(
                // &quot;model &quot; + Math.round(percentComplete, 2) + &quot;% downloaded&quot;
                &quot;model &quot; + Math.round(percentComplete) + &quot;% downloaded&quot;
            );
        }
    }
    function onError() { }

    // 新建一个 MTLLoader，指定其加载外部资源的路径，并设置加载完成的回调函数
    new MTLLoader(manager)
        .setPath(path)
        .load(name + &quot;.mtl&quot;, function (materials) {
            // 这里被执行时表明 .mtl 文件已经加载完成，传入的是将要加载的材质纹理数据
            materials.preload();
            // 新建一个 OBJLoader，为其设置材质和资源路径，使用类似的方法来设置加载完成的回调函数
            new OBJLoader(manager)
                .setMaterials(materials)
                .setPath(path)
                .load(
                    name + &quot;.obj&quot;,
                    function (object) {
                        // 可能会加载到多个模型，因此需要遍历每一个模型来创建 MeshRender 
                        // 并添加到 WebGLRenderer
                        object.traverse(function (event) {
                            const child = event;

                            // 判断每个 event 是不是 THREE.Mesh
                            if (child instanceof THREE.Mesh &amp;amp;&amp;amp; child.isMesh) {
                                // 如果是，则取出它的几何数据和材质数据
                                let geo = child.geometry;
                                let mat = new THREE.MeshPhongMaterial;
                                // 不论只有一个材质还是多个材质，
                                // 都检查并转换为 MeshPhongMaterial
                                if (Array.isArray(child.material)) {
                                    let firstMaterial = child
                                        .material[0];
                                    if (firstMaterial instanceof THREE.MeshPhongMaterial) {
                                        mat = firstMaterial;
                                    }
                                }
                                else if (child.material instanceof THREE.MeshPhongMaterial) {
                                    mat = child.material;
                                }

                                // 从几何数据中取出顶点索引
                                var indices = Array.from(
                                    { length: geo.attributes.position.count },
                                    (v, k) =&amp;gt; k
                                );
                                // 如果存在顶点坐标、法线或纹理坐标数据，则一并取出
                                // 同时创建一个 Mesh 实例保存这些数据
                                let mesh = new Mesh(
                                    {
                                        name: &quot;aVertexPosition&quot;,
                                        array: new Float32Array(geo.attributes.position instanceof BufferAttribute ? geo.attributes.position.array : []),
                                    },
                                    {
                                        name: &quot;aNormalPosition&quot;,
                                        array: new Float32Array(geo.attributes.normal instanceof BufferAttribute ? geo.attributes.normal.array : []),
                                    },
                                    {
                                        name: &quot;aTextureCoord&quot;,
                                        array: new Float32Array(geo.attributes.uv instanceof BufferAttribute ? geo.attributes.uv.array : []),
                                    },
                                    indices
                                );

                                // 如果模型材质中包含纹理数据，则创建一个 Texture 实例
                                let colorMap: Texture | null = null;
                                if (mat.map != null)
                                    colorMap = new Texture(
                                        renderer.gl,
                                        mat.map.image
                                    );
                                // MARK: You can change the myMaterial object to your own Material instance

                                // 若存在纹理数据，在新创建的 Material 实例中添加该纹理数据
                                // 否则不添加任何纹理参数
                                let textureSample = 0;
                                let myMaterial;
                                if (colorMap != null) {
                                    textureSample = 1;
                                    myMaterial = new Material(
                                        {
                                            // 名为 uSampler 的材质参数
                                            // 类型为 texture，值为 colorMap
                                            uSampler: {
                                                type: &quot;texture&quot;,
                                                value: colorMap,
                                            },
                                            uTextureSample: {
                                                type: &quot;1i&quot;,
                                                value: textureSample,
                                            },
                                            uKd: {
                                                type: &quot;3fv&quot;,
                                                value: new Float32Array(mat.color.toArray() || []),
                                            },
                                        },
                                        [],
                                        VertexShader,
                                        FragmentShader
                                    );
                                } else {
                                    myMaterial = new Material(
                                        {
                                            uTextureSample: {
                                                type: &quot;1i&quot;,
                                                value: textureSample,
                                            },
                                            uKd: {
                                                type: &quot;3fv&quot;,
                                                value: new Float32Array(mat.color.toArray() || []),
                                            },
                                        },
                                        [],
                                        VertexShader,
                                        FragmentShader
                                    );
                                }

                                // 从模型资源中取出的各类数据准备好之后
                                // 用这些数据创建一个 MeshRender 实例
                                let meshRender = new MeshRender(
                                    renderer.gl,
                                    mesh,
                                    myMaterial
                                );
                                // 并将该 MeshRenderer 添加到 WebGLRenderer 中
                                renderer.addMesh(meshRender);
                            }
                        });
                    },
                    onProgress,
                    onError
                );
        });
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;loadShader.ts&lt;/code&gt; 代码注释&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;import * as THREE from &apos;three&apos;;

export function loadShaderFile(filename: string) {

    // 使用一个将由 Three.js 提供的加载操作放在一个 Promise 中进行，
    // 当加载完成后调用 resovle 表示加载完成
    // 外部使用时可以在 async 函数中使用 await 等待 resolve 执行完成
    // 也可以直接对 Promise 调用 then 方法获取该 Promise 中调用 resolve 所传入的参数
    // 实现异步加载 Shader 源码文件
    return new Promise((resolve, reject) =&amp;gt; {
        const loader = new THREE.FileLoader();
        loader.load(filename, (data) =&amp;gt; {
            resolve(data);
            //console.log(data);
        });
    });
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Lights&lt;/h3&gt;
&lt;p&gt;光源是代码框架中结构较为简单的类型。逻辑上光源只表示场景空间中的某处存在一个发光的物体，它具有一定的发光强度，可以照亮场景中的其他物体；表现上在渲染出的场景中具有具体的形态，可能是一个灯泡模型，也可能是其他，带有自己的 Mesh 和相应的材质。&lt;/p&gt;
&lt;h4&gt;总体功能&lt;/h4&gt;
&lt;p&gt;代码框架在光源部分提供了两个类型：&lt;code&gt;EmissiveMaterial&lt;/code&gt; 和 &lt;code&gt;PointLight&lt;/code&gt;。前者定义了一种特殊的材质，用来表现发光实体本身的视觉效果；后者定义了光源的具体数据，包括发光强度，使用什么样的 Mesh 表现它的形状等，同时保存了发光材质的引用。&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;Light.ts&lt;/code&gt; 代码注释&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;import { Material } from &apos;../materials/Material&apos;;
import LightCubeVertexShader from &quot;../shaders/InternalShader/LightCubeVertexShader.glsl?raw&quot;;
import LightCubeFragmentShader from &quot;../shaders/InternalShader/LightCubeFragmentShader.glsl?raw&quot;;
import { vec3 } from &apos;gl-matrix&apos;;


export class EmissiveMaterial extends Material {

    // 定义光源的发光强度
    intensity: number;
    // 定义发光的颜色
    color: vec3;

    constructor(lightIntensity: number, lightColor: vec3) {    
        // 构造材质实例，传入着色器源码和发光强度、颜色等参数
        super({
            &apos;uLigIntensity&apos;: { type: &apos;1f&apos;, value: lightIntensity },
            &apos;uLightColor&apos;: { type: &apos;3fv&apos;, value: lightColor }
        }, [], LightCubeVertexShader, LightCubeFragmentShader);
        
        this.intensity = lightIntensity;
        this.color = lightColor;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;PointLight.ts&lt;/code&gt; 代码注释&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;import { Mesh } from &apos;../objects/Mesh&apos;;
import { EmissiveMaterial } from &apos;./Light&apos;;
import { vec3 } from &apos;gl-matrix&apos;;

export class PointLight {
    /**
     * Creates an instance of PointLight.
     * @param {float} lightIntensity  The intensity of the PointLight.
     * @param {vec3f} lightColor The color of the PointLight.
     * @memberof PointLight
     */

    // 定义发光实体的网格体
    mesh: Mesh;
    // 保存渲染该实体所需的材质
    mat: EmissiveMaterial;

    constructor(lightIntensity: number, lightColor: vec3) {
        // 光源的形状默认是一个立方体
        this.mesh = Mesh.cube();
        this.mat = new EmissiveMaterial(lightIntensity, lightColor);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>使用 TS-Check 针对 React/Redux 项目的渐进式静态检查指南</title><link>https://blog.vonbrank.com/posts/using-ts-checker-in-react-redux-js-project/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/using-ts-checker-in-react-redux-js-project/</guid><description>渐进式地使用 Typescript 静态检查器为使用 JavaScript 构建的 React/Redux 应用做静态检查</description><pubDate>Sat, 17 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;最近正在尝试在自己参与的 JavaScript 前端项目中引入静态类型检查。&lt;/p&gt;
&lt;p&gt;至于引入的原因，很明显，源自 JavaScript 是一门【弱类型-动态类型】语言。这使得每次调用已写好的组件或者给已写好的组件打补丁时，都需要重新阅读相关组件的源代码、了解相关变量的类型，以确定可以在这些变量上调用哪些方法，然后再开始 Debug。肉眼检查代码很难完全发现和消除代码中的类型错误，这使得项目中频频出现 &lt;code&gt;Cannot read property &apos;x&apos; of undefined&lt;/code&gt; 或 &lt;code&gt;xxx.map is not a function&lt;/code&gt; 等问题。这些 &lt;code&gt;Uncaught Error&lt;/code&gt; 轻则使得某些功能无法使用，重则引起 React 引擎中断渲染，导致界面白屏（通常称为阻断性 bug）。此类 bug 往往需要很多时间进行排查，尤其是组件中存在异步事件时，bug 的修复将变得更加棘手。&lt;/p&gt;
&lt;p&gt;更糟糕的是，当项目引入 Redux 进行状态管理时，在不使用 Redux Toolkit 的情况下，不论是 Selector、Reducer ，还是 Dispatch、Action ，它们的信息都分布在项目的其他目录里的若干文件中，几乎无法通过阅读代码确定类型，只能通过 &lt;code&gt;console.log&lt;/code&gt; 进行调试。&lt;/p&gt;
&lt;p&gt;因此，每次调用组件或者 debug 时都感觉：“要是 JavaScript 是强类型的，或者项目使用 TypeScript 进行构建就好了” 。但是将拥有成百上千个文件的中大型项目迁移至 TypeScript 谈何容易？在此语境下，渐进式引入静态类型检查，乃至增量地迁移至 TypeScript 是解决这个场景下问题的方法。&lt;/p&gt;
&lt;h2&gt;为 React 组件引入类型声明&lt;/h2&gt;
&lt;h3&gt;引入 &lt;code&gt;d.ts&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;d.ts&lt;/code&gt; 文件是 TypeScript 的类型声明文件。与 C/C++ 中类的声明与实现分离类似，我们可以为任意 &lt;code&gt;js&lt;/code&gt; 文件创建一个同名的 &lt;code&gt;d.ts&lt;/code&gt; 文件，然后在 &lt;code&gt;d.ts&lt;/code&gt; 中声明这个 &lt;code&gt;js&lt;/code&gt; 中有哪些组件及其类型。在使用 JavaScript 编写的 React 项目中，编译阶段 webpack 的编译器会完全忽略 &lt;code&gt;d.ts&lt;/code&gt; 文件（貌似），因此引入 &lt;code&gt;d.ts&lt;/code&gt; 文件不会对现有项目的运行造成任何影响。&lt;/p&gt;
&lt;p&gt;虽然编译器会忽略 &lt;code&gt;d.ts&lt;/code&gt; 文件，但是 VSCode 和 WebStorm 自带的 TypeScript 静态检查器可以根据 &lt;code&gt;d.ts&lt;/code&gt; 指出潜在的类型错误，帮助我们发现 bug ，保证类型安全，从而提升代码质量。以下内容对前端常用开发工具 VSCode 和 WebStorm 均有效。&lt;/p&gt;
&lt;p&gt;假设你写的应用中有某一个登录组件，它大概长这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// App.jsx
import React from &quot;react&quot;;
import Login from &quot;./Login&quot;;

const App = () =&amp;gt; {
  const user = {
    username: &quot;Admin&quot;,
    password: &quot;123456&quot;,
  };
  const permission = &quot;Tier1&quot;;

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;Login user={user} permision={permission} /&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default App;

// Login.jsx
import React from &quot;react&quot;;

const Login = (props) =&amp;gt; {
const { user, permission } = props;

  return (
    &amp;lt;div&amp;gt;
      {permission.toLowerCase() == &quot;tier1&quot; &amp;amp;&amp;amp; &amp;lt;button&amp;gt;Edit&amp;lt;/button&amp;gt;}
      &amp;lt;p&amp;gt;{user.uesrname}&amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;{user.password}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default Login;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了实践本文所述内容，我们强烈建议您拷贝上述代码至本地，按照上述内容组织好文件布局，然后继续。&lt;/p&gt;
&lt;p&gt;很明显，这样的组件是类型不安全的，实际上此处给出的代码存在类型问题，将会导致 bug ，乃至中断渲染 （想一想为什么）。这些 bug 往往很难排查。&lt;/p&gt;
&lt;h3&gt;创建类型声明&lt;/h3&gt;
&lt;p&gt;这两个组件对应的 &lt;code&gt;d.ts&lt;/code&gt; 分别是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// App.d.ts
// 暂无内容

// Login.d.ts
export interface LoginProps {
  user?: {
    username: string;
    password: string;
  };
  permission: &quot;tier1&quot; | &quot;tier2&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你不会写 TypeScript 这里介绍几个 TypeScript 的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型系统：TypeScript 允许我们为所有变量声明类型，语法为 &lt;code&gt;const/let/var &amp;lt;变量名&amp;gt;: &amp;lt;类型&amp;gt;&lt;/code&gt; 。变量名写作 &lt;code&gt;&amp;lt;变量名&amp;gt;?&lt;/code&gt; 时表示它的类型为 &lt;code&gt;&amp;lt;类型&amp;gt; | undefine&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;interface&lt;/code&gt; 与 &lt;code&gt;type&lt;/code&gt; ：TypeScript 中的 &lt;code&gt;interface&lt;/code&gt; 与一般编程语言的 &lt;code&gt;interface&lt;/code&gt; 很不一样，它可以用于定义变量的类型。&lt;code&gt;type&lt;/code&gt; 是 TypeScript 中更接近 &lt;code&gt;interface&lt;/code&gt; 本质的东西，定义好的 &lt;code&gt;interface&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; 在使用上差别不大，大部分场景中 &lt;code&gt;type&lt;/code&gt; 与 &lt;code&gt;interface&lt;/code&gt; 可以混用，通常认为应该主要使用其中一种。如果你有选择困难症，可以遵循以下规则：能用 &lt;code&gt;interface&lt;/code&gt; 时就用 &lt;code&gt;interface&lt;/code&gt; ，&lt;code&gt;interface&lt;/code&gt; 实现不了你的需求时就用 &lt;code&gt;type&lt;/code&gt; 。上述 &lt;code&gt;LoginProps&lt;/code&gt; 用 &lt;code&gt;type&lt;/code&gt; 可以定义为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export type LoginProps = {
  user?: {
    username: string;
    password: string;
  };
  permission: &quot;tier1&quot; | &quot;tier2&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;联合类型（Union Type）：注意 &lt;code&gt;LoginProps&lt;/code&gt; 的 &lt;code&gt;permission&lt;/code&gt; 类型为 &lt;code&gt;&quot;tier1&quot; | &quot;tier2&quot;&lt;/code&gt; ，这表示 &lt;code&gt;permission&lt;/code&gt; 可以从 &lt;code&gt;&quot;tier1&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;tier2&quot;&lt;/code&gt; 中任取一种类型。TypeScript 认为任何特定字符串都是一个类型，他们都是类型 &lt;code&gt;string&lt;/code&gt; 的子集。&lt;code&gt;const permissionTier1: &quot;tier1&quot;;&lt;/code&gt; 表明 &lt;code&gt;permissionTier1&lt;/code&gt; 的类型为 &lt;code&gt;&quot;tier1&quot;&lt;/code&gt; ，其值只能是 &lt;code&gt;&quot;tier1&quot;&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;连接声明与实现&lt;/h2&gt;
&lt;h3&gt;编写 &lt;code&gt;JSDoc&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;以 &lt;code&gt;Login.jsx&lt;/code&gt; 为例，可以将代码修改为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// @ts-check
import React from &quot;react&quot;;

/**
 *
 * @param {import(&quot;./Login&quot;).LoginProps} props
 * @returns
 */
const Login = (props) =&amp;gt; {
const { user, permission } = props;

  return (
    &amp;lt;div&amp;gt;
      {permission.toLowerCase() == &quot;tier1&quot; &amp;amp;&amp;amp; &amp;lt;button&amp;gt;Edit&amp;lt;/button&amp;gt;}
      &amp;lt;p&amp;gt;{user?.username}&amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;{user?.password}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default Login;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种形式的注释被称为 JSDoc ，编辑器自带的 TypeScript 静态检查器可以通过 JSDoc 实现类型检查。这时候如果你在编辑器中将鼠标悬浮在 &lt;code&gt;user&lt;/code&gt; 上方可以清晰地看见它的类型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://vonbrank-images.oss-cn-hangzhou.aliyuncs.com/20221217-Use-TS-Checker-In-React-Redux-Project/image-20221217115303971.jpg&quot; alt=&quot;image-20221217115303971&quot; /&gt;&lt;/p&gt;
&lt;p&gt;同时注意到代码的最开始我们添加了一行 &lt;code&gt;// @ts-check&lt;/code&gt; 这在告诉 TS 静态检查器我们需要为这个文件启用静态检查。添加完成后代码中对 &lt;code&gt;user&lt;/code&gt; 的引用会出现红色警告，表明这里存在类型错误。此处的错误是，因为 &lt;code&gt;user&lt;/code&gt; 可能为 &lt;code&gt;undefined&lt;/code&gt; ，对 &lt;code&gt;undefined&lt;/code&gt; 引用 &lt;code&gt;username&lt;/code&gt; 属性将引发渲染中断造成白屏，TS 静态检查器发现了这一潜在错误，我们需要为 &lt;code&gt;user&lt;/code&gt; 变量的引用可选链运算符 &lt;code&gt;?&lt;/code&gt; 使得当 &lt;code&gt;user&lt;/code&gt; 为 &lt;code&gt;undefined&lt;/code&gt; 时直接返回 &lt;code&gt;undefined&lt;/code&gt; ，避免错误。&lt;/p&gt;
&lt;p&gt;如果你希望 TS 静态检查器忽略某一行，可以在前一行写上 &lt;code&gt;// @ts-ignore&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;：如果你创建 &lt;code&gt;d.ts&lt;/code&gt; 文件后发现对应 &lt;code&gt;js&lt;/code&gt; 文件并没有识别出 &lt;code&gt;d.ts&lt;/code&gt; 中的类型，请尝试在 VSCode 中关闭 &lt;code&gt;js&lt;/code&gt; 文件后再打开。&lt;/p&gt;
&lt;h3&gt;使用 &lt;code&gt;declare&lt;/code&gt; 语句&lt;/h3&gt;
&lt;p&gt;回到 &lt;code&gt;App.tsx&lt;/code&gt; ，现在我们为组件的调用应用类型检查。因为 &lt;code&gt;App&lt;/code&gt; 组件没有 &lt;code&gt;props&lt;/code&gt; 因此不需要在组件开头声明类型，不过还是要在文件开头添加 &lt;code&gt;// @ts-check&lt;/code&gt; 开静态检查。&lt;/p&gt;
&lt;p&gt;但是注意到此时 &lt;code&gt;Login&lt;/code&gt; 组件下方和红色报错，这是因为一旦为 &lt;code&gt;Login&lt;/code&gt; 创建 &lt;code&gt;d.ts&lt;/code&gt; 文件，TS 静态检查器将以 &lt;code&gt;Login.d.ts&lt;/code&gt; 文件为准获取组件信息，而不是 &lt;code&gt;Login.jsx&lt;/code&gt; ，而 &lt;code&gt;Login.d.ts&lt;/code&gt; 中没有包含任何 &lt;code&gt;Login&lt;/code&gt; 组件的信息，因此导致报错，注意此时项目仍然可以正常编译运行，因为正如前文所述，在使用 JavaScript 的 React 项目中 Webpack 编译器只关注 &lt;code&gt;.js/.jsx&lt;/code&gt; 文件，爆红仅仅是静态检查器的行为。&lt;/p&gt;
&lt;p&gt;为了修正错误，我们需要在 &lt;code&gt;Login.d.ts&lt;/code&gt; 声明 &lt;code&gt;Login&lt;/code&gt; 组件，告诉 TS 静态检查器 Login 是什么：现在将 &lt;code&gt;App.d.ts&lt;/code&gt; 和 &lt;code&gt;Login.d.ts&lt;/code&gt; 文件改为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// App.d.ts
import * as React from &quot;react&quot;;

declare const App: React.FC&amp;lt;{}&amp;gt;;
export default App;

// Login.d.ts
import * as React from &quot;react&quot;;

export interface LoginProps {
  user?: {
    username: string;
    password: string;
  };
  permission: &quot;tier1&quot; | &quot;tier2&quot;;
}

declare const Login: React.FC&amp;lt;LoginProps&amp;gt;;
export default Login;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;App&lt;/code&gt; 和 &lt;code&gt;Login&lt;/code&gt; 前添加 &lt;code&gt;declare&lt;/code&gt; 关键字是因为 &lt;code&gt;d.ts&lt;/code&gt; 中应该只包含 &lt;code&gt;Login&lt;/code&gt; 或 &lt;code&gt;App&lt;/code&gt; 的类型而没有具体实现，因此需要使用 &lt;code&gt;declare&lt;/code&gt; 关键字告诉 TS 静态检查器这里有一个名为 &lt;code&gt;Login&lt;/code&gt; 的 React 组件，其 Props 的类型为 &lt;code&gt;LoginProps&lt;/code&gt; ，真正的实现在项目的某处，由编译器自己去找。&lt;code&gt;React.FC&amp;lt;LoginProps&amp;gt;&lt;/code&gt; 实际上是 &lt;code&gt;React.FunctionComponent&amp;lt;LoginProps&amp;gt;&lt;/code&gt; 的别名，等价于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;declare const Login: (props: LoginProps) =&amp;gt; React.ReactElement&amp;lt;LoginProps&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在不涉及泛型的情况下，使用 &lt;code&gt;React.FC&amp;lt;&amp;gt;&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;为 &lt;code&gt;Login&lt;/code&gt; 组件添加类型声明后，我们将发现，TS 静态检查器在 &lt;code&gt;App&lt;/code&gt; 中了解到 &lt;code&gt;Login&lt;/code&gt; 组件的 Props 信息，知道所有 Props 应该类型，同时发现先前的代码中对 &lt;code&gt;Login&lt;/code&gt; 组件的 &lt;code&gt;permision&lt;/code&gt; 属性传入是一个拼写错误。因为 TS 了解类型信息，所以可以给出可靠的代码提示，根据代码提示修改错误即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://vonbrank-images.oss-cn-hangzhou.aliyuncs.com/20221217-Use-TS-Checker-In-React-Redux-Project/image-20221217122417832.jpg&quot; alt=&quot;image-20221217122417832&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最后给出最终修改好的所有代码：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;App.jsx&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// @ts-check
import React from &quot;react&quot;;
import Login from &quot;./Login&quot;;

const App = () =&amp;gt; {
  const user = {
    username: &quot;Admin&quot;,
    password: &quot;123456&quot;,
  };
  const permission = &quot;tier1&quot;;

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;Login user={user} permission={permission} /&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default App;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;App.d.ts&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import * as React from &quot;react&quot;;

declare const App: React.FC&amp;lt;{}&amp;gt;;
export default App;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Login.jsx&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// @ts-check
import React from &quot;react&quot;;

/**
 *
 * @param {import(&quot;./Login&quot;).LoginProps} props
 * @returns
 */
const Login = (props) =&amp;gt; {
  const { user, permission } = props;

  return (
    &amp;lt;div&amp;gt;
      {permission.toLowerCase() === &quot;tier1&quot; &amp;amp;&amp;amp; &amp;lt;button&amp;gt;Edit&amp;lt;/button&amp;gt;}
      &amp;lt;p&amp;gt;{user?.username}&amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;{user?.password}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default Login;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Login.d.ts&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import * as React from &quot;react&quot;;

export interface LoginProps {
  user?: {
    username: string;
    password: string;
  };
  permission: &quot;tier1&quot; | &quot;tier2&quot;;
}

declare const Login: React.FC&amp;lt;LoginProps&amp;gt;;
export default Login;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;实现 Redux 的类型安全&lt;/h2&gt;
&lt;p&gt;到目前为止，我们已经能够避免 React-JavaScript 项目中大部分由类型错误产生的 bug 。但是在引入 Redux 的项目中，Redux 部分的静态检查问题仍然没有解决。&lt;/p&gt;
&lt;p&gt;Redux 是一种前端状态管理库，在 React 应用中可以实现跨组件通信。这一部分将假设你了解 Redux 的使用方法，知道 Reducer、Action、Selector、Dispatch 等概念，并且使用的是原生 Redux 写法，而不是现在官方推荐的 Redux Toolkit 框架。&lt;/p&gt;
&lt;p&gt;此处给出一个在 React 项目中使用 Redux 的传统姿势：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// index.jsx
import store from &quot;./store&quot;
import App from &quot;./App&quot;
ReactDOM.render(
  &amp;lt;React.StrictMode&amp;gt;
      &amp;lt;Provider store={store}&amp;gt;
          &amp;lt;App /&amp;gt;
      &amp;lt;/Provider&amp;gt;
  &amp;lt;/React.StrictMode&amp;gt;,
  document.getElementById(&quot;root&quot;)
);

// store.js
import { applyMiddleware, combineReducers, createStore } from &quot;redux&quot;;
import thunk from &quot;redux-thunk&quot;;
import { composeWithDevTools } from &quot;redux-devtools-extension&quot;;
import { testLoginReducer } from &quot;./TestLoginReducer&quot;;
import { useDispatch, useSelector } from &quot;react-redux&quot;;

const rootReducer = combineReducers({
  testLogin: testLoginReducer,
});

const store = createStore(
  rootReducer,
  composeWithDevTools(applyMiddleware(thunk))
);

export default store;

// TestLoginReducer.js
import * as actions from &quot;./TestLoginAction&quot;;

const initialState = {
  user: null,
  loginTime: null,
};

export const testLoginReducer = (state = initialState, action) =&amp;gt; {
  switch (action.type) {
	// ...
  }
};

// TestLoginAction.js
export const TEST_LOGIN_LOGIN = &quot;testLogin/login&quot;;
export const TEST_LOGIN_LOGOUT = &quot;testLogin/logout&quot;;

// App.jsx
// @ts-check
import React from &quot;react&quot;;
import Login from &quot;./Login&quot;;
import { useSelector } from &quot;react-redux&quot;;

const App = () =&amp;gt; {
  const { user } = useSelector((state) =&amp;gt; ({
    user: state.testLogin.user,
  }));
  const permission = &quot;tier1&quot;;

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;Login user={user} permission={permission} /&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default App;

// Login.jsx
// @ts-check
import React from &quot;react&quot;;
import { useDispatch } from &quot;react-redux&quot;;

/**
 *
 * @param {import(&quot;./Login&quot;).LoginProps} props
 * @returns
 */
const Login = (props) =&amp;gt; {
  const { user, permission } = props;
  const dispatch = useDispatch();
  const handleLogin = () =&amp;gt; {
    dispatch({
      type: TEST_LOGIN_LOGIN,
      payload: {
        user: {
          username: &quot;Admin&quot;,
          password: &quot;123456&quot;,
        },
        timeStamp: new Date().toISOString(),
      },
    });
  };
  return (
    &amp;lt;div&amp;gt;
      {permission.toLowerCase() == &quot;tier1&quot; &amp;amp;&amp;amp; &amp;lt;button&amp;gt;Edit&amp;lt;/button&amp;gt;}
      &amp;lt;p&amp;gt;{user?.username}&amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;{user?.password}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default Login;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的代码示例中 &lt;code&gt;App&lt;/code&gt; 与 &lt;code&gt;Login&lt;/code&gt; 已经完成了静态检查，唯一不同的是 &lt;code&gt;App&lt;/code&gt; 中的 &lt;code&gt;user&lt;/code&gt; 从 Redux 中获取，&lt;code&gt;Login&lt;/code&gt; 中的 &lt;code&gt;handleLogin&lt;/code&gt; 可以修改 &lt;code&gt;testLoginState&lt;/code&gt; 中的内容，实际的项目中这里可能表示某个按钮的点击事件，然后进行登录。接着 &lt;code&gt;user&lt;/code&gt; 被更新，然后完成 UI 的更新。&lt;/p&gt;
&lt;p&gt;可以看到 TS 静态检查器在 &lt;code&gt;App&lt;/code&gt; 的 &lt;code&gt;useSelector&lt;/code&gt; 中给出了警告，因为此时 &lt;code&gt;state&lt;/code&gt; 的类型是 &lt;code&gt;DefaultState&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;一般来说，如果 bug 被定位到这段代码中，那么将非常难以调试。试想这样的场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;你发现 &lt;code&gt;user&lt;/code&gt; 可能是导致 bug 的原因，然后想看看 &lt;code&gt;user&lt;/code&gt; 里究竟有什么；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你鼠标悬停在 &lt;code&gt;user&lt;/code&gt; 想看看它是什么类型，TS 当然不知道它是什么类型，毕竟此时 &lt;code&gt;state&lt;/code&gt; 的类型是 &lt;code&gt;DefaultState&lt;/code&gt; ，代码编辑器将 &lt;code&gt;user&lt;/code&gt; 的类型显示为为 &lt;code&gt;any&lt;/code&gt; ；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你发现这是一个来自 Redux 中 &lt;code&gt;TestLogin&lt;/code&gt; 部分的 &lt;code&gt;State&lt;/code&gt; ；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接着你翻山越岭，找到了初始化 &lt;code&gt;state.testLogin.user&lt;/code&gt; 的地方——&lt;code&gt;TestLoginReducer.js&lt;/code&gt; 的 &lt;code&gt;initialState&lt;/code&gt; 变量内，然后从代码的海洋中（要知道一个 &lt;code&gt;reducer&lt;/code&gt; 中定义的 &lt;code&gt;State&lt;/code&gt; 一般来说很可能有几十甚至上百个 &lt;code&gt;property&lt;/code&gt;）找到了 &lt;code&gt;user&lt;/code&gt; 的初始化情况，然而却惊讶地发现它被初始化为 &lt;code&gt;null&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这将导致你无法仅通过代码了解到 &lt;code&gt;user&lt;/code&gt; 的具体情况，你不得不使用 &lt;code&gt;console.log&lt;/code&gt; 在运行时打印 &lt;code&gt;user&lt;/code&gt; 的值来确认其类型，如果仍为 &lt;code&gt;null&lt;/code&gt; ，那么意味着 bug 可能存在于与此状态相关的某个 &lt;code&gt;dispatch&lt;/code&gt; 异步事件中，此时你可能尝试搜索引用了能够修改 &lt;code&gt;user&lt;/code&gt; 值的那些 &lt;code&gt;action&lt;/code&gt; 的所有 &lt;code&gt;dispatch&lt;/code&gt; ，或者开始联系曾经接手过这部分代码的所有同事帮助你共同排查 bug ...&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总之这将会是一个艰难的过程。&lt;/p&gt;
&lt;p&gt;你可能会想到利用之前提到的的 JSDoc 在调用 &lt;code&gt;useSelector&lt;/code&gt; 时编写注释，让后来的人能够通过类型注解知道此处 &lt;code&gt;user&lt;/code&gt; 的类型，但是这不是一个根本上的解决方案，因为这意味着每次使用 &lt;code&gt;useSelector&lt;/code&gt; 都需要单独编写类型注释，比较麻烦，而且未必可靠。&lt;/p&gt;
&lt;p&gt;我们希望的是，让 &lt;code&gt;useSelector&lt;/code&gt; 了解 &lt;code&gt;state&lt;/code&gt; 的结构，从而使得传入的 &lt;code&gt;(state)=&amp;gt;({})&lt;/code&gt; 函数可以自动推导类型，直接得出 &lt;code&gt;user&lt;/code&gt; 的类型是 &lt;code&gt;{username: string; password: string} | undefined&lt;/code&gt; 的结论。同时我们还希望规范所有 &lt;code&gt;action&lt;/code&gt; 的类型，让所有 &lt;code&gt;type&lt;/code&gt; 的 &lt;code&gt;action&lt;/code&gt; 都只能对应特定类型的 &lt;code&gt;payload&lt;/code&gt; ，并且减少直接使用 &lt;code&gt;dispatch&lt;/code&gt; 的机会，转而使用一类被称为 &lt;code&gt;ActionCreator&lt;/code&gt; 的函数，通过仅通过调用带类型参数的返回 &lt;code&gt;action&lt;/code&gt; 的函数来帮助创建 &lt;code&gt;action&lt;/code&gt; 并且 &lt;code&gt;disptach&lt;/code&gt; 。&lt;/p&gt;
&lt;h3&gt;定义 &lt;code&gt;Action&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;上述 Redux 示例里有两个 &lt;code&gt;action&lt;/code&gt; ，均在 &lt;code&gt;TestLoginAction.js&lt;/code&gt; 下，和之前做类型检查的步骤一样，添加对应的 &lt;code&gt;TestLoginAction.d.ts&lt;/code&gt; 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export declare const TEST_LOGIN_LOGIN: &quot;testLogin/login&quot;;
export type TEST_LOGIN_LOGIN = typeof TEST_LOGIN_LOGIN;

interface User {
  username: string;
  password: string;
}

export interface ITestLoginLoginAction {
  type: TEST_LOGIN_LOGIN;
  payload: {
    user: User;
    timeStamp: string;
  };
}

export declare const TEST_LOGIN_LOGOUT: &quot;testLogin/logout&quot;;
export type TEST_LOGIN_LOGOUT = typeof TEST_LOGIN_LOGOUT;

export interface ITestLoginLogoutAction {
  type: TEST_LOGIN_LOGOUT;
}

export type TestLoginAction = ITestLoginLoginAction | ITestLoginLogoutAction;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们想要为每一种 &lt;code&gt;action&lt;/code&gt; 都指定对应的 &lt;code&gt;payload&lt;/code&gt; ，这可以使用 &lt;code&gt;interface&lt;/code&gt; 实现，这里有两种 &lt;code&gt;action&lt;/code&gt; —— &lt;code&gt;TEST_LOGIN_LOGIN&lt;/code&gt; 和 &lt;code&gt;TEST_LOGIN_LOGOUT&lt;/code&gt; ，其中 &lt;code&gt;TEST_LOGIN_LOGIN&lt;/code&gt; 这个 &lt;code&gt;action&lt;/code&gt; 需要特定类型的 &lt;code&gt;payload&lt;/code&gt; ，而另一个不需要，&lt;code&gt;TestLogin&lt;/code&gt; 的所有 &lt;code&gt;Action&lt;/code&gt; 类型被汇总为 &lt;code&gt;TestLoginAction&lt;/code&gt; 这种类型，它是所有 &lt;code&gt;Action&lt;/code&gt; 的联合类型。&lt;/p&gt;
&lt;h3&gt;声明 &lt;code&gt;State&lt;/code&gt; 的类型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TestLogin&lt;/code&gt; 的 &lt;code&gt;state&lt;/code&gt; 也需要确定类型，从上可知 &lt;code&gt;user&lt;/code&gt; 和 &lt;code&gt;loginTime&lt;/code&gt; 都可以是 &lt;code&gt;null&lt;/code&gt; ，实际上让它默认是 &lt;code&gt;undefined&lt;/code&gt; 也问题不大，除非需要和后端传来的数据做匹配，不过更好的做法是初始化 &lt;code&gt;username&lt;/code&gt; 和 &lt;code&gt;password&lt;/code&gt; 为 &lt;code&gt;&quot;&quot;&lt;/code&gt;。可以先在 &lt;code&gt;TestLoginReducer.d.ts&lt;/code&gt; 加上：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export interface TestLoginState {
  user?: {
    username: string;
    password: string;
  };
  loginTime?: string;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在 &lt;code&gt;TestLoginReducer.js&lt;/code&gt; 中声明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @typedef {import(&quot;./TestLoginReducer&quot;).TestLoginState} TestLoginState
 */

/**
 * @type {TestLoginState}
 */
const initialState = {
  user: {
    username: &quot;&quot;,
    password: &quot;&quot;,
  },
  loginTime: &quot;&quot;,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;类型安全的 &lt;code&gt;Reducer&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Redux 中的 Reducer 是一种泛型，其原型为 &lt;code&gt;Reducer&amp;lt;S, A&amp;gt; = (prevState: S, action: A) =&amp;gt; S&lt;/code&gt; ，源于 $\lambda$ 演算，意思是给定初始的 &lt;code&gt;state&lt;/code&gt; ，输入一个 &lt;code&gt;action&lt;/code&gt; 序列，最终得到另外一个 &lt;code&gt;state&lt;/code&gt; 。JavaScript 中的 &lt;code&gt;reduce&lt;/code&gt; 函数式接口概念与此类似。&lt;/p&gt;
&lt;p&gt;对于 &lt;code&gt;testLoginReducer&lt;/code&gt; 这个函数，可以直接将其声明为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @type {import(&quot;react&quot;).Reducer&amp;lt;TestLoginState, TestLoginAction&amp;gt;}
 */
export const testLoginReducer = (state = initialState, action) =&amp;gt; {
  switch (action.type) {
	// ...
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在 &lt;code&gt;testLoginReducer&lt;/code&gt; 中启用 &lt;code&gt;// @ts-check&lt;/code&gt; ，上述 &lt;code&gt;reducer&lt;/code&gt; 中的 &lt;code&gt;switch&lt;/code&gt; 语句是故意留空的，这时候代码会爆红，别急，稍后我们会来处理。接着还需要在 &lt;code&gt;TestLoginReducer.d.ts&lt;/code&gt; 中声明 &lt;code&gt;testLoginReducer&lt;/code&gt; 的存在，即添加代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { Reducer } from &quot;react&quot;;
import { TestLoginAction } from &quot;./TestLoginAction&quot;;
export declare const testLoginReducer: Reducer&amp;lt;TestLoginState, TestLoginAction&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时 &lt;code&gt;testLoginReducer&lt;/code&gt; 就是类型安全的了。&lt;/p&gt;
&lt;p&gt;现在我们可以试着写一下 &lt;code&gt;testLoginReducer&lt;/code&gt; 具体内容，将代码修改为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// @ts-check
import * as actions from &quot;./TestLoginAction&quot;;
/**
 * @typedef {import(&quot;./TestLoginReducer&quot;).TestLoginState} TestLoginState
 * @typedef {import(&quot;./TestLoginAction&quot;).TestLoginAction} TestLoginAction
 */

// ...

/**
 * @type {import(&quot;react&quot;).Reducer&amp;lt;TestLoginState, TestLoginAction&amp;gt;}
 */
export const testLoginReducer = (state = initialState, action) =&amp;gt; {
  switch (action.type) {
    case actions.TEST_LOGIN_LOGIN:
      const payload = action.payload;
      return {
        ...state,
        user: payload.user,
      };
    case actions.TEST_LOGIN_LOGOUT:
      return {
        ...state,
        user: undefined,
      };
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时爆红消失了。我们建议你手动编写这段代码而不是直接复制，然后你会发现，TS 静态检查器会在每个分支智能地判断出 &lt;code&gt;action&lt;/code&gt; 的类型，从而让 VSCode 给出可靠的代码提示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://vonbrank-images.oss-cn-hangzhou.aliyuncs.com/20221217-Use-TS-Checker-In-React-Redux-Project/image-20221217142026585.jpg&quot; alt=&quot;image-20221217142026585&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;带类型封装的 &lt;code&gt;useSelector&lt;/code&gt; 与 &lt;code&gt;useDispatch&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;最后，我们需要在使用 &lt;code&gt;dipsatch&lt;/code&gt; 和 &lt;code&gt;selector&lt;/code&gt; 时也能享受到类型静态类型检查的好处，提升代码质量。为实现这一点，我们需要封装自己的 &lt;code&gt;useSelector&lt;/code&gt; 和 &lt;code&gt;useDispatch&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;首先创建 &lt;code&gt;store.d.js&lt;/code&gt; ，添加如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { EmptyObject, Store } from &quot;redux&quot;;
import { TestLoginState } from &quot;./TestLoginReducer&quot;;
import { TypedUseSelectorHook, useDispatch } from &quot;react-redux&quot;;
import { Dispatch } from &quot;react&quot;;
import { TestLoginAction } from &quot;./TestLoginAction&quot;;

export type RootState = {
  testLogin: TestLoginState;
};

export type RootAction = TestLoginAction;

export type AppDispatch = Dispatch&amp;lt;RootAction&amp;gt;;

export declare const store: Store&amp;lt;EmptyObject&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们先定义好整个 &lt;code&gt;state&lt;/code&gt; 的类型，因为在 &lt;code&gt;combineReducers&lt;/code&gt; 里我们写道：&lt;code&gt;testLogin: testLoginReducer&lt;/code&gt; ，那么 &lt;code&gt;TestLoginState&lt;/code&gt; 在所谓 &lt;code&gt;RootState&lt;/code&gt; 的属性名就是 &lt;code&gt;testLogin&lt;/code&gt; ，将来引入其他 &lt;code&gt;Reducer&lt;/code&gt; 时同理。&lt;/p&gt;
&lt;p&gt;然后定义 &lt;code&gt;RootAction&lt;/code&gt; 的类型，这是整个项目所有 &lt;code&gt;Action&lt;/code&gt; 的联合类型（此处只有一类 &lt;code&gt;Action&lt;/code&gt; 即 &lt;code&gt;TestLoginAction&lt;/code&gt;）。接着定义自己的 &lt;code&gt;dispatch&lt;/code&gt; 类型，即 &lt;code&gt;AppDispatch: Dispatch&amp;lt;RootAction&amp;gt;&lt;/code&gt; ，这里的意思是凡是使用这种类型的 &lt;code&gt;dispatch&lt;/code&gt; 时，传入的 &lt;code&gt;Action&lt;/code&gt; 都必须是 &lt;code&gt;RootAction&lt;/code&gt;  中的某一个实例，即在 &lt;code&gt;RootAction&lt;/code&gt; 中注册的任意一种 &lt;code&gt;Action&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;接着，注意到我们在 &lt;code&gt;store.js&lt;/code&gt;中 &lt;code&gt;export&lt;/code&gt; 了 &lt;code&gt;store&lt;/code&gt; 这种变量，因此需要在 &lt;code&gt;store.d.ts&lt;/code&gt; 中声明这个变量。由于 &lt;code&gt;createStore&lt;/code&gt; 方法是一个过时的 API ，&lt;code&gt;store&lt;/code&gt; 的类型变得无关紧要，所以简单声明为  &lt;code&gt;Store&amp;lt;EmptyObject&amp;gt;&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;最后，创建 &lt;code&gt;hooks.js&lt;/code&gt; 和 &lt;code&gt;hooks.d.ts&lt;/code&gt; ，内容分别为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hooks.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { useDispatch, useSelector } from &quot;react-redux&quot;;

export const useAppSelector = useSelector;
export const useAppDispatch = useDispatch;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;hooks.d.ts&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { TypedUseSelectorHook } from &quot;react-redux&quot;;
import { AppDispatch, RootState } from &quot;./store&quot;;

export declare const useAppSelector: TypedUseSelectorHook&amp;lt;RootState&amp;gt;;
export declare const useAppDispatch: () =&amp;gt; AppDispatch;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，我们可以在组件中使用类型安全的 &lt;code&gt;useAppSelector&lt;/code&gt; 和 &lt;code&gt;useAppDispatch&lt;/code&gt; 来与 Redux 交互了。&lt;/p&gt;
&lt;p&gt;回到 &lt;code&gt;App.jsx&lt;/code&gt; ，将代码修改为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// @ts-check
import React from &quot;react&quot;;
import Login from &quot;./Login&quot;;
import { useAppSelector } from &quot;./hooks&quot;;

const App = () =&amp;gt; {
  const { user } = useAppSelector((state) =&amp;gt; ({
    user: state.testLogin.user,
  }));

  const permission = &quot;tier1&quot;;

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;Login user={user} permission={permission} /&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default App;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你将会惊奇地发现使用 &lt;code&gt;useAppSelector&lt;/code&gt; 时 &lt;code&gt;state&lt;/code&gt; 是包含类型信息的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://vonbrank-images.oss-cn-hangzhou.aliyuncs.com/20221217-Use-TS-Checker-In-React-Redux-Project/image-20221217144515583.jpg&quot; alt=&quot;image-20221217144515583&quot; /&gt;&lt;/p&gt;
&lt;p&gt;同样地在 &lt;code&gt;Login.jsx&lt;/code&gt; 中使用全新的 &lt;code&gt;useAppDispatch&lt;/code&gt; ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// @ts-check
import React from &quot;react&quot;;
import { TEST_LOGIN_LOGIN } from &quot;./TestLoginAction&quot;;
import { useAppDispatch } from &quot;./hooks&quot;;

/**
 *
 * @param {import(&quot;./Login&quot;).LoginProps} props
 * @returns
 */
const Login = (props) =&amp;gt; {
  const { user, permission } = props;
  const dispatch = useAppDispatch();

  const handleLogin = () =&amp;gt; {
    dispatch({
      type: TEST_LOGIN_LOGIN,
      payload: {
        user: {
          username: &quot;Admin&quot;,
          password: &quot;123456&quot;,
        },
        timeStamp: new Date().toISOString(),
      },
    });
  };

  return (
    &amp;lt;div&amp;gt;
      {permission.toLowerCase() == &quot;tier1&quot; &amp;amp;&amp;amp; &amp;lt;button&amp;gt;Edit&amp;lt;/button&amp;gt;}
      &amp;lt;p&amp;gt;{user?.username}&amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;{user?.password}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default Login;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里使用 &lt;code&gt;dispatch&lt;/code&gt; 时也可以给出可靠的代码提示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://vonbrank-images.oss-cn-hangzhou.aliyuncs.com/20221217-Use-TS-Checker-In-React-Redux-Project/image-20221217144702916.jpg&quot; alt=&quot;image-20221217144702916&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;实现 &lt;code&gt;ActionCreator&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;比起本文所述的 Redux 的使用方法，Redux 官方目前更加推荐另一种写法，即前文数次提到的 Redux Toolkit。Redux Toolkit 是一种对 Redux 更高层次的封装，要使用它实现上述 &lt;code&gt;TestLoginState&lt;/code&gt; 需求，代码可以是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// TestLoginSlice.ts
import { createSlice, PayloadAction } from &quot;@reduxjs/toolkit&quot;;

interface User {
  username: string;
  password: string;
}

interface TestLoginState {
  user?: User;
  loginTime?: string;
}

const initialState: TestLoginState = {
  user: {
    username: &quot;&quot;,
    password: &quot;&quot;,
  },
  loginTime: &quot;&quot;,
};

export const testLoginSlice = createSlice({
  name: &quot;testLogin&quot;,
  initialState,
  reducers: {
    login: (
      state,
      action: PayloadAction&amp;lt;{
        user: User;
        timeStamp: string;
      }&amp;gt;
    ) =&amp;gt; {
      const payload = action.payload;
      state.user = payload.user;
      state.loginTime = payload.timeStamp;
    },
    logout: (state) =&amp;gt; {
      state.user = undefined;
    },
  },
});

export const { login, logout } = testLoginSlice.actions;

export default testLoginSlice.reducer;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们注意到，传统的 Redux 写法需要手动编写 &lt;code&gt;Reducer&amp;lt;S, A&amp;gt;&lt;/code&gt; 函数，形成大量模板代码，有时候这是难以维护的。Redux Toolkit 的开发者注意到 &lt;code&gt;action.type&lt;/code&gt; 大部分时候是可以对开发者隐藏的，因此使用 &lt;code&gt;Slice&lt;/code&gt;  来将 &lt;code&gt;Reducer&lt;/code&gt; 和 &lt;code&gt;Action&lt;/code&gt; 统一起来。&lt;/p&gt;
&lt;p&gt;上述代码中 &lt;code&gt;export&lt;/code&gt; 的 &lt;code&gt;login&lt;/code&gt; 和 &lt;code&gt;logout&lt;/code&gt; 并不是带有 &lt;code&gt;type&lt;/code&gt; 属性的 &lt;code&gt;action&lt;/code&gt; 实例，而是生成 &lt;code&gt;action&lt;/code&gt; 的函数，称为 &lt;code&gt;ActionCreator&lt;/code&gt; 。以 &lt;code&gt;login&lt;/code&gt; 为例，注意到 &lt;code&gt;reducers&lt;/code&gt; 中写着 &lt;code&gt;login&lt;/code&gt; 的函数签名为 ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(state, action: PayloadAction&amp;lt;{user: User; timeStamp: string;}&amp;gt;) =&amp;gt; void
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;action&lt;/code&gt; 的类型实际上是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  type: string;
  payload: {
    user: User; 
    timeStamp: string;
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而下方 &lt;code&gt;export&lt;/code&gt; 的 &lt;code&gt;login&lt;/code&gt; 是一个类型为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(payload: { user: User; timeStamp: string; }) =&amp;gt; { 
  type: string; 
  payload: { user: User; timeStamp: string; }; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;的 &lt;code&gt;ActionCreator&lt;/code&gt; ，返回的正是一个 &lt;code&gt;action&lt;/code&gt; ，一般来说，实际执行的时候 &lt;code&gt;type&lt;/code&gt; 的值将满足 Redux Toolkit 的命名规范： &lt;code&gt;testLogin/login&lt;/code&gt; ，&lt;code&gt;dispatch&lt;/code&gt; 再根据这个 &lt;code&gt;type&lt;/code&gt; 选择 &lt;code&gt;reducers&lt;/code&gt; 中的某个方法执行。&lt;/p&gt;
&lt;p&gt;虽然 Redux Toolkit 有诸多好处，既可以化简代码，又保证了类型安全，但是很可惜，从原生 Redux 写法迁移到 Redux Toolkit 的难度不会比一次性从 JavaScript 迁移到 TypeScript 低多少，因为直接迁移意味着所有显示构造 &lt;code&gt;action&lt;/code&gt; 并执行 &lt;code&gt;dispatch&lt;/code&gt; 的语句都需要进行修改，还需要改写所有 &lt;code&gt;Reducer&amp;lt;S, A&amp;gt;&lt;/code&gt; 。就目前我正在尝试引入静态检查的项目而言，这类 &lt;code&gt;dispatch&lt;/code&gt; 的调用超过 $2,200$ 处，未来还将持续增加。因此直接迁移到 Redux Toolkit 几乎不可行。&lt;/p&gt;
&lt;p&gt;不过我们还是可以通过手动创建 &lt;code&gt;ActionCreator&lt;/code&gt; 来简化 &lt;code&gt;dispatch&lt;/code&gt; 的调用。以前文提到的 &lt;code&gt;login&lt;/code&gt; 和 &lt;code&gt;logout&lt;/code&gt; 为例。我们只需要在 &lt;code&gt;TestLoginAction.js&lt;/code&gt; 中添加两个函数 &lt;code&gt;loginAction&lt;/code&gt; 和 &lt;code&gt;logoutAction&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// @ts-check
export const TEST_LOGIN_LOGIN = &quot;testLogin/login&quot;;
export const TEST_LOGIN_LOGOUT = &quot;testLogin/logout&quot;;

/**
 * @type {import(&quot;./TestLoginAction&quot;).LoginAction}
 */
export const loginAction = (user) =&amp;gt; ({
  type: TEST_LOGIN_LOGIN,
  payload: {
    user: user,
    timeStamp: new Date().toISOString(),
  },
});

/**
 * @type {import(&quot;./TestLoginAction&quot;).LogoutAction}
 */
export const logoutAction = () =&amp;gt; ({
  type: TEST_LOGIN_LOGOUT,
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在 &lt;code&gt;TestLoginAction.d.ts&lt;/code&gt; 中将其声明为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export type LoginAction = (user: User) =&amp;gt; ITestLoginLoginAction;
export declare const loginAction: LoginAction;
export type LogoutAction = () =&amp;gt; ITestLoginLogoutAction;
export declare const logoutAction: LogoutAction;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们就完成了 &lt;code&gt;ActionCreator&lt;/code&gt; 的手动创建。&lt;/p&gt;
&lt;p&gt;之后就可以使用形如 &lt;code&gt;dispatch(loginAction(...))&lt;/code&gt; 的写法修改 Redux State 的状态了。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;一名开发者今天写的代码不仅为了完成当下的任务，还是现在与未来交流的桥梁。我们所做的一切都是为了提升代码的可读性，在未来的自己或他人回来再看这段代码、重构或修复 bug 时能迅速领会其含义、发现其中的错误，从而减少未来维护的成本、提升编码体验。这也是静态类型检查的目的。&lt;/p&gt;
&lt;p&gt;遵照上述方法，我们可以渐进式地在使用 JavaScript 编写的 React-Redux 应用类型检查，直至整个项目几乎完全实现类型安全。&lt;/p&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TypeScript 渐进迁移指南：https://segmentfault.com/a/1190000038963440&lt;/li&gt;
&lt;li&gt;利用 TS-Check 对 JavaScript 进行静态类型检测：https://daotin.netlify.app/fw8lsf.html&lt;/li&gt;
&lt;li&gt;TypeScript + React + Redux = ❤️: https://zhuanlan.zhihu.com/p/74749048&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;附录&lt;/h2&gt;
&lt;h3&gt;一些常用的 Typescript 类型声明示例&lt;/h3&gt;
&lt;p&gt;因为这不是一本字典，所以这里采用 Q&amp;amp;A 的形式给出一些示例：&lt;/p&gt;
&lt;h4&gt;如何封装一个 Material-UI 组件？&lt;/h4&gt;
&lt;p&gt;以封装一个 &lt;code&gt;Box&lt;/code&gt; 为例，假设你想要封装一个最外层为 &lt;code&gt;Box&lt;/code&gt; 的组件，你想要这个组件的 &lt;code&gt;Props&lt;/code&gt; 暴露给外部时让人感觉它是一个包含额外功能的 &lt;code&gt;Box&lt;/code&gt; ，只需要让这个组件的 &lt;code&gt;Props&lt;/code&gt; 的类型继承 &lt;code&gt;BoxProps&lt;/code&gt; （MUI 中的所有组件都有其 &lt;code&gt;Props&lt;/code&gt; 的 &lt;code&gt;type&lt;/code&gt; 可以直接 &lt;code&gt;import&lt;/code&gt;） ，以刚才的 &lt;code&gt;Login&lt;/code&gt; 组件为例，假设其最外层为 &lt;code&gt;Box&lt;/code&gt; ，希望拥有 &lt;code&gt;Box&lt;/code&gt; 的所有属性，可以写为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Login.d.ts&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import * as React from &quot;react&quot;;
import { BoxProps } from &quot;@mui/material&quot;;

export interface LoginProps extends BoxProps {
  user?: {
    username: string;
    password: string;
  };
  permission: &quot;tier1&quot; | &quot;tier2&quot;;
}

declare const Login: React.FC&amp;lt;LoginProps&amp;gt;;
export default Login;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Login.jsx&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// @ts-check
import React from &quot;react&quot;;
import { Box } from &quot;@mui/material&quot;;
import { TEST_LOGIN_LOGIN } from &quot;./TestLoginAction&quot;;

/**
 *
 * @param {import(&quot;./Login&quot;).LoginProps} props
 * @returns
 */
const Login = (props) =&amp;gt; {
  const { user, permission, sx, children, ...oterhs } = props;
  return (
    &amp;lt;Box
      sx={{
        padding: &quot;1.6rem&quot;,
        ...sx,
      }}
      {...oterhs}
    &amp;gt;
      {permission.toLowerCase() == &quot;tier1&quot; &amp;amp;&amp;amp; &amp;lt;button&amp;gt;Edit&amp;lt;/button&amp;gt;}
      &amp;lt;p&amp;gt;{user?.username}&amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;{user?.password}&amp;lt;/p&amp;gt;
      {children}
    &amp;lt;/Box&amp;gt;
  );
};

export default Login;

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;组件的 &lt;code&gt;props&lt;/code&gt; 没有 &lt;code&gt;children&lt;/code&gt; 属性怎么办？&lt;/h4&gt;
&lt;p&gt;在组件的 &lt;code&gt;Props&lt;/code&gt; 接口中添加一个字段：&lt;code&gt;children: React.ReactNode&lt;/code&gt; 即可。以 &lt;code&gt;Login&lt;/code&gt; 为例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import * as React from &quot;react&quot;;
export interface LoginProps {
  user?: {
    username: string;
    password: string;
  };
  permission: &quot;tier1&quot; | &quot;tier2&quot;;
  children?: React.ReactNode;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;如何继承泛型组件的 Props？&lt;/h4&gt;
&lt;p&gt;以 MUI 中的 &lt;code&gt;Autocomplete&lt;/code&gt; 为例，&lt;code&gt;AutocompleteProps&lt;/code&gt; 是一个泛型 &lt;code&gt;type&lt;/code&gt;，原型为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface AutocompleteProps&amp;lt;T, Multiple extends boolean | undefined, DisableClearable extends boolean | undefined, FreeSolo extends boolean | undefined, ChipComponent extends React.ElementType&amp;lt;any&amp;gt; = &quot;div&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要泛型参数 &lt;code&gt;T&lt;/code&gt; ，如果要声明一个自定义组件 &lt;code&gt;CustomAutocomplete&lt;/code&gt; ，可以写为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export type CustomAutocompleteProps&amp;lt;T&amp;gt; = 
    AutocompleteProps&amp;lt;T, boolean, boolean, boolean, &quot;div&quot;&amp;gt;;
export declare const CustomAutocomplete: &amp;lt;T&amp;gt;(
  props: CustomAutocompleteProps&amp;lt;T&amp;gt;
) =&amp;gt; React.ReactElement&amp;lt;CustomAutocompleteProps&amp;lt;T&amp;gt;&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;怎样选择性继承属性？&lt;/h4&gt;
&lt;p&gt;TypeScript 的 &lt;code&gt;Omit&lt;/code&gt; 语法允许你剔除类型中的某些字段，假设要剔除下面类型中的 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; 字段：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface TypeA {
  a: string;
  b: number:
  c: boolean;
  d: () =&amp;gt; void;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以写为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type TypeB = Omit&amp;lt;TypeA, &quot;b&quot; | &quot;d&quot;&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;TypeB&lt;/code&gt; 等价于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface TypeB {
  a: string;
  c: boolean;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;如何合并两个类型？&lt;/h4&gt;
&lt;p&gt;个人认为用 &lt;code&gt;type&lt;/code&gt; 更加方便，当然 &lt;code&gt;interface&lt;/code&gt; 也可以。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface TypeA {
  a: string;
  b: number:
}
interface TypeB {
  c: boolean;
  d: () =&amp;gt; void;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果使用 &lt;code&gt;type&lt;/code&gt; 合并上面两个类型，可以写为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type TypeC = TypeA &amp;amp; TypeB;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface TypeC {
  a: string;
  b: number:
  c: boolean;
  d: () =&amp;gt; void;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这被称为 Intersections Type .&lt;/p&gt;
&lt;h3&gt;其他常见问题&lt;/h3&gt;
&lt;h4&gt;使用 &lt;code&gt;d.ts&lt;/code&gt; 进行类型声明后如何快速定位到组件的实现？&lt;/h4&gt;
&lt;p&gt;这的确是一个尚且无法完美解决的问题。以往当我们引用一个组件时，只需要将鼠标悬浮到组件名上，按下 &lt;code&gt;Ctrl&lt;/code&gt; ，然后单击鼠标左键，就编辑器就会直接转跳到组件的实现，而当引入 &lt;code&gt;d.ts&lt;/code&gt; 时，上述操作只能转跳到组件的声明。对于组件的使用者，这尚且可以接受，但是对于组件的开发者来说就不方便了。&lt;/p&gt;
&lt;p&gt;好消息是，如果你使用的是 WebStorm ，在 &lt;code&gt;d.ts&lt;/code&gt; 中选中组件的声明，然后按下 &lt;code&gt;Ctrl+F12&lt;/code&gt; ，就可以直接转跳到组件的实现。&lt;/p&gt;
&lt;p&gt;然而如果你使用的是 VSCode，很不幸，虽然 Stack Overflow 上相关问题与官方文档都声称： “如果将 VSCode 升级到 1.67 版本、TypeScript 升级到 4.7 版本，然后在 &lt;code&gt;d.ts&lt;/code&gt; 中选中组件名，接着右键点击 &lt;code&gt;Go to Source Definition&lt;/code&gt;，就可以转跳到组件的实现。” ，但经过本人多次实验与尝试，这种做法并没有奏效；不过经测试，以下做法勉强可行：在 &lt;code&gt;d.ts&lt;/code&gt; 中选中组件的 Props 的定义，然后右键选择 &lt;code&gt;Go to Implementations&lt;/code&gt; （或按下 &lt;code&gt;Ctrl+F12&lt;/code&gt;），编辑器就会转跳至 &lt;code&gt;.js&lt;/code&gt; 文件中声明组件 Props 类型的位置，同时也是组件实现的开头位置。举例来说，你想定位到 &lt;code&gt;Login&lt;/code&gt; 组件的实现，那么可以在 &lt;code&gt;d.ts&lt;/code&gt; 中选中 &lt;code&gt;LoginProps&lt;/code&gt; ，一般来说 &lt;code&gt;LoginProps&lt;/code&gt; 就在 &lt;code&gt;Login&lt;/code&gt; 声明的向上若干行的位置，接着右键点击 &lt;code&gt;Go to Implementations&lt;/code&gt; 就转跳到 &lt;code&gt;Login&lt;/code&gt; 组件上方写着 &lt;code&gt;@param {import(&quot;./Login&quot;).LoginProps} props&lt;/code&gt; 的位置。这种做法可行的原因是点击 &lt;code&gt;Go to Implementations&lt;/code&gt; 后 VSCode 似乎会尝试寻找 &lt;code&gt;.js&lt;/code&gt; 中所有引用了这个对象的位置。如果只有一个引用，VSCode 将直接转跳，否则 VSCode 会显示一个列表，允许你选择想要转跳到哪一个引用。而组件的 Props 接口通常与组件名关联，整个项目中通常只有一个或几个。&lt;/p&gt;
&lt;h4&gt;如何让 TS 静态检查器识别 &lt;code&gt;@&lt;/code&gt; 路径别名&lt;/h4&gt;
&lt;p&gt;为了方便，许多项目会在 Webpack 中将 &lt;code&gt;@&lt;/code&gt; 配置为 &lt;code&gt;src/*&lt;/code&gt; 路径的别名，这样可以使用形如 &lt;code&gt;@/components/xxx&lt;/code&gt; 的路径来引用组件。这样的做法虽然编译没问题，却对静态检查不友好，因为静态检查器并不知道 Webpack 的设置。可以通过配置 &lt;code&gt;jsconfig.json&lt;/code&gt; 来解决此问题，具体做法是，在项目根目录下创建 &lt;code&gt;jsconfig.json&lt;/code&gt; （新版 &lt;code&gt;creat-react-app&lt;/code&gt; 好像会自动创建这个文件，如果是 TypeScript 版的 React 项目那就是 &lt;code&gt;tsconfig.json&lt;/code&gt; ），然后在里面添加如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;compilerOptions&quot;: {
    &quot;baseUrl&quot;: &quot;./&quot;,
    &quot;paths&quot;: {
      &quot;@/*&quot;: [&quot;src/*&quot;]
    },
    &quot;declaration&quot;: true,
    &quot;declarationMap&quot;: true,
    &quot;declarationDir&quot;: &quot;./dist&quot;,
    &quot;jsx&quot;: &quot;react&quot;,
    &quot;target&quot;: &quot;ES2015&quot;,
    &quot;moduleResolution&quot;: &quot;node&quot;,
    &quot;allowSyntheticDefaultImports&quot;: true
  },
  &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;public&quot;, &quot;server&quot;]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&quot;@/*&quot;: [&quot;src/*&quot;]&lt;/code&gt; 是实现上述需求的关键，意思是任何 &lt;code&gt;&quot;@/xxx&quot;&lt;/code&gt; 的路径都会被静态检查器视作以项目根目录为基准的 &lt;code&gt;src/xxx&lt;/code&gt; 路径。其他配置则是为了解决其他问题，比如&lt;a href=&quot;#%E4%BD%BF%E7%94%A8-set-%E5%92%8C-map-%E6%97%B6-ts-%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5%E5%99%A8%E7%88%86%E7%BA%A2%E6%80%8E%E4%B9%88%E5%8A%9E&quot;&gt;下一个问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;保存文件后，VSCode 将显示 “初始化 JS/TS 语言功能” ，这表明它正在根据 &lt;code&gt;jsconfig.json&lt;/code&gt; 配置项目环境。配置完成后我们将发现所有合法的形如 &lt;code&gt;@/xxx&lt;/code&gt; 的路径都可以通过 &lt;code&gt;Ctrl+左键&lt;/code&gt; 直接转跳，TS 静态检查器也可以正确识别这些路径的内容。&lt;/p&gt;
&lt;h4&gt;使用 &lt;code&gt;Set&lt;/code&gt; 和 &lt;code&gt;Map&lt;/code&gt; 时 TS 静态检查器爆红怎么办？&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Set&lt;/code&gt; 和 &lt;code&gt;Map&lt;/code&gt; 是 ES2015 的新特性，其他特性还包括 &lt;code&gt;Promise&lt;/code&gt; 、字符串模板、对象字面量、&lt;code&gt;let/const&lt;/code&gt; 关键字等，部分特性要求在 &lt;code&gt;jsconfig.json&lt;/code&gt; 中显式声明所用的 ES 版本才能让 &lt;code&gt;ts-check&lt;/code&gt; 正确识别，因此在 &lt;code&gt;jsconfig.json&lt;/code&gt; 的 &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; 里加上 &lt;code&gt;&quot;target&quot;: &quot;ES2015&quot;,&lt;/code&gt; 即可。&lt;/p&gt;
</content:encoded></item><item><title>HIT-软件构造 | 考前讲座 Lecture 03</title><link>https://blog.vonbrank.com/posts/hit-software-construction-review-lecture-03/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/hit-software-construction-review-lecture-03/</guid><description>HIT 软件构造课程考前讲座第 3 节，范围 9-12 章：可复用性、可维护性、健壮性/鲁棒性、正确性与设计模式</description><pubDate>Wed, 08 Jun 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;By Von Brank | 2022/06/12&lt;/p&gt;
&lt;h2&gt;第 9 章 可复用性&lt;/h2&gt;
&lt;h3&gt;概念&lt;/h3&gt;
&lt;h4&gt;软件复用是什么？&lt;/h4&gt;
&lt;p&gt;两类软件复用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向复用编程：开发出可复用的软件&lt;/li&gt;
&lt;li&gt;基于复用编程：利用已有的可复用软件搭建应用系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么要复用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;降低开发时间和成本&lt;/li&gt;
&lt;li&gt;让复用的组件得以经过充分测试，保证其可靠、稳定&lt;/li&gt;
&lt;li&gt;实现组件标准化，令其在不同应用中保持一致&lt;/li&gt;
&lt;li&gt;开发初期成本：复用 &amp;gt; 不复用；后期成本：复用 &amp;lt; 不复用&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;如何衡量可复用性？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;复用的机会有多频繁？复用的场合有多少？&lt;/li&gt;
&lt;li&gt;复用的代价有多大？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;组件复用级别&lt;/h3&gt;
&lt;p&gt;复用的级别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源代码级别的复用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模块级别的复用&lt;/strong&gt;（类，抽象类，接口）&lt;/li&gt;
&lt;li&gt;库级别的复用（API/包）&lt;/li&gt;
&lt;li&gt;系统级别的复用（框架）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;源码级别的复用&lt;/h4&gt;
&lt;p&gt;最主要的复用是代码层面的复用。&lt;/p&gt;
&lt;p&gt;代码层面的复用中，以下内容都可能被复用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需求&lt;/li&gt;
&lt;li&gt;设计/规约spec&lt;/li&gt;
&lt;li&gt;数据&lt;/li&gt;
&lt;li&gt;测试用例&lt;/li&gt;
&lt;li&gt;文档&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两类源码级别的复用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白盒复用：
&lt;ul&gt;
&lt;li&gt;源代码&lt;strong&gt;可见&lt;/strong&gt;，可修改和扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;黑盒复用：
&lt;ul&gt;
&lt;li&gt;源代码&lt;strong&gt;不可见&lt;/strong&gt;，不能修改&lt;/li&gt;
&lt;li&gt;只能通过 API 接口来使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;模块级别的复用（类，接口）&lt;/h4&gt;
&lt;p&gt;设计可复用类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承与重写&lt;/li&gt;
&lt;li&gt;重载&lt;/li&gt;
&lt;li&gt;参数多态性与泛型编程&lt;/li&gt;
&lt;li&gt;行为子类化与泛型编程&lt;/li&gt;
&lt;li&gt;组合与委托&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种复用类/接口的途径：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;委托&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;库级别的复用（API，包）和系统级别的复用（框架）&lt;/h4&gt;
&lt;p&gt;框架是一组具体类、抽象类、及其之间的连接关系。&lt;/p&gt;
&lt;p&gt;开发者根据框架的规约，填充自己的代码进去，形成完整系统。&lt;/p&gt;
&lt;h3&gt;设计可复用类&lt;/h3&gt;
&lt;p&gt;面对对象的类的组织关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子类型多态（继承）&lt;/li&gt;
&lt;li&gt;Liskov替换原则&lt;/li&gt;
&lt;li&gt;委托&lt;/li&gt;
&lt;li&gt;组合&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;子类型多态&lt;/h4&gt;
&lt;p&gt;客户端可用统一的方式处理不同类型的对象，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Animal a = new Animal();
Animal c1 = new Cat();
Cat c2 = new Cat();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;c1&lt;/code&gt; 和 &lt;code&gt;c2&lt;/code&gt; 都是 &lt;code&gt;Animal&lt;/code&gt; &lt;strong&gt;子类&lt;/strong&gt; 的实例，那么用 &lt;code&gt;c1&lt;/code&gt; 或 &lt;code&gt;c2&lt;/code&gt; 代替 &lt;code&gt;Animal&lt;/code&gt; 不会有任何问题。&lt;/p&gt;
&lt;h4&gt;Liskov 替换原则（LSP）&lt;/h4&gt;
&lt;h5&gt;内容&lt;/h5&gt;
&lt;p&gt;具体要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子类型可以增加方法，但是不可以删除基类的方法&lt;/li&gt;
&lt;li&gt;子类型需要实现抽象类型中的所有未实现方法&lt;/li&gt;
&lt;li&gt;当子类覆盖或实现父类的方法时，方法的返回值要比父类更严格。（子类型中重写的方法必须有相同或子类型的返回值或者符合 &lt;code&gt;co-variance&lt;/code&gt; 的参数）&lt;/li&gt;
&lt;li&gt;当子类覆盖或实现父类的方法时，方法的形参要比父类方法的更为宽松。（子类型中重写的方法必须使用同样类型的参数或者符合 &lt;code&gt;contra-variance&lt;/code&gt; 的参数）&lt;/li&gt;
&lt;li&gt;子类型中重写的方法不能抛出额外的异常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单记为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更强的不变量&lt;/li&gt;
&lt;li&gt;更弱的前置条件&lt;/li&gt;
&lt;li&gt;更强的后置条件&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;协变&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;父类 $\to$ 子类：越来越具体&lt;/li&gt;
&lt;li&gt;返回值类型：不变或更具体&lt;/li&gt;
&lt;li&gt;异常的类型：不变或更具体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class T {
  Object a() { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class S extends T {
  @Override
  String a() { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;又如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class T {
  void b( ) throws Throwable{ ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class S extends T {
  @Override
  void b( ) throws IOException{ ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再变为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class U extends S {
  @Override
  void b( ) { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;反协变/逆变&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;父类 $\to$ 子类：越来越具体&lt;/li&gt;
&lt;li&gt;参数类型：不变或越来越抽象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class T {
  void c( String s ) { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class S extends T {
  @Override
  void c( Object s ) { ... }
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;数组的协变&lt;/h6&gt;
&lt;p&gt;Java 中的数组是协变的，也就是说，数组 &lt;code&gt;T[]&lt;/code&gt; 中任意一个元素可以是 &lt;code&gt;T&lt;/code&gt; 的子类。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Number[] numbers = new Number[2];
numbers[0] = new Integer(10);
numbers[1] = new Double(3.14);

Integer[] myInts = {1,2,3,4};
Number[] myNumber = myInts;

myNumber[0] = 3.14; //run-time error!
&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;泛型中的LSP&lt;/h6&gt;
&lt;p&gt;观察到以下现象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ArrayList&amp;lt;String&amp;gt;&lt;/code&gt; 是 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 的子类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 不是 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 的子类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是因为 Java 实现泛型的方式是 &lt;strong&gt;“类型擦除”&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;例子1：
编译器看见的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Pair&amp;lt;T&amp;gt; {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() {
        return first;
    }
    public T getLast() {
        return last;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JVM 虚拟机执行的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Pair {
    private Object first;
    private Object last;
    public Pair(Object first, Object last) {
        this.first = first;
        this.last = last;
    }
    public Object getFirst() {
        return first;
    }
    public Object getLast() {
        return last;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例子2：
编译器看见的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Pair&amp;lt;String&amp;gt; p = new Pair&amp;lt;&amp;gt;(&quot;Hello&quot;, &quot;world&quot;);
String first = p.getFirst();
String last = p.getLast();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JVM 虚拟机执行的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Pair p = new Pair(&quot;Hello&quot;, &quot;world&quot;);
String first = (String) p.getFirst();
String last = (String) p.getLast();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要实现泛型的子类，进而满足 LSP 原则，可以使用通配符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;List&amp;lt;Number&amp;gt;&lt;/code&gt; 是 &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; 的子类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List&amp;lt;Number&amp;gt;&lt;/code&gt; 是 &lt;code&gt;List&amp;lt;? extends Object&amp;gt;&lt;/code&gt; 的子类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 是 &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; 的子类&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;? extends Integer&amp;gt; intList = new ArrayList&amp;lt;&amp;gt;();
List&amp;lt;? extends Number&amp;gt; numList = intList;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;委托&lt;/h4&gt;
&lt;p&gt;委托指的是一个对象请求另一个对象的功能，是复用的一种常见形式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface Flyable {
    public void fly();
}

interface Quackable {
    public void quack();
}

class FlyWithWings implements Flyable {
    @Override
    public void fly() {
        System.out.println(&quot;fly with wings&quot;);
    }
}

class Quack implements Quackable {
    @Override
    public void quack() {
        System.out.println(&quot;quack like duck&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;interface Ducklike extends Flyable, Quackable {}

public class Duck implements Ducklike {
    Flyable flyBehavior = new FlyWithWings();   // 组合
    Quackable quackBehavior = new Quack();  // 组合
    @Override
    public void fly() {
        this.flyBehavior.fly(); // 委托
    }
    @Override
    public void quack() {
        this.quackBehavior.quack(); // 委托
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;用委托替代继承&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Before:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class RealPrinter {
    void print() {
        System.out.println(&quot;Printing Data&quot;);
    }
}
class Printer extends RealPrinter {
    void print(){
        super.print();
    }
}
Printer printer = new Printer();
printer.print();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;After:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class RealPrinter {
    void print() {
        System.out.println(&quot;The Delegate&quot;);}
}
class Printer {
    RealPrinter p = new RealPrinter();
    void print() {
        p.print();
    }
}
Printer printer = new Printer();
printer.print();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;复合复用原则（CRP）&lt;/h5&gt;
&lt;p&gt;CRP 鼓励使用委派而不是继承来实现复用。&lt;/p&gt;
&lt;p&gt;设计两棵继承树，通过 delegatoin 实现 “对象” 和 “行为” 的动态绑定，实现灵活可变复用。&lt;/p&gt;
&lt;h5&gt;组合与委托&lt;/h5&gt;
&lt;h5&gt;委派（delegation）的种类&lt;/h5&gt;
&lt;h6&gt;Dependency&lt;/h6&gt;
&lt;p&gt;临时性 delegation，即 Use (A use B)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Duck {
    void fly(Flyable flyable) {
        flyable.fly();
    }
}

Flyable flyable = new FlyWithWings();
Duck duck = new Duck();
d.fly(flyable);

&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;Association&lt;/h6&gt;
&lt;p&gt;永久性 delegation (A has B)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Duck {
    Flyable flyable = new CannotFly();

    Duck(Flyable flyable) {
        this.flyable = flyable;
    }

    void fly() {
        flyable.fly();
    }

    void fly(Flyable flyable) {
        this.flyable = flyable;
    }
}

Flyable flyable = new FlyWithWings();
Duck duck = new Duck(flyable);
d.fly();

&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;Composition&lt;/h6&gt;
&lt;p&gt;通过类内部初始化建立的 delegation 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Duck {
    Flyable flyable =  new FlyWithWings();

    void fly() {
        flyable.fly();
    }

}

Duck duck = new Duck();
d.fly();

&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;Aggregation&lt;/h6&gt;
&lt;p&gt;通过客户端调用方法或构造函数，从外部传入 delegation 类，保存到某个 field 建立起来的 delegation 关系。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Duck {
    Flyable flyable;

    Duck(Flyable flyable) {
        this.flyable = flyable;
    }
    void fly(Flyable flyable) {
        this.flyable = flyable;
    }

}

Flyable flyable = new FlyWithWings();
Duck duck = new Duck(flyable);
d.fly();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;区别 Dependency 和 Association 主要是看类是否有一个字段（field）来保存委托变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Association：通过固有的 filed 来建立 delegation&lt;/li&gt;
&lt;li&gt;Dependency：没有固有的 filed ，只是用方法参数等建立 delegation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Composition 和 Aggregation 都是将 delegation 实例保存在类的某个 field 建立起来的 delegation 关系，是两种形式的 Association&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Composition 比 Association 更强， delegation 关系&lt;strong&gt;无法&lt;/strong&gt;修改（通过初始化建立）&lt;/li&gt;
&lt;li&gt;Aggregation 比 Association 更弱， delegation 关系&lt;strong&gt;可以&lt;/strong&gt;修改（通过方法或构造函数、由传入的参数建立）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;设计系统级可复用 API 库和框架&lt;/h3&gt;
&lt;p&gt;设计可复用库与框架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API 与 库&lt;/li&gt;
&lt;li&gt;框架&lt;/li&gt;
&lt;li&gt;例如：Java 的集合框架&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;概念&lt;/h4&gt;
&lt;p&gt;对 API 开发者的建议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;始终以开发 API 的标准面对任何开发任务&lt;/li&gt;
&lt;li&gt;面向“复用”编程而不是面向“应用”编程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;难点在于，要有足够良好的设计，一旦发布就无法再自由改变。&lt;/p&gt;
&lt;h4&gt;白盒框架与黑盒框架&lt;/h4&gt;
&lt;p&gt;黑盒框架与白盒框架：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白盒框架——通过代码层面的继承进行框架扩展：继承、子类、重载与覆写&lt;/li&gt;
&lt;li&gt;黑盒框架——通过实现特定接口/委托进行框架扩展：接口、委托&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;白盒框架&lt;/h5&gt;
&lt;p&gt;白盒框架主要利用&lt;strong&gt;继承&lt;/strong&gt;实现。&lt;/p&gt;
&lt;p&gt;框架：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class PrintOnScreen {
    public void print() { 
        JFrame frame = new JFrame(); 
        JOptionPane.showMessageDialog(frame, textToShow());
        frame.dispose();
    } 
    protected abstract String textToShow(); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyApplication extends PrintOnScreen {
@Override protected String textToShow() {
        return &quot;printing this text on &quot;
        + &quot;screen using PrintOnScreen &quot;
        + &quot;white Box Framework&quot;; 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;黑盒框架&lt;/h5&gt;
&lt;p&gt;黑盒框架主要利用&lt;strong&gt;委托/组合&lt;/strong&gt;实现。&lt;/p&gt;
&lt;p&gt;框架：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface TextToShow { 
    String text(); 
}

public class MyTextToShow implements TextToShow {
    @Override 
    public String text() { 
        return &quot;Printing&quot;; 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public final class PrintOnScreen {
    TextToShow textToShow;   
    public PrintOnScreen(TextToShow tx) { 
        this.textToShow = tx; 
    }
    public void print() { 
        JFrame frame = new JFrame(); 
        JOptionPane.
        showMessageDialog(frame, textToShow.text());
        frame.dispose(); 
    }
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;第 10 章 可维护性&lt;/h2&gt;
&lt;h3&gt;一些概念&lt;/h3&gt;
&lt;h4&gt;软件维护的种类&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;纠错性维护&lt;/li&gt;
&lt;li&gt;适应性维护&lt;/li&gt;
&lt;li&gt;完善性维护&lt;/li&gt;
&lt;li&gt;预防性维护&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;几类提高软件可维护性的方法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;模块化&lt;/li&gt;
&lt;li&gt;OO（面向对象）设计原则&lt;/li&gt;
&lt;li&gt;OO（面向对象）设计模式&lt;/li&gt;
&lt;li&gt;基于状态的构造技术&lt;/li&gt;
&lt;li&gt;表驱动的构造技术&lt;/li&gt;
&lt;li&gt;基于语法的构造技术&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;可维护性多量指标&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;可维护性&lt;/li&gt;
&lt;li&gt;可扩展性&lt;/li&gt;
&lt;li&gt;灵活性&lt;/li&gt;
&lt;li&gt;可适应性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;模块化设计与模块化原则&lt;/h3&gt;
&lt;h4&gt;一些概念&lt;/h4&gt;
&lt;p&gt;模块化编程特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高内聚&lt;/li&gt;
&lt;li&gt;低耦合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;模块化编程降低复杂度的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关注点分离&lt;/li&gt;
&lt;li&gt;信息隐藏&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;评估模块化程度的 5 个角度&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;可分解性&lt;/li&gt;
&lt;li&gt;可组合性&lt;/li&gt;
&lt;li&gt;可理解性&lt;/li&gt;
&lt;li&gt;可持续性——发生变化时受影响范围最小&lt;/li&gt;
&lt;li&gt;出现异常之后的保护———出现异常后受影响范围最小&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;模块化设计的 5 条规则&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;直接映射&lt;/li&gt;
&lt;li&gt;尽可能少的接口&lt;/li&gt;
&lt;li&gt;尽可能小的接口&lt;/li&gt;
&lt;li&gt;显式接口&lt;/li&gt;
&lt;li&gt;信息隐藏&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;耦合与内聚&lt;/h4&gt;
&lt;p&gt;模块之间的联系称为&lt;strong&gt;耦合&lt;/strong&gt;。模块间联系越紧密，耦合性越强。&lt;/p&gt;
&lt;p&gt;模块内部元素的联系称为&lt;strong&gt;内聚&lt;/strong&gt;。模块内元素结合得越紧密，内聚性越高。&lt;/p&gt;
&lt;p&gt;我们追求&lt;strong&gt;低耦合、高内聚&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;面向对象设计原则：SOLID&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;单一责任原则（SRP）&lt;/li&gt;
&lt;li&gt;开放封闭原则（OCP）&lt;/li&gt;
&lt;li&gt;Liskov 替换原则（LSP）&lt;/li&gt;
&lt;li&gt;接口隔离原则（ISP）&lt;/li&gt;
&lt;li&gt;依赖倒置原则（DIP）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;单一责任原则&lt;/h4&gt;
&lt;p&gt;一个类，应该只有一个引起它变化的原因。也就是说，一个类应该只负责&lt;strong&gt;一个职责&lt;/strong&gt;，如果这个类需要修改的话，也只是因为这一个职责的变化了才引发类的修改。&lt;/p&gt;
&lt;p&gt;假设我们要设计一辆汽车，它目前有如下功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Car {
    // 启动引擎
    public void start() {
        System.out.println(&quot;车辆启动了！&quot;);
    }
    // 熄火
    public void stop() {
        System.out.println(&quot;车辆熄火了！&quot;);
    }
    // 加速
    public void speed() {
        System.out.println(&quot;车辆加速中！&quot;);
    }
    // 接送乘客
    public void pickUpPassenger(){
        System.out.println(&quot;接送乘客中！&quot;);
    }
    // 加油
    public void gasUp(){
        System.out.println(&quot;去加油站加汽油！&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要修改汽车的参数，就需要修改这个类；如果修改接送乘客的规则，也需要修改这个类。这个类包含了太多职责，不符合单一责任原则，会变得低内聚、高耦合。&lt;/p&gt;
&lt;p&gt;可以改为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Car {
    // 启动引擎
    public void start() {
        System.out.println(&quot;车辆启动了！&quot;);
    }
    // 熄火
    public void stop() {
        System.out.println(&quot;车辆熄火了！&quot;);
    }
    // 加速
    public void speed() {
        System.out.println(&quot;车辆加速中！&quot;);
    }
}

class TaxiDriver {
    public Car car;
    // 接送乘客
    public void pickUpPassenger(){
        System.out.println(&quot;接送乘客中！&quot;);
    }
    // 加油
    public void gasUp(){
        System.out.println(&quot;去加油站加汽油！&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把汽车的功能拆分出来，委托给 &lt;code&gt;TaxiDriver&lt;/code&gt;，实现汽车本身的操作和送客、加油功能的解耦。&lt;/p&gt;
&lt;h4&gt;开放封闭原则 (OCP)&lt;/h4&gt;
&lt;p&gt;一个实体（类、函数、模块等）应该对外扩展开放，对内修改封闭。某实体应该易于扩展，在扩展某类的功能时应该通过添加新的代码来实现而不是修改其内部的代码。&lt;/p&gt;
&lt;p&gt;之前的例子中，如果司机需要把车改成电动车，那么就不需要加油而是充电。如果直接修改 &lt;code&gt;TaxiDriver&lt;/code&gt; 很容易引发bug，而且原来的代码已经测试好了、而且被其他地方引用，返工成本比较高。解决方法是将 &lt;code&gt;Car&lt;/code&gt; 变成接口或抽象类，扩展出燃油车、电动车的子类，两种车在 &lt;code&gt;gasUp&lt;/code&gt; 时有不同行为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abstract class Car {
    // 启动引擎
    public void start() {
        System.out.println(&quot;车辆启动了！&quot;);
    }

    // 熄火
    public void stop() {
        System.out.println(&quot;车辆熄火了！&quot;);
    }

    // 加速
    public void speed() {
        System.out.println(&quot;车辆加速中！&quot;);
    }

    //补充燃料
    public abstract  void fillUp();

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;class FuelCar extends Car {
    @Override
    public void fillUp() {
        System.out.println(&quot;加油！&quot;);
    }
}

class ElectricCar extends Car {
    @Override
    public void fillUp() {
        System.out.println(&quot;充电！&quot;);
    }
}

class TaxiDriver {
    public Car car;
    // 接送乘客
    public void pickUpPassenger(){
        System.out.println(&quot;接送乘客中！&quot;);
    }

    // 加油/充电
    public void gasUp(){
        car.fillUp();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现在新增需求时只增加代码，而不修改原有的代码。使用时引入新加的类即可。&lt;/p&gt;
&lt;h4&gt;Liskov 替换原则（LSP）&lt;/h4&gt;
&lt;p&gt;任何基类可以出现的地方，子类一定可以出现。可以用来检验继承是否合理。&lt;/p&gt;
&lt;h4&gt;接口隔离原则 （ISP）&lt;/h4&gt;
&lt;p&gt;一个类依赖另一个类时，应该依赖最小的那一个接口。因为依赖过多的接口将导致子类需要实现太多方法，子类被客户端使用时也会包含大量无用方法。&lt;/p&gt;
&lt;p&gt;假设我们要设计一种载具，先设计它的接口，然后让特定的载具实现它：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface Vehicle {
    // 飞行
    void fly();
    // 航行
    void sail();
    // 陆行
    void run();
}

class AirPlane implements Vehicle {
    @Override
    public void fly() {
        System.out.println(&quot;飞行&quot;);
    }
    @Override
    public void sail() {
    
    }
    @Override
    public void run() {

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码中，一种 &lt;code&gt;Vehicle&lt;/code&gt; 可能有多种功能，看似合理，但是 &lt;code&gt;AirPlane&lt;/code&gt; 继承 &lt;code&gt;Vehicle&lt;/code&gt; 时，&lt;code&gt;sail&lt;/code&gt; 和 &lt;code&gt;run&lt;/code&gt; 方法都是无用的，毕竟飞机只需要飞且不能航行，然而它却不得不实现 &lt;code&gt;sail&lt;/code&gt; 和 &lt;code&gt;run&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;可以修改为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
interface Fly { // 飞行接口
    // 飞行
    void fly();
}
interface Sail { // 航行接口
    // 航行
    void sail();
}
interface Run { // 陆行接口
    // 陆行
    void run();
}
class AirCraft implements Fly { // 飞行器类
    @Override
    public void fly() {
        System.out.println(&quot;飞行&quot;);
    }
}
public class Vehicle 
    implements Fly, Sail, Run {
    // 飞行
    @Override
    void fly();
    // 航行
    @Override
    void sail();
    // 陆行
    @Override
    void run();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改后 &lt;code&gt;AirCraft&lt;/code&gt; 只需要实现 &lt;code&gt;Fly&lt;/code&gt; 接口中的方法即可。如果确实有开发一种能上天入地载具的需求，只需要让 &lt;code&gt;Vehicle&lt;/code&gt; 实现 &lt;code&gt;Fly&lt;/code&gt;, &lt;code&gt;Sail&lt;/code&gt;, &lt;code&gt;Run&lt;/code&gt; 即可。&lt;/p&gt;
&lt;h4&gt;依赖倒置原则（DIP）&lt;/h4&gt;
&lt;p&gt;一个类依赖另一个一个类时，应该尽量依赖其接口而不是具体实现。&lt;/p&gt;
&lt;p&gt;还是司机开车的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class TaxiDriver {
    public FuelCar car;

    TaxiDriver(FuelCar car) {
        this.car = car;
    }

    // 接送乘客
    public void pickUpPassenger(){
        System.out.println(&quot;接送乘客中！&quot;);
    }

    // 加油/充电
    public void gasUp(){
        car.fillUp();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个例子中，司机只能开燃油车，如果未来司机需要开电动车，就需要修改类内的代码。可以改为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class TaxiDriver {
    public Car car;

    TaxiDriver(Car car) {
        this.car = car;
    }

    // 接送乘客
    public void pickUpPassenger(){
        System.out.println(&quot;接送乘客中！&quot;);
    }

    // 加油/充电
    public void gasUp(){
        car.fillUp();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在司机可以开任何车了，如果需要修改开车的种类，只需要修改客户端代码即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Main {
    public static void main(String[] args) {
        Car basicCar = new BasicCar();
        Car teslaModel3 = new TeslaModel3();
        Car bugattiVeyron = new BugattiVeyron();
        // 什么车都能开
        TaxiDriver taxiDriver = new TaxiDriver(teslaModel3);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;正则表达式&lt;/h3&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md&quot;&gt;learn-regex项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正则表达式由一些字母和数字组成，它表示一类字符串的格式（专业的说法：它定义了一类语言）。例如 &lt;code&gt;the&lt;/code&gt; 是一个正则表达式，它可以匹配 &lt;code&gt;The fat cat sat on the mat.&lt;/code&gt; 中的后一个 &lt;code&gt;the&lt;/code&gt; 。因为正则表达式是敏感的，所以 &lt;code&gt;The&lt;/code&gt; 只能匹配句子开头的 &lt;code&gt;The&lt;/code&gt; 而不能匹配 &lt;code&gt;the&lt;/code&gt; 。&lt;/p&gt;
&lt;h4&gt;元字符和字符集简写&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;元字符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;句号匹配任意单个字符除了换行符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[ ]&lt;/td&gt;
&lt;td&gt;字符种类。匹配方括号内的任意字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[^ ]&lt;/td&gt;
&lt;td&gt;否定的字符种类。匹配除了方括号里的任意字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;匹配&amp;gt;=0个重复的在*号之前的字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;匹配&amp;gt;=1个重复的+号前的字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;标记?之前的字符为可选.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{n,m}&lt;/td&gt;
&lt;td&gt;匹配num个大括号之前的字符或字符集 (n &amp;lt;= num &amp;lt;= m).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(xyz)&lt;/td&gt;
&lt;td&gt;字符集，匹配与 xyz 完全相等的字符串.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;或运算符，匹配符号前或后的字符.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\&lt;/td&gt;
&lt;td&gt;转义字符,用于匹配一些保留的字符 &amp;lt;code&amp;gt;[ ] ( ) { } . * + ? ^ $ \ |&amp;lt;/code&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;从开始行开始匹配.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;从末端开始匹配.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;简写&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;除换行符外的所有字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;匹配所有字母数字，等同于 &lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;匹配所有非字母数字，即符号，等同于： &lt;code&gt;[^\w]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;匹配数字： &lt;code&gt;[0-9]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\D&lt;/td&gt;
&lt;td&gt;匹配非数字： &lt;code&gt;[^\d]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;匹配所有空格字符，等同于： &lt;code&gt;[\t\n\f\r\p{Z}]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\S&lt;/td&gt;
&lt;td&gt;匹配所有非空格字符： &lt;code&gt;[^\s]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\f&lt;/td&gt;
&lt;td&gt;匹配一个换页符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;匹配一个换行符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\r&lt;/td&gt;
&lt;td&gt;匹配一个回车符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\t&lt;/td&gt;
&lt;td&gt;匹配一个制表符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\v&lt;/td&gt;
&lt;td&gt;匹配一个垂直制表符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\p&lt;/td&gt;
&lt;td&gt;匹配 CR/LF（等同于 &lt;code&gt;\r\n&lt;/code&gt;），用来匹配 DOS 行终止符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;基础匹配与示例&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;点字符 &lt;code&gt;.&lt;/code&gt;
句号匹配任意单个字符除了换行符
&amp;lt;pre&amp;gt;
&quot;.ar&quot; =&amp;gt; The &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;car&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;par&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt;ked in the &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;gar&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt;age.
&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符集 &lt;code&gt;[ ]&lt;/code&gt;
字符种类。匹配方括号内的任意字符。
&amp;lt;pre&amp;gt;
&quot;[Tt]he&quot; =&amp;gt; &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;The&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; car parked in &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;the&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; garage.
&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;pre&amp;gt;
&quot;ar[.]&quot; =&amp;gt; A garage is a good place to park a c&amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;ar.&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;否定字符集 &lt;code&gt;[^ ]&lt;/code&gt;
否定的字符种类。匹配除了方括号里的任意字符。
&amp;lt;pre&amp;gt;
&quot;[^c]ar&quot; =&amp;gt; The car &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;par&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt;ked in the &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;gar&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt;age.
&amp;lt;/pre&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重复次数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt; 号
匹配&amp;gt;=0个重复的在&lt;em&gt;号之前的字符。
&amp;lt;pre&amp;gt;
&quot;[a-z]&lt;/em&gt;&quot; =&amp;gt; T&amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;he&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;car&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;parked&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;in&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;the&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;garage&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; #21.
&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt; 号
匹配&amp;gt;=1个重复的+号前的字符。
&amp;lt;pre&amp;gt;
&quot;c.+t&quot; =&amp;gt; The fat &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;cat sat on the mat&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt;.
&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;?&lt;/code&gt; 号
标记?之前的字符为可选，即该字符出现 0 次或 1 次都可以。
&amp;lt;pre&amp;gt;
&quot;[T]he&quot; =&amp;gt; &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;The&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; car is parked in the garage.
&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;pre&amp;gt;
&quot;[T]?he&quot; =&amp;gt; &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;The&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; car is parked in t&amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;he&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; garage.
&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;{}&lt;/code&gt; 号
{n,m}匹配num个大括号之前的字符或字符集 (n &amp;lt;= num &amp;lt;= m).
&amp;lt;pre&amp;gt;
&quot;[0-9]{2,3}&quot; =&amp;gt; The number was 9.&amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;999&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt;7 but we rounded it off to &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;10&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt;.0.
&amp;lt;/pre&amp;gt;
&amp;lt;pre&amp;gt;
&quot;[0-9]{2,}&quot; =&amp;gt; The number was 9.&amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;9997&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; but we rounded it off to &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;10&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt;.0.
&amp;lt;/pre&amp;gt;
&amp;lt;pre&amp;gt;
&quot;[0-9]{3}&quot; =&amp;gt; The number was 9.&amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;999&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt;7 but we rounded it off to 10.0.
&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(...)&lt;/code&gt; 特征标群（Capturing Groups）
将括号内的字符串视作一个整体，如 (xyz) 匹配与 xyz 完全相等的字符串
&amp;lt;pre&amp;gt;
&quot;(c|g|p)ar&quot; =&amp;gt; The &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;car&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; is &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;par&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt;ked in the &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;gar&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt;age.
&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;|&lt;/code&gt; 或运算符
匹配符号前或后的字符
&amp;lt;pre&amp;gt;
&quot;(T|t)he|car&quot; =&amp;gt; &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;The&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;car&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; is parked in &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;the&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; garage.
&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;转码特殊字符
转义字符,用于匹配一些保留的字符 &amp;lt;code&amp;gt;[ ] ( ) { } . * + ? ^ $ \ |&amp;lt;/code&amp;gt;
&amp;lt;pre&amp;gt;
&quot;(f|c|m)at.?&quot; =&amp;gt; The &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;fat&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;cat&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; sat on the &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;mat.&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锚点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; 号
从开始行开始匹配
&amp;lt;pre&amp;gt;
&quot;(T|t)he&quot; =&amp;gt; &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;The&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; car is parked in &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;the&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; garage.
&amp;lt;/pre&amp;gt;
&amp;lt;pre&amp;gt;
&quot;^(T|t)he&quot; =&amp;gt; &amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;The&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; car is parked in the garage.
&amp;lt;/pre&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; 号
从末端开始匹配
&amp;lt;pre&amp;gt;
&quot;(at.)&quot; =&amp;gt; The fat c&amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;at.&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; s&amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;at.&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; on the m&amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;at.&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;/pre&amp;gt;
&amp;lt;pre&amp;gt;
&quot;(at.)$&quot; =&amp;gt; The fat cat. sat. on the m&amp;lt;a href=&quot;#learn-regex&quot;&amp;gt;&amp;lt;strong&amp;gt;at.&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;/pre&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;在 Java 中使用 regex&lt;/h4&gt;
&lt;p&gt;在 Java 中使用正则表达式时，所有 &lt;code&gt;\&lt;/code&gt; 要写作 &lt;code&gt;\\&lt;/code&gt; ，因为 Java 字符串自身有转义行为。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        String regex = &quot;20\\d\\d&quot;;
        System.out.println(&quot;20\\d\\d&quot;); // 20\d\d
        System.out.println(&quot;2019&quot;.matches(regex)); // true
        System.out.println(&quot;2100&quot;.matches(regex)); // false
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;第 11 章 设计模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建型模式：
&lt;ul&gt;
&lt;li&gt;工厂模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结构型模式
&lt;ul&gt;
&lt;li&gt;适配器模式&lt;/li&gt;
&lt;li&gt;装饰器模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;行为型模式
&lt;ul&gt;
&lt;li&gt;策略模式&lt;/li&gt;
&lt;li&gt;模板模式&lt;/li&gt;
&lt;li&gt;迭代器模式&lt;/li&gt;
&lt;li&gt;访问者模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;创建型模式&lt;/h3&gt;
&lt;h4&gt;工厂模式&lt;/h4&gt;
&lt;p&gt;很多时候，客户端需要创建一个实例，但是不知道需要哪一个实例，只能给出一些参数，这时候就需要使用工厂模式。&lt;/p&gt;
&lt;p&gt;简单工厂模式通过定义一个工厂类，根据传入参数的不同返回不同实例，这些实例具有共同的父类接口。&lt;/p&gt;
&lt;p&gt;假设你写的客户端需要一台手机，但是只给出手机的品牌名，但是创建手机实例需要价格、芯片型号等更详细的参数，这些参数需要工厂方法根据品牌名传入。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface Phone {
    int price;
    String soc;
    void run();
}
public class MiPhone implements Phone {
    public MiPhone(int price, String soc) {
        this.price = price;
        this.soc = soc;
    }
    @Override
    public void run() {
        System.out.println(&quot;MiPhone is cheap!&quot;);
    }
}
public class IPhone implements Phone {
    public IPhone(int price) {
        this.price = price;
        this.soc = &quot;A15&quot;;
    }
    @Override
    public void run() {
        System.out.println(&quot;iPhone has high performance!&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class PhoneFactory {
    public Phone makePhone(String phoneType) {
        if(phoneType.equals(&quot;Apple&quot;)) 
            return new IPhone(8999);
        else if(phoneType.equals(&quot;Mi&quot;))
            return new MiPhone(1999, &quot;SnapDragon 888&quot;); 
    }
}

public class Main {
    public static void main(String[] args) {
        PhoneFactory factory = new PhoneFactory();
        Phone miPhone = factory.makePhone(&quot;Mi&quot;);
        Phone iPhone = factory.makePhone(&quot;Apple&quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如此一来，客户端想要什么手机，只需要传入手机的名称，而不需要关心手机的价格、芯片型号等信息。&lt;/p&gt;
&lt;h3&gt;结构型模式&lt;/h3&gt;
&lt;h4&gt;适配器模式&lt;/h4&gt;
&lt;p&gt;假设你正在开发一款绘图程序，开发时你决定使用一个第三方库中的一个类 &lt;code&gt;LegacyRectangle&lt;/code&gt; 来帮助你完成矩形的绘制。但是问题在于，你写的客户端只能提供矩形对角两点的坐标，而库则需要接受其中一点的坐标以及矩形的长和宽。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class LegacyRectangle {
    void display(int x1, int y1, int w, int h) {...}
}

class Client {
    Shape shape;
    public display() {
        shape.display(x1, y1, x2, y2);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你可以修改库来支持你的客户端，或修改自己的客户端来适配库，但是在实际生产环境中，修改库几乎是不可能的，因为你很可能没有库的源码，即使有，你也无法保证你的修改没有副作用，从而导致库出错。（开闭原则）&lt;/p&gt;
&lt;p&gt;解决方案是创建一个&lt;strong&gt;适配器&lt;/strong&gt;对象，传入矩形的对角线坐标，由它帮助你调用库完成矩形的绘制。考虑到未来可能有其他适配器，我们将 &lt;code&gt;Rectangle&lt;/code&gt; 作为 &lt;code&gt;Shape&lt;/code&gt; 接口的一个实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class LegacyRectangle {
    void display(int x1, int y1, int w, int h) {...}
}

interface Shape {
    void display(int x1, int y1, int x2, int y2);
}

class Rectangle implements Shape {
    @Override
    void display(int x1, int y1, int x2, int y2) {
        new LegacyRectangle().display(x1, y1, x2 - x1, y2 - y1);
    }
}

class Client {
    Shape shape = new Rectangle();
    public display() {
        shape.display(x1, y1, x2, y2);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;装饰器模式&lt;/h4&gt;
&lt;p&gt;假设我们要渲染一段 HTML 文本，HTML 可以标记文本的附加效果，比如一段加粗、加删除线的文本的 HTML 实现可以是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;del&amp;gt;&amp;lt;b&amp;gt;Hello World&amp;lt;/b&amp;gt;&amp;lt;/del&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果： &lt;s&gt;&lt;strong&gt;Hello World&lt;/strong&gt;&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;当然，现代 Web 前端技术主张使用 CSS 实现这些样式。&lt;/p&gt;
&lt;p&gt;实现类似附加效果最 naive 的方法可以是直接写一个类来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface TextNode {
    String getText();
}

class BlackNode implements TextNode {
    private String text;
    public void BlackNode(String text) {
        this.text = text;
    }
    public String getText() {
        return &quot;&amp;lt;b&amp;gt;&quot; + text + &quot;&amp;lt;/b&amp;gt;&quot;;
    }
}

public class Main {
    public static void main(String[] args) {
        TextNode textNode = new BlackNode(&quot;Hello World&quot;);
        System.out.println(textNode.getText());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们想给黑体文本加上下划线，可以新建一个类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class DeleteBlackNode implements TextNode {
    private String text;
    public void DeleteBlackNode(String text) {
        this.text = text;
    }
    public String getText() {
        return &quot;&amp;lt;del&amp;gt;&amp;lt;b&amp;gt;&quot; + text + &quot;&amp;lt;/b&amp;gt;&amp;lt;/del&amp;gt;&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是这样将导致一个严重的问题，一段文本可以添加的效果有粗体、斜体、下划线、删除线、字号、颜色等，这些效果可以任意组合，如果给任意一种组合编写一个类，子类数量会爆炸性增长。&lt;/p&gt;
&lt;p&gt;装饰器模式的目的是，一个子类只负责一个效果，通过委托的方式将这种效果累加到已经添加好其他效果的文本上。&lt;/p&gt;
&lt;p&gt;为了更好地理解装饰器模式，以上述例子为例，我们希望写出的类是这样的（其中 &lt;code&gt;target&lt;/code&gt; 是一个已经添加好部分效果的 &lt;code&gt;TextNode&lt;/code&gt;）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class DelTextNode implements TextNode {
    DelTextNode(TextNode textNode) {
        this.target = textNode;
    }
    public String getText() {
        return &quot;&amp;lt;del&amp;gt;&quot; + target.getText() + &quot;&amp;lt;/del&amp;gt;&quot;;
    }
}

public class Main {
    public static void main(String[] args) {
        TextNode textNode = ...
        ...
        // textNode 是已经添加好一些效果的 TextNode
        // 假设是 &amp;lt;b&amp;gt;Hello World&amp;lt;/b&amp;gt;
        // 现在我们想要往上面添加删除线效果
        TextNode delTextNode = new DelTextNode(textNode);
        System.out.println(delTextNode.getText());
        // 将输出 &amp;lt;del&amp;gt;&amp;lt;b&amp;gt;Hello World&amp;lt;/b&amp;gt;&amp;lt;/del&amp;gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们发现每一个效果类对外提供的接口都是一样的，不妨将其设成一个装饰器类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class NodeDecorator implements TextNode {
    protected final TextNode target;

    protected NodeDecorator(TextNode target) {
        this.target = target;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;去除所有效果后剩下的是一段文本，这需要一个类实现，我们称为核心类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TextNodeCore implements TextNode {
    private String text;

    public void TextNodeCore(String text) {
        this.text = text;
    }

    public String getText() {
        return text;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后将之前提到的所有效果类修改为 &lt;code&gt;NodeDecorator&lt;/code&gt; 装饰器的子类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class DelTextNode extends NodeDecorator {
    DelTextNode(TextNode target) {
        super(target)
    }
    public String getText() {
        return &quot;&amp;lt;del&amp;gt;&quot; + target.getText() + &quot;&amp;lt;/del&amp;gt;&quot;;
    }
}
class BlackTextNode extends NodeDecorator {
    DelTextNode(TextNode target) {
        super(target)
    }
    public String getText() {
        return &quot;&amp;lt;b&amp;gt;&quot; + target.getText() + &quot;&amp;lt;/b&amp;gt;&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要渲染一段加粗、加删除线效果的文本可以这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        TextNode textNode = new TextNodeCore(&quot;Hello World&quot;);
        TextNode delBlackTextNode = 
            new DelTextNode(new BlackTextNode(textNode));
        System.out.println(delBlackTextNode.getText());
        // &amp;lt;del&amp;gt;&amp;lt;b&amp;gt;Hello World&amp;lt;/b&amp;gt;&amp;lt;/del&amp;gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;行为型模式&lt;/h3&gt;
&lt;h4&gt;策略模式&lt;/h4&gt;
&lt;p&gt;定义一组算法，每个算法都封装在一个类中，这些类实现（继承）自同一个接口（类）。客户端可以灵活选择其中一个算法使用。&lt;/p&gt;
&lt;p&gt;以购物车结算为例。购物车中有一些列物品，顾客可以选择用信用卡支付或 Paypal 支付。每次结算时，购物车将计算出总花费，然后使用相应方式支付。&lt;/p&gt;
&lt;p&gt;但是信用卡或 Paypal 的支付逻辑是不同的，将逻辑写死在购物车对象中将提高耦合度，可以将支付方法抽象成接口，使用不同的&lt;strong&gt;策略&lt;/strong&gt;来实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface PaymentStrategy {
    public void pay(int payment);
}

public class CreditCardStrategy implements PaymentStrategy {
    ...
    public CreditCardStrategy(
        String nm, String ccNum, String cvv, String expiryDate){...}
    @Override
    public void pay(int amount) {
        System.out.println(amount + &quot; paid with credit card&quot;);
    }
}

public class PaypalStrategy implements PaymentStrategy {
    private String emailId;
    private String password;
    public PaypalStrategy(String email, String pwd){ ... }
    @Override
    public void pay(int amount) {
        System.out.println(amount + &quot; paid using Paypal.&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class ShoppingCart {
    ...
    public void pay(PaymentStrategy paymentMethod){
        int amount = calculateTotal();
        paymentMethod.pay(amount);
    }
}

public class ShoppingCartTest {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        Item item1 = new Item(&quot;1234&quot;,10);
        Item item2 = new Item(&quot;5678&quot;,40);
        cart.addItem(item1);
        cart.addItem(item2);
        //pay by paypal
        cart.pay(new PaypalStrategy(&quot;myemail@exp.com&quot;, &quot;mypwd&quot;));
        //pay by credit card
        cart.pay(new CreditCardStrategy(&quot;Alice&quot;, &quot;1234&quot;, &quot;786&quot;, &quot;12/18&quot;));
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;模板模式&lt;/h4&gt;
&lt;p&gt;假设你要为一款游戏中的一种战斗单位设计 AI 算法，假设所有种族的这种单位的进攻流程都是一样的：1.如果没有敌人则待命；2.锁定敌人；3.靠近敌人；4.攻击敌人。&lt;/p&gt;
&lt;p&gt;但是不同种族的这种单位锁敌、攻击方式不同。&lt;strong&gt;模板模式&lt;/strong&gt;的做法就是复用相同的进攻流程，然后将不同种族战斗单位的行为差异下方到子类实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abstract class GameAI {
    final public void action() {
        if(noEnemy()) standby();
        spotEnemy();
        approachEnemy();
        attackEnemy();
    }
    abstract void spotEnemy();  // 锁定敌人
    abstract void approachEnemy();  // 靠近敌人
    abstract void attackEnemy();    // 攻击敌人
    abstract void standby();    //待命
}

class OrcsAI extends GameAI {
    void spotEnemy() { ... }
    void approachEnemy() { ... }
    void attackEnemy() { ... }
    void standby() { ... }
}

class MonstersAI extends GameAI {
    void spotEnemy() { ... }
    void approachEnemy() { ... }
    void attackEnemy() { ... }
    void standby() { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如此一来，客户端可以轻易创建这几种 AI 的实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        OrcsAI orcsAI = new OrcsAI();
        MonstersAI monstersAI = new MonstersAI();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;迭代器模式&lt;/h4&gt;
&lt;p&gt;提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。&lt;/p&gt;
&lt;p&gt;事实上，我们都曾用过迭代器，下面两种遍历方式是等价的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list1 = new ArrayList&amp;lt;&amp;gt;();
for (String s : list1) {
    ...
}
List&amp;lt;String&amp;gt; list2 = new ArrayList&amp;lt;&amp;gt;();
for (Iterator&amp;lt;String&amp;gt; it = list2.iterator(); it.hasNext(); ) {
    String s = it.next();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;迭代器中常用的三个方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hasNext&lt;/code&gt; ：是否存在下一个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next&lt;/code&gt; ：返回当前元素，指向下一个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;remove&lt;/code&gt; ：移除上一次调用 &lt;code&gt;next&lt;/code&gt; 时返回的那个元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;迭代器模式的最佳实践是使用 Java 的 Iterable 和 Iterator 接口实现一个自定义迭代顺序的集合，此处我们实现一个倒序遍历数组的集合：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ReverseArrayCollection&amp;lt;T&amp;gt; implements Iterable&amp;lt;T&amp;gt; {
    T[] array;

    @SafeVarargs
    public ReverseArrayCollection(T... array) {
        this.array = Arrays.copyOfRange(array, 0, array.length);
    }

    @Override
    public Iterator&amp;lt;T&amp;gt; iterator() {
        return new ReverseIterator(this);
    }

    @Override
    public void forEach(Consumer&amp;lt;? super T&amp;gt; action) {
        Iterable.super.forEach(action);
    }

    class ReverseIterator implements Iterator&amp;lt;T&amp;gt; {
        int index;
        ReverseArrayCollection&amp;lt;T&amp;gt; reverseArrayCollection;

        ReverseIterator(ReverseArrayCollection&amp;lt;T&amp;gt; reverseArrayCollection) {
            this.reverseArrayCollection = reverseArrayCollection;
            index = reverseArrayCollection.array.length;
        }

        @Override
        public boolean hasNext() {
            return index &amp;gt; 0;
        }

        @Override
        public T next() {
            index--;
            return reverseArrayCollection.array[index];
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        ReverseArrayCollection&amp;lt;Integer&amp;gt; reverseArrayCollection = 
            new ReverseArrayCollection&amp;lt;&amp;gt;(1, 2, 3);
        for (Integer integer : reverseArrayCollection) {
            System.out.println(integer);
        }
        // 输出 3 2 1
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;访问者模式&lt;/h4&gt;
&lt;p&gt;访问者模式是最复杂的设计模式之一，概念十分抽象，我们直接从例子切入：&lt;/p&gt;
&lt;p&gt;一家公司有工程师（&lt;code&gt;Engineer&lt;/code&gt;）和经理（&lt;code&gt;Manager&lt;/code&gt;）两种职务，他们实现了 &lt;code&gt;Staff&lt;/code&gt; 接口。&lt;/p&gt;
&lt;p&gt;工程师的工作指标有代码量和 KPI；经理的工作指标有产品数量和 KPI，假设它们的类如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public abstract class Staff { // 员工

    private String name;
    private int kpi;// 员工KPI
    ...
}
public class Engineer extends Staff { // 工程师
    private int codeAmount;
    ...
}
public class Manager extends Staff { // 经理
    private int productionAmount;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;年底绩效考核时，公司的 CEO 只关注工程师的代码量和经理的产品数量，CTO 只关注工程师和经理的KPI。&lt;/p&gt;
&lt;p&gt;所有工程师和经理都放在一个 &lt;code&gt;List&amp;lt;Staff&amp;gt;&lt;/code&gt; 中，CEO 和 CTO 对这些数据的关注点是不一样的。&lt;/p&gt;
&lt;p&gt;一种 naive 的做法是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        List&amp;lt;Staff&amp;gt; staffList = new ArrayList&amp;lt;&amp;gt;();
        ...
        for(Staff staff : staffList) {
            cto.visit(staff);
            ceo.visit(staff);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;interface ChiefOfficer {
    void visit(Staff staff);
}
class CEO implements ChiefOfficer {
    @Override
    private void visit(Staff staff) {
        if (staff instanceof Manager) {
            Manager manager = (Manager) staff;
            // CEO 看经理数据
        } else if (staff instanceof Engineer) {
            Engineer engineer = (Engineer) staff;
            // CEO 看工程师数据
        }
    }
}
class CTO implements ChiefOfficer {
    @Override
    private void visit(Staff staff) {
        if (staff instanceof Manager) {
            // CTO 看经理数据
        } else if (staff instanceof Engineer) {
            // CTO 看工程师数据
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方法的痛点在于 if-else 逻辑的嵌套以及类型的强制转换，难以扩展和维护。如果用户类型很多，Chief Officer 也很多，每个人的 &lt;code&gt;visit&lt;/code&gt; 方法内的逻辑就会非常复杂。&lt;/p&gt;
&lt;p&gt;访问者（Visitor）模式能解决这个问题。其中 visit 指的是对&lt;strong&gt;数据&lt;/strong&gt;的，本例中的 &lt;code&gt;Staff&lt;/code&gt; 就是数据。&lt;/p&gt;
&lt;p&gt;本例中的 Chief Officer 就是所谓的访问者，我们只需要对其稍加修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Visitor {
    void visit(Engineer engineer); // 访问工程师类型
    void visit(Manager manager); // 访问经理类型
}
// CTO访问者
public class CTOVisitor implements Visitor {
    @Override
    public void visit(Engineer engineer) {
        // CTO 看工程师数据
    }
    @Override
    public void visit(Manager manager) {
        // CTO 看经理数据
    }
}
// CEO访问者
public class CEOVisitor implements Visitor {
    @Override
    public void visit(Engineer engineer) {
        // CEO 看工程师数据
    }
    @Override
    public void visit(Manager manager) {
        // CEO 看经理数据
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是这样还不够，我们不希望在客户端直接调用 &lt;code&gt;visit&lt;/code&gt; 方法，而是转移到被访问的对象的 &lt;code&gt;accept&lt;/code&gt; 方法里使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class Staff {
    private String name;
    private int kpi;// 员工KPI
    public abstract void accept(Visitor visitor);
    ...
}
public class Engineer extends Staff {
    private int codeAmount;
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
    ...
}
public class Manager extends Staff {
    private int productionAmount;
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当被访问对象存在特殊的数据结构时，客户端并不关心这些结构，只有被访问者才知道以何种方式调用 &lt;code&gt;visit&lt;/code&gt; 方法。也就是说，实际环境中 &lt;code&gt;accept&lt;/code&gt; 方法中可能不止 &lt;code&gt;visitor.visit(this);&lt;/code&gt; 这样简单的逻辑，可能有其他操作，如果不将调用 &lt;code&gt;visit&lt;/code&gt; 方法的责任交给被访问对象，这些逻辑就会写在客户端中，要知道我们可能有很多种被访问对象，届时客户端会变得非常复杂。&lt;/p&gt;
&lt;h2&gt;第 12 章 正确性与健壮性&lt;/h2&gt;
&lt;h3&gt;概念&lt;/h3&gt;
&lt;h4&gt;健壮性&lt;/h4&gt;
&lt;p&gt;系统在不正常输入或不正常外部环境下仍能够表现正常的程度&lt;/p&gt;
&lt;p&gt;要想编写健壮性强的程序，应该注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设用户想要恶意破坏代码，假设自己的代码可能运行不正确&lt;/li&gt;
&lt;li&gt;假设用户有非法输入&lt;/li&gt;
&lt;li&gt;健壮性准则：对自身代码保守，对用户行为开放&lt;/li&gt;
&lt;li&gt;隐藏实现细节&lt;/li&gt;
&lt;li&gt;考虑边界条件&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;正确性&lt;/h4&gt;
&lt;p&gt;程序按照 spec 的规定执行。这是&lt;strong&gt;最重要&lt;/strong&gt;的质量指标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正确性&lt;/strong&gt;与&lt;strong&gt;健壮性&lt;/strong&gt;的对比：对外接口倾向于健壮；对内实现倾向于正确。&lt;/p&gt;
&lt;h3&gt;Java 的异常处理&lt;/h3&gt;
&lt;h4&gt;异常的分类&lt;/h4&gt;
&lt;p&gt;Java 中所有异常类都最终&lt;strong&gt;继承&lt;/strong&gt;自 &lt;code&gt;Throwable&lt;/code&gt; &lt;strong&gt;类&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Throwable&lt;/code&gt; 两个子类 &lt;strong&gt;Error&lt;/strong&gt; 和 &lt;strong&gt;Exception&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Error&lt;/code&gt; 一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和预防，遇到这样的错误，建议让程序终止。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Exception&lt;/code&gt; 表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Exception&lt;/code&gt; 是程序中非正常事件，使程序不能继续往下执行，可以被 &lt;code&gt;catch&lt;/code&gt; 关键字捕获，然后执行异常处理程序。&lt;code&gt;Exception&lt;/code&gt; 也可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RuntimeException&lt;/code&gt;：运行时异常，完全由开发者造成；如果在代码中提前进行验证，这些故障就可以避免。&lt;/li&gt;
&lt;li&gt;其他：非运行时异常，由外在问题所导致，开发者无法控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;异常的简单使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void exceptionTest(int n) throws EOFException, ClassNotFoundException {
    try {
        switch (n) {
            case 0 -&amp;gt; throw new FileNotFoundException();
            case 1 -&amp;gt; throw new ClassNotFoundException();
            default -&amp;gt; throw new EOFException();
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        throw new ClassNotFoundException();
    } finally {
        System.out.println(&quot;This statement will always be executed&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;checked 和 unchecked 异常&lt;/h4&gt;
&lt;p&gt;Java &lt;strong&gt;标准规定&lt;/strong&gt;，异常分为 checked 和 unchecked 类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;unchecked ：继承自 &lt;code&gt;Error&lt;/code&gt; 和 &lt;code&gt;RumtimeException&lt;/code&gt; 的异常&lt;/li&gt;
&lt;li&gt;checked ：其他异常&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Check exception&lt;/th&gt;
&lt;th&gt;Unchecked exception&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Basic&lt;/td&gt;
&lt;td&gt;必须被显式捕获或传递&amp;lt;br&amp;gt;（try-catch-finally-throw），&amp;lt;br&amp;gt;否则编译无法通过&lt;/td&gt;
&lt;td&gt;异常不必捕获或抛出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Class of Exception&lt;/td&gt;
&lt;td&gt;其他&lt;/td&gt;
&lt;td&gt;继承自 &lt;code&gt;Error&lt;/code&gt; 和 &lt;code&gt;RumtimeException&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Handling&lt;/td&gt;
&lt;td&gt;获得异常发生现场的详细信息，了解发生异常的原因，并异常中恢复&lt;/td&gt;
&lt;td&gt;仅打印异常信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Appearance&lt;/td&gt;
&lt;td&gt;较复杂，异常处理程序和正常代码混在一起&lt;/td&gt;
&lt;td&gt;简单&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;checked 异常抛出后必须要被 &lt;code&gt;catch&lt;/code&gt; 或在方法声明之后使用 &lt;code&gt;throws&lt;/code&gt; 将异常抛给客户端处理，否则编译不通过。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 编译不通过
public static void main (String args[]) {
    throw new EOFException();
}

// 编译通过
public static void main (String args[]) throws EOFException {
    throw new EOFException();
}

// 编译通过
public static void main (String args[]) {
    try {
        throw new EOFException();
    } catch (EOFException e) {
        e.printStackTrace();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;unchecked 抛出后不需要任何处理，此时将直接打印异常信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main (String args[]) {
    throw new NullPointerException();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般来说，unchecked 异常没必要处理，一方面，出现 &lt;code&gt;Error&lt;/code&gt; 异常时，已无法挽救；另一方面，&lt;code&gt;RumtimeException&lt;/code&gt; 完全是开发者写的程序逻辑有 bug，可以通过修 bug 避免。&lt;/p&gt;
&lt;h4&gt;Checked 异常的处理&lt;/h4&gt;
&lt;h5&gt;声明异常&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;在 spec 中声明：必须在方法的 spec 中用 &lt;code&gt;@throws&lt;/code&gt; 写明该方法将抛出的所有 checked 异常，便于客户端处理；&lt;/li&gt;
&lt;li&gt;在方法声明之后用关键字 &lt;code&gt;throws&lt;/code&gt; 声明可能抛出的所有异常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一种异常：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Compute the integer square root.
 * @param x value to take square toot of
 * @return square root of x
 * @throws NotPerfectSquareException if x is not a perfect square
 */
int integerSquareRoot(int x) throws NotPerfectSquareException;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多种异常：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * ...
 * @throws FileNotFoundException ...
 * @throws EOFException ...
 */
public Image loadImage(String s)
    throws FileNotFoundException, EOFException 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;异常的协变：从父类到子类，异常不变或变得越来越具体，甚至不抛出异常。参见 Liskov 替换原则。&lt;/p&gt;
&lt;h5&gt;抛出异常&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String args[]) throws EOFException {
    throw new EOFException(); 
}

public static void main(String args[]) throws EOFException {
    EOFException e = new EOFException();
    throw e;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;自定义异常&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;checked：继承自 &lt;code&gt;Exception&lt;/code&gt;：&lt;pre&gt;&lt;code&gt;class CarAlreadyParkingException extends Exception {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;unchecked：继承自 &lt;code&gt;RumtimeException&lt;/code&gt;：&lt;pre&gt;&lt;code&gt;class CarAlreadyParkingException extends RumtimeException {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;捕获异常&lt;/h5&gt;
&lt;p&gt;所有异常都可以被捕获，但是通常只捕获 checked 类型异常。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void exceptionTest(int n) throws EOFException, ClassNotFoundException {
    try {
        switch (n) {
            case 0 -&amp;gt; throw new FileNotFoundException();
            case 1 -&amp;gt; throw new ClassNotFoundException();
            default -&amp;gt; throw new EOFException();
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        throw new ClassNotFoundException();
    } finally {
        System.out.println(&quot;This statement will always be executed&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;catch (FileNotFoundException e) {
    ...
} catch (ClassNotFoundException e) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以写为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;catch (FileNotFoundException | ClassNotFoundException e) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;便于统一处理。&lt;/p&gt;
&lt;h5&gt;重新抛出异常&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public static void main (String args[]) throws EOFException {
    test();
}

private void test() throws EOFException {
    throw new EOFException();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行 &lt;code&gt;test&lt;/code&gt; 时，因为 &lt;code&gt;test&lt;/code&gt; 内抛出的 &lt;code&gt;EOFException&lt;/code&gt; 没有被处理，所以通过 &lt;code&gt;throws&lt;/code&gt; 向 &lt;code&gt;main&lt;/code&gt; 函数中抛出该异常，相当于 &lt;code&gt;test&lt;/code&gt; 这条语句处 &lt;code&gt;new&lt;/code&gt; 了一个 &lt;code&gt;EOFException&lt;/code&gt; 。&lt;/p&gt;
&lt;h5&gt;&lt;code&gt;finally&lt;/code&gt; 语句&lt;/h5&gt;
&lt;p&gt;在 &lt;code&gt;try-catch&lt;/code&gt; 之后加一个 &lt;code&gt;finally&lt;/code&gt; 代码块，表示不论是否发发生异常，该代码块都会执行。&lt;/p&gt;
&lt;p&gt;这种设计的目的之一在于，假设当前打开了一个文件，之后抛出异常，正常执行的代码被终止，在方法结束执行前，需要关闭这个文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;InputStream in = new FileInputStream(. . .);
try {
    // 1
    code that might throw exceptions// 2
}
catch (IOException e) {
    // 3
    show error message
    // 4
}
finally {
    // 5
    in.close();
}
    // 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个方法返回 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static Boolean test() {
    try {
        return true;
    }
    finally {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;堆栈追踪&lt;/h5&gt;
&lt;p&gt;有时候运行中的程序会在控制台打印这种信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Exception in thread &quot;main&quot; java.lang.NullPointerException
        at com.example.myproject.Book.getTitle(Book.java:16)
        at com.example.myproject.Author.getBookTitles(Author.java:25)
        at com.example.myproject.Bootstrap.main(Bootstrap.java:14)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种信息可以让我们知道程序中哪个部分出现了错误。&lt;/p&gt;
&lt;p&gt;unchecked 或从 &lt;code&gt;main&lt;/code&gt; 函数向外 &lt;code&gt;throws&lt;/code&gt; 的异常会打印这类信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws CarAlreadyParkingException {

    C c = new C();
    B b = new B(c);
    A a = new A(b);
    a.parking();  // 这句执行后会 throws CarAlreadyParkingException
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Exception in thread &quot;main&quot; CarAlreadyParkingException
	at C.parking(Main.java:75)
	at Parkable.parking(Main.java:52)
	at Parkable.parking(Main.java:52)
	at Main.main(Main.java:19)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;e.printStackTrace();&lt;/code&gt; 将打印这种格式的信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    C c = new C();
    B b = new B(c);
    A a = new A(b);
    try {
        a.parking();
    } catch (CarAlreadyParkingException e) {
        e.printStackTrace();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;CarAlreadyParkingException
	at C.parking(Main.java:79)
	at Parkable.parking(Main.java:56)
	at Parkable.parking(Main.java:56)
	at Main.main(Main.java:20)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;断言&lt;/h3&gt;
&lt;p&gt;在开发阶段的代码中嵌入，检验某些“假设”是否成立。若成立，表明程序运行正常，否则表明存在错误。&lt;/p&gt;
&lt;h4&gt;断言的使用&lt;/h4&gt;
&lt;p&gt;断言的写法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;assert condition;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int x = -1;
assert x &amp;gt; 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;assert condition : message;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int x = -1;
assert x &amp;gt; 0 : &quot;x &amp;lt;= 0&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认情况下，JVM 执行 &lt;code&gt;.class&lt;/code&gt; 文件时是没有启用断言的，也就是说，一般情况下写 &lt;code&gt;assert false&lt;/code&gt; 将没有任何反应。要想启用断言，可以给方法添加 &lt;code&gt;@Test&lt;/code&gt; 注解，或在 &lt;code&gt;VM options&lt;/code&gt; 添加 &lt;code&gt;-ea&lt;/code&gt; 选项。&lt;/p&gt;
&lt;h4&gt;断言与异常的选择&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;检查&lt;strong&gt;前置条件&lt;/strong&gt;是否满足，不满足则抛出异常，可以提升程序&lt;strong&gt;健壮性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用断言 Assert 检查&lt;strong&gt;后置条件&lt;/strong&gt;是否满足，不满足说明程序存在问题（违反表示不变性等），可以提升程序&lt;strong&gt;正确性&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;防御式编程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对来自外部的数据源要仔细检查，例如：文件、网络数据、用户输入等&lt;/li&gt;
&lt;li&gt;对每个函数的输入参数合法性要做仔细检查，并决定如何处理非法输入&lt;/li&gt;
&lt;li&gt;public 方法接受到的外部数据时，需要假设这些参数是不安全或不合法的，需要检查这些参数的合法性再传给 private 方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SpotBugs 是一款 Java 静态代码分析工具。&lt;/p&gt;
</content:encoded></item><item><title>HIT-软件构造 | Java 函数式编程</title><link>https://blog.vonbrank.com/posts/hit-software-construction-java-functional-programming/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/hit-software-construction-java-functional-programming/</guid><description>HIT 软件构造课程 Java 函数式编程笔记</description><pubDate>Wed, 01 Jun 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;函数式编程（Functional Programming）是编程范式的一种，常见的编程范式还有面向过程编程、面向对象编程（OOP）、面向数据编程（DOP）等。&lt;/p&gt;
&lt;p&gt;程序设计语言发展的早期，人们将一段封装起来可供调用的代码块称为 “过程” 或 “函数” ；当函数绑定到对象上用于对象的操作时又被称为 “方法” ；有人始终认为编程语言中应该有真正数学意义上的函数，它应该是一种，对于确定的输入，有确定的输出、没有副作用的纯函数。&lt;/p&gt;
&lt;h2&gt;Lambda 表达式&lt;/h2&gt;
&lt;p&gt;函数式编程的特点之一是，它将函数视作变量，可以作为函数的参数值，也可以作为返回值。我们通常将作为变量的函数称为 “匿名函数” 或 Lambda 表达式。&lt;/p&gt;
&lt;p&gt;在 Java 中如果我们要遍历这样一个列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; fruits = List.of(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可能会这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(int i = 0; i&amp;lt; fruits.size(); i++) {
    System.out.println(fruits.get(i));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果了解迭代器 &lt;code&gt;Iterator&lt;/code&gt; 也许会这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(String fruit : fruits) {
    System.out.println(fruit);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;像是 JetBrains IDEA 这样的智能 IDE 有时会建议我们将上述写法转换为如下写法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fruits.forEach(fruit -&amp;gt; {
    System.out.println(fruit);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这便是对 Lambda 表达式的一次简单使用。&lt;/p&gt;
&lt;p&gt;接着我们来看一下 Java 中 Lambda 表达式的基本结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(arg1, arg2, ...) -&amp;gt; {
    // 一些操作
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到这和一个普通函数有一些相似之处，它通过一个参数列表来传递参数，这些参数甚至不需要指定参数类型，后面加上一个箭头 &lt;code&gt;-&amp;gt;&lt;/code&gt; ，接着是对这个这些参数的一些操作，如果操作有多行那么需要用大括号 &lt;code&gt;{}&lt;/code&gt; 括起来，否则不用。和普通函数类似；执行完函数体内的逻辑后可以用 &lt;code&gt;return&lt;/code&gt; 从函数中返回。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fruits.forEach(fruit -&amp;gt; System.out.println(fruit);&lt;/code&gt; 这句话从语义上非常容易理解：&lt;code&gt;fruit&lt;/code&gt; 调用了 &lt;code&gt;List&lt;/code&gt; 接口的方法 &lt;code&gt;forEach&lt;/code&gt; ，传入一个 &lt;code&gt;lambda&lt;/code&gt; 表达式作为参数。可以想象 &lt;code&gt;forEach&lt;/code&gt; 函数内部对 &lt;code&gt;fruits&lt;/code&gt; 进行了遍历，将每一个元素作为参数传入 &lt;code&gt;lambda&lt;/code&gt; 表达式，在其内对这个元素进行一些操作。此处我们将每次传入的元素命名为 &lt;code&gt;fruit&lt;/code&gt; ，然后打印这一个元素。&lt;/p&gt;
&lt;h2&gt;Lambda API&lt;/h2&gt;
&lt;p&gt;像 &lt;code&gt;.forEach&lt;/code&gt; 这样一个接受 Lambda 表达式的方法叫做 Lambda API。同其他支持函数式编程的语言一样，Java 提供了几个经典的 Lambda API : &lt;code&gt;map&lt;/code&gt; , &lt;code&gt;filter&lt;/code&gt; , &lt;code&gt;reduce&lt;/code&gt; 。&lt;/p&gt;
&lt;h3&gt;使用 Stream&lt;/h3&gt;
&lt;p&gt;在使用这些 API 之前我们需要先了解 Java 的 Stream API ，因为 Lambda API 大都和来自 Stream API 而不是 &lt;code&gt;List&lt;/code&gt; 等接口，在使用这些 API 时，需要先将 &lt;code&gt;List&lt;/code&gt; 转换为 &lt;code&gt;Stream&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Stream&lt;/code&gt; 和 &lt;code&gt;List&lt;/code&gt; 有亿点点不一样。&lt;code&gt;List&lt;/code&gt; 中每个元素都是确定的存储在内存中的；而 &lt;code&gt;Stream&lt;/code&gt; 可以是一个有确定元素的列表，也可以是一个形如 “全体” 自然数集合的抽象列表，操作时使用 &lt;code&gt;limit&lt;/code&gt; 等方法将其截断转换为一个有确定元素的 &lt;code&gt;Stream&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Stream&lt;/code&gt; 的详细内容不是本文的重点，通常我们将其看成一种特殊的列表就好了，但是我们还是在此举一个使用 &lt;code&gt;Stream&lt;/code&gt; 的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 获取全体自然数
Stream&amp;lt;BigInteger&amp;gt; naturalNumbers = createNaturalStream();
naturalNumbers
    .map(BigInteger::multiply) //全体自然数的乘积
    .limit(100) // 截取前 100 个元素
    .forEach(System.out::println);  // 逐一打印每个元素
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;forEach&lt;/code&gt; 中传入 &lt;code&gt;System.out::println&lt;/code&gt; 看起来很奇怪也有点恐怖，因为这是后文的方法引用相关内容，此处我们只需要知道这样写可以打印数据就行了。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;map&lt;/code&gt; &lt;code&gt;filter&lt;/code&gt; 和 &lt;code&gt;reduce&lt;/code&gt; 方法&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/13/aUKdFiQbPeh8kZG.jpg&quot; alt=&quot;图 1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;上图对 &lt;code&gt;map&lt;/code&gt; 、 &lt;code&gt;filter&lt;/code&gt; 和 &lt;code&gt;reduce&lt;/code&gt; 的解释可以说是 “不言而喻，一目了然” 了，此处我们直接看代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; listMap = list.stream().map(current -&amp;gt; current * 2).toList();
for (Integer n : listMap)
    System.out.printf(&quot;%d &quot;, n);
System.out.println();   // 6 2 8 6 4 

List&amp;lt;Integer&amp;gt; listFilter = list.stream().filter(current -&amp;gt; current &amp;gt; 2).toList();
for (Integer n : listFilter)
    System.out.printf(&quot;%d &quot;, n);
System.out.println();   // 3 4 3 

Integer listReduceResult = list.stream().reduce(0, (acc, current) -&amp;gt; acc + current);
System.out.println(listReduceResult);   // 13
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;方法引用&lt;/h2&gt;
&lt;p&gt;lambda 表达式实际上也是一个函数，这意味着 lambda API 不仅能接受 lambda 表达式，也能接受函数，比如我们可以通过 &lt;code&gt;.forEach&lt;/code&gt; 方法打印一个 &lt;code&gt;list&lt;/code&gt; 的所有成员：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = List.of(3, 1, 4, 3, 2);
list.forEach(current -&amp;gt; {
    System.out.println(current);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它将遍历 &lt;code&gt;list&lt;/code&gt; 将每个元素传入 &lt;code&gt;lambda&lt;/code&gt; 表示，我们的 &lt;code&gt;lambda&lt;/code&gt; 表达式只是简单调用 &lt;code&gt;System.out.println&lt;/code&gt; ，将这个参数传入而已。这个方法的签名和 &lt;code&gt;lambda&lt;/code&gt; 表达式完全一致，那么我们久可以把这个函数直接传入 lambda API 。以下代码和上述代码等效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = List.of(3, 1, 4, 3, 2);
list.forEach(System.out::println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种将相同签名的方法传入 lambda API 的操作被称为方法引用。&lt;/p&gt;
&lt;h2&gt;自定义 Lambda API&lt;/h2&gt;
&lt;p&gt;Java 标准库提供了很多 lambda API 。我们当然也可以编写自己的 lambda API。&lt;/p&gt;
&lt;p&gt;Java 的 lambda 表达式实际上是使用单方法接口实现的。调用 lambda API 并传入 lambda 表达式时，实际上是将 lambda 表达式作为一个单方法接口的实现，然后传入这个接口的一个实例。&lt;/p&gt;
&lt;p&gt;比如我们想实现自己的 &lt;code&gt;forEach&lt;/code&gt; 函数，这个函数接受需要迭代的对象，还接受对每个对象的处理逻辑，后者就是一个签名为 &lt;code&gt;&amp;lt;T&amp;gt; void (T)&lt;/code&gt; 的 lambda 表达式。&lt;code&gt;forEach&lt;/code&gt; 接口的签名可以是 &lt;code&gt;&amp;lt;T&amp;gt; void forEach(List&amp;lt;T&amp;gt;, MyForEach&amp;lt;T&amp;gt;)&lt;/code&gt; ，&lt;code&gt;MyForEach&amp;lt;T&amp;gt;&lt;/code&gt; 是一个单方法接口，又称函数式接口，声明这个接口时应使用 &lt;code&gt;@FunctionalInterface&lt;/code&gt; 注解：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@FunctionalInterface
interface MyForEach&amp;lt;T&amp;gt; {
    void run(T current);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;客户端使用时可以这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        List&amp;lt;Integer&amp;gt; list = List.of(3, 1, 4, 3, 2);
        forEach(list, current -&amp;gt; System.out.printf(&quot;%d &quot;, current));
    }

    private static  &amp;lt;T&amp;gt; void forEach(List&amp;lt;T&amp;gt; list, MyForEach&amp;lt;T&amp;gt; myForEach) {
        for(T t : list) {
            myForEach.run(t);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它等价于传统的写法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        List&amp;lt;Integer&amp;gt; list = List.of(3, 1, 4, 3, 2);
        forEach(list, new MyForEach&amp;lt;Integer&amp;gt;() {
            @Override
            public void run(Integer current) {
                System.out.printf(&quot;%d &quot;, current);
            }
        });
    }

    private static  &amp;lt;T&amp;gt; void forEach(List&amp;lt;T&amp;gt; list, MyForEach&amp;lt;T&amp;gt; myForEach) {
        for(T t : list) {
            myForEach.run(t);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>HIT-软件构造 | Java 反射</title><link>https://blog.vonbrank.com/posts/hit-software-construction-java-reflection/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/hit-software-construction-java-reflection/</guid><description>HIT 软件构造课程 Java 反射笔记</description><pubDate>Sat, 21 May 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;在 Java 运行时，如果我们拿到一个 &lt;code&gt;Object&lt;/code&gt; ，它可能是某个类的实例。如果我们想使用这个类的某个方法，却不知道这个类的名字，即连强制类型转换也做不了，那如何调用我们想要执行的方法呢。解决方案是使用 Java 反射。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;Class&lt;/code&gt; 类与实例&lt;/h2&gt;
&lt;p&gt;如果我们有两个类 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 的实例，然后将其转换成 &lt;code&gt;Object&lt;/code&gt; 实例。表面上我们看不出这两个 &lt;code&gt;Object&lt;/code&gt; 实例的区别，因为我们对他们的信息一无所知，但是这只是因为他们的引用是 &lt;code&gt;Object&lt;/code&gt; 类型的而已。&lt;/p&gt;
&lt;p&gt;Java runtime 提供了一种数据类型，称为 &lt;code&gt;Class&lt;/code&gt; ，Java 程序开始运行后，每次首次加载一个 &lt;code&gt;class&lt;/code&gt; ，都会用这个 &lt;code&gt;class&lt;/code&gt; 的信息创建一个 &lt;code&gt;Class&lt;/code&gt; 实例，即这个 &lt;code&gt;Class&lt;/code&gt; 实例将会包含这个类的所有信息。&lt;code&gt;Object&lt;/code&gt; 类提供了一个接口能让我们拿到任何一个对象的 &lt;code&gt;Class&lt;/code&gt; 实例。也就是说，对于上述的 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 转换成 &lt;code&gt;Object&lt;/code&gt; 后的实例，我们可以拿到它们的 &lt;code&gt;Class&lt;/code&gt; 实例，来区分这两个实例哪一个是 &lt;code&gt;Type1&lt;/code&gt; 的实例、哪一个是 &lt;code&gt;Type2&lt;/code&gt; 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Type1 { ... }
class Type2 { ... }

Type1 type1 = new Type1();
Type2 type2 = new Type2();

Object obj1 = (Object)type1;
Object obj2 = (Object)type2;

Class cls1 = obj1.getClass();
Class cls2 = obj2.getClass();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除此之外，还可以已知类的名字，然后直接获得其 &lt;code&gt;Class&lt;/code&gt; 实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Type1.class;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或使用包路径格式的完整类名：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Class.forName(&quot;com.vonbrank.Type1&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;用 &lt;code&gt;Class&lt;/code&gt; 实例访问字段&lt;/h2&gt;
&lt;p&gt;假设有一个类 &lt;code&gt;Person&lt;/code&gt; ，定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Person {
    private String name;
    public Person(String name) {
        this.name = name;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在下面的 &lt;code&gt;test&lt;/code&gt; 方法中，我们只能拿到它实例的 &lt;code&gt;Object&lt;/code&gt; 引用，如果想访问 &lt;code&gt;name&lt;/code&gt; 可以这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        Person person = new Person(&quot;Xiao Ming&quot;);
        test(person);
    }

    static void test(Object obj) {
        Class cls = obj.getClass();
        Field field = cls.getDeclaredField(&quot;name&quot;);
        Object value = field.get(p);
        System.out.println(value); // &quot;Xiao Ming&quot;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;调用方法&lt;/h2&gt;
&lt;p&gt;此处我们以 &lt;code&gt;String&lt;/code&gt; 为例展示通过反射调用对象实例的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws Exception {
        // String对象:
        String s = &quot;Hello world&quot;;
        // 获取String substring(int)方法，参数为int:
        Method m = String.class.getMethod(&quot;substring&quot;, int.class);
        // 在s对象上调用该方法并获取结果:
        String r = (String) m.invoke(s, 6);
        // 打印调用结果:
        System.out.println(r);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>HIT-软件构造 | 设计模式选讲</title><link>https://blog.vonbrank.com/posts/hit-software-construction-design-pattern/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/hit-software-construction-design-pattern/</guid><description>装饰器模式、访问者模式、观察者模式、责任链模式</description><pubDate>Tue, 10 May 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;装饰器模式&lt;/h2&gt;
&lt;p&gt;假设我们要渲染一段 HTML 文本，HTML 可以标记文本的附加效果，比如一段加粗、加删除线的文本的 HTML 实现可以是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;del&amp;gt;&amp;lt;b&amp;gt;Hello World&amp;lt;/b&amp;gt;&amp;lt;/del&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果： &lt;s&gt;&lt;strong&gt;Hello World&lt;/strong&gt;&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;当然，现代 Web 前端技术主张使用 CSS 实现这些样式。&lt;/p&gt;
&lt;p&gt;实现类似附加效果最 naive 的方法可以是直接写一个类来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface TextNode {
    String getText();
}

class BlackNode implements TextNode {
    private String text;
    public void BlackNode(String text) {
        this.text = text;
    }
    public String getText() {
        return &quot;&amp;lt;b&amp;gt;&quot; + text + &quot;&amp;lt;/b&amp;gt;&quot;;
    }
}

public class Main {
    public static void main(String[] args) {
        TextNode textNode = new BlackNode(&quot;Hello World&quot;);
        System.out.println(textNode.getText());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们想给黑体文本加上下划线，可以新建一个类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class DeleteBlackNode implements TextNode {
    private String text;
    public void DeleteBlackNode(String text) {
        this.text = text;
    }
    public String getText() {
        return &quot;&amp;lt;del&amp;gt;&amp;lt;b&amp;gt;&quot; + text + &quot;&amp;lt;/b&amp;gt;&amp;lt;/del&amp;gt;&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是这样将导致一个严重的问题，一段文本可以添加的效果有粗体、斜体、下划线、删除线、字号、颜色等，这些效果可以任意组合，如果给任意一种组合编写一个类，子类数量会爆炸性增长。&lt;/p&gt;
&lt;p&gt;装饰器模式的目的是，一个子类只负责一个效果，通过委托的方式将这种效果累加到已经添加好其他效果的文本上。&lt;/p&gt;
&lt;p&gt;为了更好地理解装饰器模式，以上述例子为例，我们希望写出的类是这样的（其中 &lt;code&gt;target&lt;/code&gt; 是一个已经添加好部分效果的 &lt;code&gt;TextNode&lt;/code&gt;）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class DelTextNode implements TextNode {
    DelTextNode(TextNode textNode) {
        this.target = textNode;
    }
    public String getText() {
        return &quot;&amp;lt;del&amp;gt;&quot; + target.getText() + &quot;&amp;lt;/del&amp;gt;&quot;;
    }
}

public class Main {
    public static void main(String[] args) {
        TextNode textNode = ...
        ...
        // textNode 是已经添加好一些效果的 TextNode
        // 假设是 &amp;lt;b&amp;gt;Hello World&amp;lt;/b&amp;gt;
        // 现在我们想要往上面添加删除线效果
        TextNode delTextNode = new DelTextNode(textNode);
        System.out.println(delTextNode.getText());
        // 将输出 &amp;lt;del&amp;gt;&amp;lt;b&amp;gt;Hello World&amp;lt;/b&amp;gt;&amp;lt;/del&amp;gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们发现每一个效果类对外提供的接口都是一样的，不妨将其设成一个装饰器类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class NodeDecorator implements TextNode {
    protected final TextNode target;

    protected NodeDecorator(TextNode target) {
        this.target = target;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;去除所有效果后剩下的是一段文本，这需要一个类实现，我们称为核心类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TextNodeCore implements TextNode {
    private String text;

    public void TextNodeCore(String text) {
        this.text = text;
    }

    public String getText() {
        return text;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后将之前提到的所有效果类修改为 &lt;code&gt;NodeDecorator&lt;/code&gt; 装饰器的子类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class DelTextNode extends NodeDecorator {
    DelTextNode(TextNode target) {
        super(target)
    }
    public String getText() {
        return &quot;&amp;lt;del&amp;gt;&quot; + target.getText() + &quot;&amp;lt;/del&amp;gt;&quot;;
    }
}
class BlackTextNode extends NodeDecorator {
    DelTextNode(TextNode target) {
        super(target)
    }
    public String getText() {
        return &quot;&amp;lt;b&amp;gt;&quot; + target.getText() + &quot;&amp;lt;/b&amp;gt;&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要渲染一段加粗、加删除线效果的文本可以这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        TextNode textNode = new TextNodeCore(&quot;Hello World&quot;);
        TextNode delBlackTextNode = 
            new DelTextNode(new BlackTextNode(textNode));
        System.out.println(delBlackTextNode.getText());
        // &amp;lt;del&amp;gt;&amp;lt;b&amp;gt;Hello World&amp;lt;/b&amp;gt;&amp;lt;/del&amp;gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;访问者模式&lt;/h2&gt;
&lt;p&gt;访问者模式是最复杂的设计模式之一，概念十分抽象，我们直接从例子切入：&lt;/p&gt;
&lt;p&gt;一家公司有工程师（&lt;code&gt;Engineer&lt;/code&gt;）和经理（&lt;code&gt;Manager&lt;/code&gt;）两种职务，他们实现了 &lt;code&gt;Staff&lt;/code&gt; 接口。&lt;/p&gt;
&lt;p&gt;工程师的工作指标有代码量和 KPI；经理的工作指标有产品数量和 KPI，假设它们的类如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public abstract class Staff { // 员工

    private String name;
    private int kpi;// 员工KPI
    ...
}
public class Engineer extends Staff { // 工程师
    private int codeAmount;
    ...
}
public class Manager extends Staff { // 经理
    private int productionAmount;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;年底绩效考核时，公司的 CEO 只关注工程师的代码量和经理的产品数量，CTO 只关注工程师和经理的KPI。&lt;/p&gt;
&lt;p&gt;所有工程师和经理都放在一个 &lt;code&gt;List&amp;lt;Staff&amp;gt;&lt;/code&gt; 中，CEO 和 CTO 对这些数据的关注点是不一样的。&lt;/p&gt;
&lt;p&gt;一种 naive 的做法是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        List&amp;lt;Staff&amp;gt; staffList = new ArrayList&amp;lt;&amp;gt;();
        ...
        for(Staff staff : staffList) {
            cto.visit(staff);
            ceo.visit(staff);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;interface ChiefOfficer {
    void visit(Staff staff);
}
class CEO implements ChiefOfficer {
    @Override
    private void visit(Staff staff) {
        if (staff instanceof Manager) {
            Manager manager = (Manager) staff;
            // CEO 看经理数据
        } else if (staff instanceof Engineer) {
            Engineer engineer = (Engineer) staff;
            // CEO 看工程师数据
        }
    }
}
class CTO implements ChiefOfficer {
    @Override
    private void visit(Staff staff) {
        if (staff instanceof Manager) {
            // CTO 看经理数据
        } else if (staff instanceof Engineer) {
            // CTO 看工程师数据
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方法的痛点在于 if-else 逻辑的嵌套以及类型的强制转换，难以扩展和维护。如果用户类型很多，Chief Officer 也很多，每个人的 &lt;code&gt;visit&lt;/code&gt; 方法内的逻辑就会非常复杂。&lt;/p&gt;
&lt;p&gt;访问者（Visitor）模式能解决这个问题。其中 visit 指的是对&lt;strong&gt;数据&lt;/strong&gt;的，本例中的 &lt;code&gt;Staff&lt;/code&gt; 就是数据。&lt;/p&gt;
&lt;p&gt;本例中的 Chief Officer 就是所谓的访问者，我们只需要对其稍加修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Visitor {
    void visit(Engineer engineer); // 访问工程师类型
    void visit(Manager manager); // 访问经理类型
}
// CTO访问者
public class CTOVisitor implements Visitor {
    @Override
    public void visit(Engineer engineer) {
        // CTO 看工程师数据
    }
    @Override
    public void visit(Manager manager) {
        // CTO 看经理数据
    }
}
// CEO访问者
public class CEOVisitor implements Visitor {
    @Override
    public void visit(Engineer engineer) {
        // CEO 看工程师数据
    }
    @Override
    public void visit(Manager manager) {
        // CEO 看经理数据
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是这样还不够，我们不希望在客户端直接调用 &lt;code&gt;visit&lt;/code&gt; 方法，而是转移到被访问的对象的 &lt;code&gt;accept&lt;/code&gt; 方法里使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class Staff {
    private String name;
    private int kpi;// 员工KPI
    public abstract void accept(Visitor visitor);
    ...
}
public class Engineer extends Staff {
    private int codeAmount;
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
    ...
}
public class Manager extends Staff {
    private int productionAmount;
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当被访问对象存在特殊的数据结构时，客户端并不关心这些结构，只有被访问者才知道以何种方式调用 &lt;code&gt;visit&lt;/code&gt; 方法。也就是说，实际环境中 &lt;code&gt;accept&lt;/code&gt; 方法中可能不止 &lt;code&gt;visitor.visit(this);&lt;/code&gt; 这样简单的逻辑，可能有其他操作，如果不将调用 &lt;code&gt;visit&lt;/code&gt; 方法的责任交给被访问对象，这些逻辑就会写在客户端中，要知道我们可能有很多种被访问对象，届时客户端会变得非常复杂。&lt;/p&gt;
&lt;h2&gt;观察者模式&lt;/h2&gt;
&lt;p&gt;在前端领域常用的 MVC 架构模式中，有三个重要的组件：Model、View 和 Controller。图中实线箭头表示模块间的依赖关系，虚线箭头表示数据流向。用户点击 UI 上的某个按钮时，Controller 将相应这个点击事件，调用 Model 更新 UI 状态，然后 Controller 重新渲染页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/14/ZXTSwEpqPNjGByn.jpg&quot; alt=&quot;图 2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;此处有一个重要问题：Controller 如何监听用户对 View 的操作？即如何让用户在点击某个按钮或做出其他操作时，Controller 能做出相应反应？有两种 Naive 的做法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;View 维护 UI 组件的状态，如用户点击按钮时标记被点击的组件；Controller 定期持续轮询所有 UI 组件，当发现被组件被标记点击时，调用相应处理函数 &lt;code&gt;callbackFunction&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;View 直接依赖 Controller ，持有 Controller 实例，触发 UI 事件时，View 直接调用对应函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两种做法都有严重问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;做法 $1$ ：Controller 持续轮询 UI 组件性能太差，且如果用户在一个轮询周期内做出两个相互依赖的操作，将导致时序问题。&lt;/li&gt;
&lt;li&gt;做法 $2$ ：这严重违背 MVC 模式的设计初衷，导致 Controller 和 View 循环依赖，相互耦合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决方案是使用观察者模式，对于一个 UI 组件，View 只持有 &lt;code&gt;callbackFunction&lt;/code&gt; 的引用，而不是整个 Controller ，使用时只需要确定好 &lt;code&gt;callbackFunction&lt;/code&gt; 的接口规约，就能实现 Controller 对 View 的单向依赖，即 View 并不知道 Controller 的存在，实现解耦。&lt;/p&gt;
&lt;p&gt;以一个 Web 前端菜谱管理页面为例，我们要实现通过一个按钮添加菜谱的功能，点击 &lt;code&gt;Add Recipe&lt;/code&gt; 按钮，&lt;code&gt;AddRecipeView&lt;/code&gt; 组件将获得用户输入的菜谱数据 &lt;code&gt;data&lt;/code&gt; ，我们需要让 Controller 监听这一事件，并让 Controller 将原始 &lt;code&gt;data&lt;/code&gt; 传递给 Model 。&lt;/p&gt;
&lt;p&gt;View 部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// view.js
class View {
    ...
    // View 基类的实现省略
}

class AddRecipeView extends View {
    ...
    // AddRecipeView 其他部分省略

    addHandlerUpload(handler) {
        this._paretElement.addEventListener(&quot;submit&quot;, function(e) {
            // 只保留 data 传递的业务逻辑
            ...
            const data = ...
            ...
            handler(data);
        });
    }
}

export default new AddRecipeView();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Controller 部分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// controller.js

import * as model from &quot;./model.js&quot;;
import { addRecipeView } from &quot;view.js&quot;;

...

const controlAddRecipe = async function (newRecipe) {
    // Controller 响应事件，上传、更新数据、重新渲染页面
    // 省略部分逻辑
    try {
        console.log(newRecipe);
        // Show loading spinner
        addRecipeView.renderSpinner();

        // Upload new recipe data
        await model.uploadRecipe(newRecipe);
        console.log(model.state.recipe);

        // Render recipe
        recipeView.render(model.state.recipe);

        // Succes message
        addRecipeView.renderMessage();

        // Render bookmarksView
        bookmarksView.render(model.state.bookmarks);

        ...

    } catch (err) {
        console.error(err);
        addRecipeView.renderError(err.message);
    }
};


const init = function () {

    ...

    addRecipeView.addHandlerUpload(controlAddRecipe);
};

init();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Model 部分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// model.js

export const uploadRecipe = async function (newRecipe) {
    ...
    // 上传菜谱的逻辑
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;责任链模式&lt;/h2&gt;
&lt;p&gt;责任链模式（Chain of Responsibility）是一种处理请求的模式。它使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。&lt;/p&gt;
</content:encoded></item><item><title>HIT-软件构造 | Lab1 项目配置</title><link>https://blog.vonbrank.com/posts/hit-software-construction-lab1-config/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/hit-software-construction-lab1-config/</guid><description>HIT 软件构造课程实验 Lab1 项目配置说明</description><pubDate>Fri, 29 Apr 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;{% note warning flat %}
⚠️ 警告：&lt;/p&gt;
&lt;p&gt;本文所述内容仅能帮助你在 JetBrains IDEA 下以不修改代码框架中任何 &lt;code&gt;package&lt;/code&gt; 命名的方式，优雅地完成实验内容，但注意到 &lt;code&gt;实验指导-Lab0-3.3.4&lt;/code&gt; 中所述：&lt;/p&gt;
&lt;p&gt;{% note warning no-icon %}
在提交至 GitHub 仓库前，请将实验代码从 Eclipse / IDEA 环境脱离开来，建议你自行使用 JDK、Ant (http://ant.apache.org)、Maven (http://maven.apache.org)、Gradle (https://gradle.org)等工具进行 build，或者在提交至 GitHub 仓库之后使用 Travis-CI (https://travis-ci.org)进行在线 build。如果因为缺少某些库文件导致你的程序无法运行，TA 不再为其评分。
{% endnote %}&lt;/p&gt;
&lt;p&gt;这意味着完成实验后需要将基于 Eclipse / IDEA 的项目转换成某一通用的构建系统描述的项目，以应对 TA 可能采取的自动编译评测方式。
{% endnote %}&lt;/p&gt;
&lt;p&gt;{% note info flat %}
如果你已经熟悉 IDEA 的基本使用，本文后半部分会讲述如何将 IDEA 普通 Java 项目迁移至使用 Gradle 构建，可直接转跳阅读 &lt;a href=&quot;#%E8%BF%81%E7%A7%BB%E8%87%B3-Gradle-%E8%BF%9B%E8%A1%8C%E6%9E%84%E5%BB%BA&quot;&gt;➡️&lt;/a&gt;
{% endnote %}&lt;/p&gt;
&lt;p&gt;HIT-CS32123 软件构造课程 Lab1 项目结构大致如图：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.Lab1
├── src
│   ├── P1
│   │   ├── MagicSquare.java
│   │   └── txt
│   │       ├── 1.txt
│   │       ├── 2.txt
│   │       ├── 3.txt
│   │       ├── 4.txt
│   │       └── 5.txt
│   ├── P2
│   │   ├── .gitignore
│   │   ├── rules
│   │   │   ├── RulesOf6005.java
│   │   │   └── RulesOf6005Test.java
│   │   └── turtle
│   │       ├── Action.java
│   │       ├── DrawableTurtle.java
│   │       ├── LineSegment.java
│   │       ├── PenColor.java
│   │       ├── Point.java
│   │       ├── Turtle.java
│   │       ├── TurtleGUI.java
│   │       ├── TurtleSoup.java
│   │       └── TurtleSoupTest.java
│   └── P3
│       ├── FriendshipGraph.java
│       └── Person.java
└── test
    └── P3
        └── FriendshipGraphTest.java
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从拿到的框架可知 &lt;code&gt;P2&lt;/code&gt; 是一个 Eclipse 项目，而众所周知，JetBrains IDEA 比 Eclipse 好用&lt;s&gt;到不知道哪里去了&lt;/s&gt;。因此本文将介绍如何在 IDEA 中正确配置本次实验的项目结构。&lt;/p&gt;
&lt;h2&gt;先决条件&lt;/h2&gt;
&lt;p&gt;以下先决条件在此不再赘述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置 JDK （版本要求大于 $11$ ）&lt;/li&gt;
&lt;li&gt;下载并安装 JetBrains IDEA （本文使用的是旗舰版，社区版与旗舰版的配置过程只有细微差别）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;解决方案&lt;/h2&gt;
&lt;h3&gt;新建项目&lt;/h3&gt;
&lt;p&gt;只需要注意项目类型选 Java 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/cB9AU7XsZjOQJHL.jpg&quot; alt=&quot;图 1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;另外 JDK版本只需要大于课程要求的 $11$ 就行，其他的无所谓，因为稍后我们将通过 IDE 里的设置将代码所用特性限制在 Java 11 之前。&lt;/p&gt;
&lt;h3&gt;配置 &lt;code&gt;P1&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;刚建好的项目如图所示，可以看见 &lt;code&gt;src&lt;/code&gt; 下面什么都没有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/PtibhEpIF3GHcsR.jpg&quot; alt=&quot;图 2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我们将下载到的代码框架的 &lt;code&gt;P1&lt;/code&gt; 与 &lt;code&gt;P2&lt;/code&gt; 文件夹直接复制到 &lt;code&gt;src&lt;/code&gt; 下，此处你可以直接用文件资源管理器进行该操作。注意，不建议把 &lt;code&gt;Spring2022_HITCS_SC_Lab1&lt;/code&gt; 这个项目 &lt;code&gt;clone&lt;/code&gt; 下来，尤其不建议直接 &lt;code&gt;clone&lt;/code&gt; 到 &lt;code&gt;src&lt;/code&gt; 里，而只需要下载就可以。完成后如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/3PX7R1EM2Ohgwz9.jpg&quot; alt=&quot;图 3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以发现此时 IDEA 将 &lt;code&gt;P1&lt;/code&gt; 和 &lt;code&gt;P2&lt;/code&gt; 识别为 Java 包，但这是不对的，因为从 &lt;code&gt;P2&lt;/code&gt; 的 &lt;code&gt;RulesOf6005.java&lt;/code&gt; 看， &lt;code&gt;P1&lt;/code&gt;， &lt;code&gt;P2&lt;/code&gt; 包括之后的 &lt;code&gt;P3&lt;/code&gt; 更像是可以独立编译运行的 Java 项目。 &lt;code&gt;rules&lt;/code&gt; 应该是以 &lt;code&gt;P2&lt;/code&gt; 作为顶层目录下的一个 &lt;code&gt;package&lt;/code&gt; 而不是像现在这样 IDE 认为它应该被修改为包 &lt;code&gt;P2.rules&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/24BNHvY1dGan5D9.jpg&quot; alt=&quot;图 4&quot; /&gt;&lt;/p&gt;
&lt;p&gt;为了解决这个问题，按下 &lt;code&gt;Ctrl+Shift+Alt+S&lt;/code&gt; 来打开 &lt;code&gt;Project Structure&lt;/code&gt; ，这是 IDEA 项目中一个非常重要的面板，你可以在这里利用 IDE 管理你的项目，比如你可以在左侧的 &lt;code&gt;Project&lt;/code&gt; 里设置这个项目的语言等级（language level），比 JDK 版本（演示机上设置的是JDK 17）低的任何等级都可以被设置，在本次实验中我们允许使用 Java 8 - 11。但现在我们选择左侧的 &lt;code&gt;Module&lt;/code&gt; ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/WMbXRrYCE4LVeKn.jpg&quot; alt=&quot;图 5&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在继续之前，我们先引入 IDEA 中 Module 的概念，它不是从 Java 9 开始支持的那个 Java 中的 Module ，但有几分相似，事实上 IDEA 中一个项目被称为 Project ， Project 下允许构建可以独立运行的子组件，并设置其间的依赖关系，称为 Module 。IDEA 还有许多概念与 Eclipse 中的一些概念存在对应关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/DVTwH94nQ8o2aOd.jpg&quot; alt=&quot;图 6&quot; /&gt;&lt;/p&gt;
&lt;p&gt;理解上述概念后，我们知道，解决上述问题的一个方法是：实验所需要的 &lt;code&gt;P1&lt;/code&gt; 、 &lt;code&gt;P2&lt;/code&gt; 和 &lt;code&gt;P3&lt;/code&gt; 在 IDEA 中应该以 Module 的形式存在。接下来我们将为 &lt;code&gt;P1&lt;/code&gt; 和 &lt;code&gt;P2&lt;/code&gt; 创建 Module。&lt;/p&gt;
&lt;p&gt;点击上方的 &lt;code&gt;+&lt;/code&gt; 号，选择 &lt;code&gt;New Module&lt;/code&gt; ，和创建项目的窗口非常类似，我们再次选择 Java ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/7AxonZqwVIJ4QWu.jpg&quot; alt=&quot;图 7&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/j6EwG5IrxhCyWzS.jpg&quot; alt=&quot;图 8&quot; /&gt;&lt;/p&gt;
&lt;p&gt;而路径则需要选择这个项目下的 &lt;code&gt;src/P1&lt;/code&gt; ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/inkNqPoBpWlgVYT.jpg&quot; alt=&quot;图 9&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/97HlIATQSMzXbxh.jpg&quot; alt=&quot;图 10&quot; /&gt;&lt;/p&gt;
&lt;p&gt;此处表明一个 Module 确实像是一个新的 IDEA Java 项目，它为我们开发 Java 程序提供了一个独立的空间。&lt;/p&gt;
&lt;p&gt;完成之后点击 &lt;code&gt;OK&lt;/code&gt; 便回到了我们的 &lt;code&gt;Project Structure&lt;/code&gt; 面板，在点击 &lt;code&gt;OK&lt;/code&gt; 完成创建 &lt;code&gt;P1&lt;/code&gt; 模块之前，先点击上方的 &lt;code&gt;Sources&lt;/code&gt; 来到下面这个面板：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/6NUhdOGfCJLp7wk.jpg&quot; alt=&quot;图 11&quot; /&gt;&lt;/p&gt;
&lt;p&gt;根据实验要求，我们 &lt;code&gt;MagicSquare.java&lt;/code&gt; 应处于 &lt;code&gt;P1&lt;/code&gt; 的根目录而不是 &lt;code&gt;P1&lt;/code&gt; 的 &lt;code&gt;src&lt;/code&gt; 子目录下，因此需要选择 &lt;code&gt;src&lt;/code&gt; ，然后将上方的 &lt;code&gt;Sources&lt;/code&gt; 按钮取消选中，之后你甚至可以直接删除 &lt;code&gt;P1&lt;/code&gt; 下的这一个 &lt;code&gt;src&lt;/code&gt; 文件夹；最后选择 &lt;code&gt;P1&lt;/code&gt; 根目录本身，选中 &lt;code&gt;Sources&lt;/code&gt; 将其作为 &lt;code&gt;P1&lt;/code&gt; 模块的 &lt;code&gt;Sources Root&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/BKtqpWRDgnymTYH.jpg&quot; alt=&quot;图 12&quot; /&gt;&lt;/p&gt;
&lt;p&gt;点击 &lt;code&gt;OK&lt;/code&gt; 后我们便完成了 &lt;code&gt;P1&lt;/code&gt; 模块的创建。可以看见 &lt;code&gt;P1&lt;/code&gt; 的图标发生了明显变化，它现在不再是一个 &lt;code&gt;package&lt;/code&gt; 而是一个可以独立编译运行的 &lt;code&gt;Module&lt;/code&gt; ！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/zICaW5eltSTipoA.jpg&quot; alt=&quot;图 13&quot; /&gt;&lt;/p&gt;
&lt;p&gt;另外根据实验指导，我们需要在 &lt;code&gt;P1&lt;/code&gt; 下创建一个 &lt;code&gt;txt&lt;/code&gt; 子目录来存放所有 &lt;code&gt;1.txt&lt;/code&gt; 到 &lt;code&gt;5.txt&lt;/code&gt; ，注意在一个 &lt;code&gt;Source Root&lt;/code&gt; 下，创建一个 &lt;code&gt;package&lt;/code&gt; 等同于创建一个文件夹，所以我们可以通过在 &lt;code&gt;P1&lt;/code&gt; 下创建一个名为 &lt;code&gt;txt&lt;/code&gt; 的包来创建 &lt;code&gt;txt&lt;/code&gt; 这个目录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/P4VODcGeQTlRoAX.jpg&quot; alt=&quot;图 14&quot; /&gt;&lt;/p&gt;
&lt;p&gt;至此我们完成了 &lt;code&gt;P1&lt;/code&gt; 模块的创建，你甚至可以写一个 &lt;code&gt;Hello World!&lt;/code&gt; 程序来测试一下。&lt;/p&gt;
&lt;h3&gt;配置 &lt;code&gt;P2&lt;/code&gt; | &lt;code&gt;JUnit&lt;/code&gt; 配置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;P2&lt;/code&gt; 与 &lt;code&gt;P1&lt;/code&gt; 的不同之处在于它提供了一个代码框架，同时它还依赖于 &lt;code&gt;JUnit&lt;/code&gt; 。 &lt;code&gt;P2&lt;/code&gt; 配置的前半部分与 &lt;code&gt;P1&lt;/code&gt; 完全相同，为了检验是否理解了 IDEA Module 的概念，作为练习，请读者自行为 &lt;code&gt;P2&lt;/code&gt; 创建 Module 。完成后结果如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/5KvwpqnWyMtEOPI.jpg&quot; alt=&quot;图 15&quot; /&gt;&lt;/p&gt;
&lt;p&gt;但是注意到此时项目还是有警告的，因为我们还没有配置 &lt;code&gt;JUnit&lt;/code&gt; ，事实上这并不是一种良好的项目结构，测试类通常不应该与源码在同一模块下。但是在 IDEA 下完成 &lt;code&gt;JUnit&lt;/code&gt; 配置十分容易，我们只需要打开 &lt;code&gt;RulesOf6005Test.java&lt;/code&gt; ，将鼠标悬停在有红线的 &lt;code&gt;junit&lt;/code&gt; 上，出现的提示中选择 &lt;code&gt;Add &apos;JUnit&apos; to classpath&lt;/code&gt; ，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/jyh9UTCf3RklB1p.jpg&quot; alt=&quot;图 16&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在弹出的窗口中选 &lt;code&gt;OK&lt;/code&gt; ，IDEA 将自动为我们下载 &lt;code&gt;JUnit&lt;/code&gt; 包，然后将其添加到 &lt;code&gt;P2&lt;/code&gt; 模块的依赖项中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/vhwAia1uW8FojKt.jpg&quot; alt=&quot;图 17&quot; /&gt;&lt;/p&gt;
&lt;p&gt;稍等片刻，所有警告都会消失， &lt;code&gt;Project Structure&lt;/code&gt; 的 &lt;code&gt;Dependencis&lt;/code&gt; 面板也显示 &lt;code&gt;JUnit&lt;/code&gt; 确实被添加到了 &lt;code&gt;P2&lt;/code&gt; 的依赖项列表里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/J6Bguqv7TPxyMk3.jpg&quot; alt=&quot;图 18&quot; /&gt;&lt;/p&gt;
&lt;p&gt;点击 &lt;code&gt;RulesOf6005Test&lt;/code&gt; 里 &lt;code&gt;testMayUseCodeInAssignment&lt;/code&gt; 右侧的小三角形，然后 &lt;code&gt;Run&lt;/code&gt; 之，可以运行这一项单元测试。虽然出错了，但是可以看见 &lt;code&gt;testMayUseCodeInAssignment&lt;/code&gt; 是可以运行的，只是 &lt;code&gt;RulesOf6005.mayUseCodeInAssignment&lt;/code&gt; 还没有实现而已，所以报错，但这表明我们的对 &lt;code&gt;P2&lt;/code&gt; 的配置已经完成了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/29/lQTgUkAsGC5i9D7.jpg&quot; alt=&quot;图 19&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;配置 &lt;code&gt;P3&lt;/code&gt; | 模块间的依赖关系&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;P3&lt;/code&gt; 是一个面向对象编程的练习，也是一个体验单元测试流程的练习。我们先来回顾一下实验指导要求的目录结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.Lab1
├── src
│   └── P3
│       ├── FriendshipGraph.java
│       └── Person.java
└── test
    └── P3
        └── FriendshipGraphTest.java
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和 &lt;code&gt;P1&lt;/code&gt; &lt;code&gt;P2&lt;/code&gt; 一样，我们将 &lt;code&gt;P3&lt;/code&gt; 和 &lt;code&gt;test&lt;/code&gt; 里的 &lt;code&gt;P3&lt;/code&gt; 都视作模块，唯一不同的是，&lt;code&gt;test&lt;/code&gt; 里的 &lt;code&gt;P3&lt;/code&gt; 是专门用来测试 &lt;code&gt;src&lt;/code&gt; 里的 &lt;code&gt;P3&lt;/code&gt; 的模块，因此虽然它的目录是 &lt;code&gt;test/P3&lt;/code&gt; 但是个人认为给模块命名时称之为 &lt;code&gt;P3Test&lt;/code&gt; 比较好，像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/05/02/AxhHKOpvRefNULu.jpg&quot; alt=&quot;图 1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其他步骤不再赘述，最终效果如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/05/02/oGWghVRDmX3OJEn.jpg&quot; alt=&quot;图 2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/05/02/roS25dpqKei4NYh.jpg&quot; alt=&quot;图 3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;按照实验要求，我们需要先在 &lt;code&gt;P3&lt;/code&gt; 中实现 &lt;code&gt;FriendshipGraph&lt;/code&gt; 和 &lt;code&gt;Person&lt;/code&gt; 类的功能，然后在 &lt;code&gt;src/P3&lt;/code&gt; （ &lt;code&gt;P3Test&lt;/code&gt; 与此意思相同，后文将不再区分）的 &lt;code&gt;FriendshipGraphTest&lt;/code&gt; 类中对其进行测试。&lt;/p&gt;
&lt;p&gt;为了演示这点而不违反 &lt;code&gt;Collaboration policy&lt;/code&gt; ，本文将在 &lt;code&gt;P3&lt;/code&gt; 创建 &lt;code&gt;FriendshipGraph&lt;/code&gt; 类并在里面创建一个 &lt;code&gt;public static int getInt(int x)&lt;/code&gt; 方法，这个方法传入一个 &lt;code&gt;int&lt;/code&gt; 并返回这个 &lt;code&gt;int&lt;/code&gt; 本身，非常无聊，但有助于演示；然后在 &lt;code&gt;P3Test&lt;/code&gt; 中创建一个 &lt;code&gt;FriendshipGraphTest&lt;/code&gt; 类，其中的 &lt;code&gt;public void friendshipGraphGetIntTest()&lt;/code&gt; 方法用于测试 &lt;code&gt;FriendshipGraph.getInt&lt;/code&gt; 方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/05/02/G1nElSIMYpxgbcf.jpg&quot; alt=&quot;图 4&quot; /&gt;&lt;/p&gt;
&lt;p&gt;此处是本节的重点，形如 &lt;code&gt;assertEquals(0, FriendshipGraph.getInt(1))&lt;/code&gt; 便可以用于测试。因为在 &lt;code&gt;FriendshipGraphTest&lt;/code&gt; 类的 &lt;code&gt;friendshipGraphGetIntTest&lt;/code&gt; 方法中，我们既使用了 &lt;code&gt;JUnit&lt;/code&gt; 库的方法 &lt;code&gt;assertEquals&lt;/code&gt; ，又使用了 &lt;code&gt;FriendshipGraph&lt;/code&gt; 中的方法，所以我们称 “&lt;code&gt;FriendshipGraphTest&lt;/code&gt; &lt;strong&gt;依赖于&lt;/strong&gt; &lt;code&gt;JUnit&lt;/code&gt; 和 &lt;code&gt;FriendshipGraph&lt;/code&gt;” ；因为 &lt;code&gt;FriendshipGraphTest&lt;/code&gt; 在 &lt;code&gt;P3Test&lt;/code&gt; 模块中， &lt;code&gt;FriendshipGraph&lt;/code&gt; 在 &lt;code&gt;P3&lt;/code&gt; 模块中，所以同理，我们称 “&lt;code&gt;P3Test&lt;/code&gt; 模块依赖于 &lt;code&gt;P3&lt;/code&gt; 模块” 。&lt;/p&gt;
&lt;p&gt;按照 &lt;code&gt;P2&lt;/code&gt; 介绍的方式，我们可以很容易地为 &lt;code&gt;P3Test&lt;/code&gt; 引入 &lt;code&gt;JUnit&lt;/code&gt; 单元测试库，在此作为练习，效果如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/05/02/LIghpkaoAtFO2sE.jpg&quot; alt=&quot;图 5&quot; /&gt;&lt;/p&gt;
&lt;p&gt;此时 &lt;code&gt;JUnit&lt;/code&gt; 可以正常使用，但是 &lt;code&gt;FriendshipGraph&lt;/code&gt; 标红表示此处不可用，因为我们还没有设置 &lt;code&gt;P3Test&lt;/code&gt; 依赖于 &lt;code&gt;P3&lt;/code&gt; 。可以看见一旦我们将鼠标悬在 &lt;code&gt;FriendshipGraph&lt;/code&gt; 上方，智能的 IDEA 就会建议我们将 &lt;code&gt;P3&lt;/code&gt; 添加为依赖项。IDEA 给出这个正确的建议的原因之一是当前项目里只有 &lt;code&gt;P3&lt;/code&gt; 里有 &lt;code&gt;FriendshipGraph&lt;/code&gt; 类，具有特殊性，所以我们还是来看一下如何将一个模块设置为另一个模块的依赖项。&lt;/p&gt;
&lt;p&gt;首先还是打开 &lt;code&gt;Project Structure&lt;/code&gt; ，然后 选择 &lt;code&gt;P3Test&lt;/code&gt; 模块，打开 &lt;code&gt;Dependencies&lt;/code&gt; 面板，点击 &lt;code&gt;+&lt;/code&gt; 号，选择 &lt;code&gt;Module Dependency&lt;/code&gt; ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/05/02/OEk6qDGtNi9uKUw.jpg&quot; alt=&quot;图 6&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在弹出的窗口中选择 &lt;code&gt;P3&lt;/code&gt; ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/05/02/RFKVWMtrjw6UzqT.jpg&quot; alt=&quot;图 7&quot; /&gt;&lt;/p&gt;
&lt;p&gt;点击 &lt;code&gt;OK&lt;/code&gt; ，可以看见我们成功将 &lt;code&gt;P3&lt;/code&gt; 模块添加到 &lt;code&gt;P3Test&lt;/code&gt; 的依赖项列表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/05/02/ANRvOki4VodfaYq.jpg&quot; alt=&quot;图 8&quot; /&gt;&lt;/p&gt;
&lt;p&gt;到此为止，我们已经完成了本次实验在 IDEA 中的全部配置。运行一下 &lt;code&gt;FriendshipGraphTest&lt;/code&gt; 中的单元测试发现可以正确运行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/05/02/PhwRl6eSqTIB3EQ.jpg&quot; alt=&quot;图 9&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;后续步骤&lt;/h2&gt;
&lt;h3&gt;迁移至 &lt;code&gt;Gradle&lt;/code&gt; 进行构建&lt;/h3&gt;
&lt;p&gt;正如前文所述，如果 TA 使用自动化测试，那么提交的项目应该与 IDE 无关。此处我们推荐使用 Gradle 管理项目。过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将下列依赖项放至项目根目录下 &lt;code&gt;lib&lt;/code&gt; 文件夹内：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;junit-4.13.1.jar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hamcrest-core-1.31.jar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hamcrest-core-1.3-sources.jar&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在项目根目录下新建 &lt;code&gt;settings.gradle.kts&lt;/code&gt; ，填写内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rootProject.name = &quot;项目名&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在项目根目录下新建 &lt;code&gt;build.gradle.kts&lt;/code&gt; ，详细配置请参考奆佬 Nullptr 的 &lt;a href=&quot;https://nullptr.icu/index.php/archives/65/&quot;&gt;[软构] 记一次 Gradle 的坑&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接着点击 &lt;code&gt;Link Gradle project&lt;/code&gt; ，等待 IDEA 完成 Gradle 项目初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完成这一切后你可能发现 &lt;code&gt;Project Structure&lt;/code&gt; 中 &lt;code&gt;P1&lt;/code&gt; 等模块被重复了两次，这是因为 &lt;code&gt;Gradle&lt;/code&gt; 将这些模块视作 &lt;code&gt;Resource&lt;/code&gt; 并创建在根模块下。你可以删掉其中不在项目根模块中的那一个，因为它们原本是由 IDEA 管理的，现在不需要了。&lt;/p&gt;
</content:encoded></item><item><title>【阅读笔记】深入理解计算机系统</title><link>https://blog.vonbrank.com/posts/book-note-csapp/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/book-note-csapp/</guid><description>This book (CS:APP3e) is the third edition of a book that stems from the introductory computer systems course we developed at Carnegie Mellon University, starting in the Fall of 1998, called &quot;Introduction to Computer Systems&quot; (ICS).</description><pubDate>Wed, 12 Jan 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;计算机系统漫游&lt;/h2&gt;
&lt;h2&gt;信息的处理及表示&lt;/h2&gt;
&lt;h3&gt;2.1 信息存储&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习 2.2&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$n$&lt;/th&gt;
&lt;th&gt;$2^n$ （十进制）&lt;/th&gt;
&lt;th&gt;$2^n$ （十六进制）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;512&lt;/td&gt;
&lt;td&gt;0x200&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;524288&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0x80000&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;14&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;16384&lt;/td&gt;
&lt;td&gt;0x4000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;s&gt;&lt;strong&gt;17&lt;/strong&gt;&lt;/s&gt; &lt;strong&gt;16&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;s&gt;&lt;strong&gt;131072&lt;/strong&gt;&lt;/s&gt; &lt;strong&gt;65536&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0x10000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;131072&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;s&gt;&lt;strong&gt;0x10000&lt;/strong&gt;&lt;/s&gt; &lt;strong&gt;0x20000&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0x10&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;11&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;2048&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0x800&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习 2.3&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;十进制&lt;/th&gt;
&lt;th&gt;二进制&lt;/th&gt;
&lt;th&gt;十六进制&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0000 0000&lt;/td&gt;
&lt;td&gt;0x00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;167&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1010 0111&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0xA7&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;62&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0100 0011&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0x43&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;188&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1011 1100&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0xBC&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;55&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0011 0111&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0x37&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1000 1000&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1111 0011&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;s&gt;&lt;strong&gt;52&lt;/strong&gt;&lt;/s&gt; &lt;strong&gt;5 $\times$ 16 $+$ 2 $=$ 82&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0101 0010&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0x52&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0xAC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0xE7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习 2.4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;十六进制加减法，不得使用进制转换。&lt;/p&gt;
&lt;p&gt;A. &lt;code&gt;0x503c + 0x8 = 0x5044&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B. &lt;s&gt;&lt;code&gt;0x503c - 0x40 = 0x499c&lt;/code&gt;&lt;/s&gt; &lt;code&gt;0x503c - 0x40 = 0x4ffc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;C. &lt;code&gt;0x503c + 64 = 0x507c&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;D. &lt;s&gt;&lt;code&gt;0x50ea - 0x503c = 0xAD&lt;/code&gt;&lt;/s&gt; &lt;code&gt;0x50ea - 0x503c = 0xAE&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;寻址和字节顺序&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.5&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int val = 0x87654321&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;小端法&lt;/th&gt;
&lt;th&gt;大端法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;&lt;code&gt;21&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;87&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;&lt;code&gt;21 43&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;87 65&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;&lt;code&gt;21 43 65&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;87 65 43&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;val&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;21 43 65 87&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;87 65 43 21&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.6&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0x00359141 = 0000 0000 0011 0101 1001 0001 0100 0001&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0x4A564504 = 0100 1010 0101 0110 0100 0101 0000 0100&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0   0   3   5   9   1   4   1
00000000001101011001000101000001
           *********************
  01001010010101100100010100000100
     4   A   5   6   4   5   0   4
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.7&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;abcdef&quot; -&amp;gt; (ASCII) 65 66 67 68 69 70
-&amp;gt;	(printf) 61 62 63 64 65 66
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.8&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;01101001&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;01010101&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;~a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;10010110&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;~b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;10101010&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a &amp;amp; b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;01000001&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;`a&lt;/td&gt;
&lt;td&gt;b`&lt;/td&gt;
&lt;td&gt;&lt;code&gt;01111101&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a ^ b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;00111100&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.10&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;步骤&lt;/th&gt;
&lt;th&gt;*x&lt;/th&gt;
&lt;th&gt;*y&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$a$&lt;/td&gt;
&lt;td&gt;$b$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$a$&lt;/td&gt;
&lt;td&gt;$a \oplus b$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$b$&lt;/td&gt;
&lt;td&gt;$a \oplus b$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$a$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.11&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. &lt;code&gt;first == last == k&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B. &lt;code&gt;inplace_swap(&amp;amp;a[k], &amp;amp;a[k]);&lt;/code&gt; 第一行等价于 &lt;code&gt;a[k] = a[k] ^ a[k];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;C. &lt;code&gt;void inplace_swap(int* x, int* y);&lt;/code&gt; 第一行加上 &lt;code&gt;if(*x == *y) return;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或 &lt;code&gt;line 4&lt;/code&gt; 改为 &lt;code&gt;first &amp;lt; last&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.12&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. &lt;code&gt;x &amp;amp; 0xFF&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B. &lt;code&gt;(~x &amp;amp; ~0xFF) | (x &amp;amp; 0xFF)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;C. &lt;code&gt;x | 0xFF&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.13&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int bis(int x, int m);	//x | m;
int bic(int x, int m);	//x &amp;amp; ~m;
                        //~x = 1 &amp;amp; ~m
int bool_or(int x, int y)
{
    int result = bis(x, y);
    return result;
}

int boo_xor(int x, int y)	//x xor y = x &amp;amp; ~y | ~x &amp;amp; y;
{
    int result = bis(bic(x, y), bic(y, x));
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.15&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int bool_equal(int x, int y)
{
    return ~((x &amp;amp; ~y) | (~x &amp;amp; y));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h4&gt;C 语言中的移位运算&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;左移：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x &amp;lt;&amp;lt; n&lt;/code&gt; 表示二进制位向左移动 $n$ 位，低位补 $0$ 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;右移：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑右移：&lt;code&gt;x &amp;gt;&amp;gt; n&lt;/code&gt; 表示二进制位向左移动 $n$ 位，高位补 $0$ 。&lt;/li&gt;
&lt;li&gt;算术右移：&lt;code&gt;x &amp;gt;&amp;gt; n&lt;/code&gt; 表示二进制位向左移动 $n$ 位，若 $x$ 最高位是 $0$ ，则高位补 $0$ ；若 $x$ 最高位是 $1$ ，则高位补 $1$ ；。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习 2.16&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;x&lt;/th&gt;
&lt;th&gt;x&lt;/th&gt;
&lt;th&gt;x&amp;lt;&amp;lt;3&lt;/th&gt;
&lt;th&gt;x&amp;lt;&amp;lt;3&lt;/th&gt;
&lt;th&gt;x&amp;gt;&amp;gt;2（逻辑）&lt;/th&gt;
&lt;th&gt;x&amp;gt;&amp;gt;2（逻辑）&lt;/th&gt;
&lt;th&gt;x&amp;gt;&amp;gt;2（算术）&lt;/th&gt;
&lt;th&gt;x&amp;gt;&amp;gt;2（算术）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;十六进制&lt;/td&gt;
&lt;td&gt;二进制&lt;/td&gt;
&lt;td&gt;二进制&lt;/td&gt;
&lt;td&gt;十六进制&lt;/td&gt;
&lt;td&gt;二进制&lt;/td&gt;
&lt;td&gt;十六进制&lt;/td&gt;
&lt;td&gt;二进制&lt;/td&gt;
&lt;td&gt;十六进制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xC3&lt;/td&gt;
&lt;td&gt;1100 0011&lt;/td&gt;
&lt;td&gt;0001 1000&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0011 0000&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1111 0000&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x75&lt;/td&gt;
&lt;td&gt;0111 0101&lt;/td&gt;
&lt;td&gt;1010 1000&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0001 1101&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;s&gt;1101 1101&lt;/s&gt;`` 0001 1101&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x87&lt;/td&gt;
&lt;td&gt;1000 0111&lt;/td&gt;
&lt;td&gt;0011 1000&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0010 0001&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1110 0001&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x66&lt;/td&gt;
&lt;td&gt;0110 0110&lt;/td&gt;
&lt;td&gt;0011 0000&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0001 1001&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0001 1001&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;h3&gt;2.2 整数表示&lt;/h3&gt;
&lt;h4&gt;无符号数编码&lt;/h4&gt;
&lt;p&gt;对向量 $\overrightarrow{x} = [x_{w-1}, x_{w-2}, \dots, x_0]$&lt;/p&gt;
&lt;p&gt;$$
\tag{2.1} B2U_w(\overrightarrow{x}) \doteq \displaystyle\sum_{i=0}^{w-1} x_i 2^i
$$&lt;/p&gt;
&lt;h4&gt;补码编码&lt;/h4&gt;
&lt;p&gt;对向量 $\overrightarrow{x} = [x_{w-1}, x_{w-2}, \dots, x_0]$&lt;/p&gt;
&lt;p&gt;$$
\tag{2.3} B2T_w( \overrightarrow{x} ) \doteq x_{w-1}2^{w-1} +  \displaystyle\sum_{i=0}^{w-2} x_i 2^i
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.17&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$\overrightarrow(x)$&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;$B2U_4(\overrightarrow{x}))$&lt;/th&gt;
&lt;th&gt;$B2T_4(\overrightarrow{x})$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;十六进制&lt;/td&gt;
&lt;td&gt;二进制&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xE&lt;/td&gt;
&lt;td&gt;$1110$&lt;/td&gt;
&lt;td&gt;$2^3 + 2^2 + 2^1 = 14$&lt;/td&gt;
&lt;td&gt;$-2^3 + 2^2 + 2^1 = -2$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x0&lt;/td&gt;
&lt;td&gt;$0000$&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;$0$&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;$0$&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x5&lt;/td&gt;
&lt;td&gt;$0101$&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;$4+1=5$&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$4+1=5$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x8&lt;/td&gt;
&lt;td&gt;$1000$&lt;/td&gt;
&lt;td&gt;$8$&lt;/td&gt;
&lt;td&gt;$-8$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xD&lt;/td&gt;
&lt;td&gt;$1101$&lt;/td&gt;
&lt;td&gt;$8 + 4 + 1 = 13$&lt;/td&gt;
&lt;td&gt;$-8 + 4 + 1 = -3$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xF&lt;/td&gt;
&lt;td&gt;$1111$&lt;/td&gt;
&lt;td&gt;$8 + 4 + 2 + 1 = 15$&lt;/td&gt;
&lt;td&gt;$-8 + 4 + 2 + 1 = -1$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.18&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;十六进制&lt;/th&gt;
&lt;th&gt;二进制&lt;/th&gt;
&lt;th&gt;补码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x2e0&lt;/td&gt;
&lt;td&gt;$0000\ 0010\ 1110\ 0000$&lt;/td&gt;
&lt;td&gt;&lt;s&gt;$2^{10} + 2^8 + 2^7 + 2^6&lt;/s&gt;&amp;lt;br&amp;gt;$2^{9} + 2^7 + 2^6 + 2^5 = 736$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-0x58&lt;/td&gt;
&lt;td&gt;$0000\ 0000\ 0101\ 1000$&lt;/td&gt;
&lt;td&gt;&lt;s&gt;2^7 + 2^5 + 2^4&lt;/s&gt;&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;$-(2^6 + 2^4 + 2^3) = -40$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x28&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x30&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x78&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x88&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x1f8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xc0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x48&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;h4&gt;有符号数与无符号数之间的转换&lt;/h4&gt;
&lt;p&gt;$$
T2U_w(x) \doteq B2U_w(T2B_w(x))
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.19&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$x$&lt;/th&gt;
&lt;th&gt;$T2U_4(x)$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$-8$&lt;/td&gt;
&lt;td&gt;$8$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$-3$&lt;/td&gt;
&lt;td&gt;$13$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$-2$&lt;/td&gt;
&lt;td&gt;$14$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$-1$&lt;/td&gt;
&lt;td&gt;$15$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$0$&lt;/td&gt;
&lt;td&gt;$0$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$5$&lt;/td&gt;
&lt;td&gt;$5$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;p&gt;$\forall x, TMin_w \le x \le TMax_w$&lt;/p&gt;
&lt;p&gt;$$
\tag{2.5} T2U_w(x) = \begin{cases}
x + 2^w &amp;amp;\text{if } x &amp;lt; 0 \
x &amp;amp;\text{if } x \ge 0
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;$\forall u, 0 \le u \le UMax_w$&lt;/p&gt;
&lt;p&gt;$$
\tag{2.7} U2T_w(x) = \begin{cases}
u - 2^w &amp;amp;\text{if } u &amp;gt; UMax_w \
u &amp;amp;\text{if } u \le UMax_w
\end{cases}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.21&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;求值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-2147483647-1 == 2147483648U&amp;lt;br&amp;gt;``0x8000 == 0x8000&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无符号&lt;/td&gt;
&lt;td&gt;&lt;s&gt;&lt;code&gt;0&lt;/code&gt;&lt;/s&gt; &lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;有符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;无符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;有符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;无符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;h4&gt;扩展一个数字的位表示&lt;/h4&gt;
&lt;p&gt;无符号数转换为一个更大的数据类型：零扩展&lt;/p&gt;
&lt;p&gt;补码数数转换为一个更大的数据类型：高位使用 $x_{w-1}$ 填充&lt;/p&gt;
&lt;p&gt;证明（数学归纳法）：&lt;/p&gt;
&lt;p&gt;$$
B2T_{w+1}([x_{w-1}, x_{w-1}, \dots, w_1, w_0]) = B2T_w([x_{w-1}, x_{w-2}, \dots, w_1, w_0])
$$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;short x = -12345;
unsigned y = x;	// -&amp;gt; y = (unsigned) (int) x;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.23&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;w&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;fun1(w)&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;fun2(w)&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0x00000076&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x00000076&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0X00000076&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0x87654321&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x00000021&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x00000021&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0x000000C9&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x000000C9&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0xFFFFFFC9&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xEDCBA987&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x00000087&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0xFFFFFF87&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fun1&lt;/code&gt; 实现将 32 位无符号 &lt;code&gt;int&lt;/code&gt; 转换为 8 位无符号 &lt;code&gt;int&lt;/code&gt; ，即无符号数对 $8$ 取模。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fun2&lt;/code&gt; 实现将 32 位有符号 &lt;code&gt;int&lt;/code&gt; 转换为 8 位有符号 &lt;code&gt;int&lt;/code&gt; ，有符号数的二进制表示取低 $8$ 位，然后进行有符号扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;截断数字&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无符号数截断：&lt;/p&gt;
&lt;p&gt;令向量 $\overrightarrow{x} = [x_{w-1}, x_{w-2}, \dots, x_0]$ ， $\overrightarrow{x}&apos; = [x_{k-1}, \dots, x_0]$ 是将 $\overrightarrow{x}$ 截断 $k$ 位的结果。令 $x = B2T_w(\overrightarrow{x})$ ， $x&apos; = B2T_k(\overrightarrow{x}&apos;)$ ，则 $x&apos; = x \ mod \  2^k$&lt;/p&gt;
&lt;p&gt;$$
\tag{2.9} B2T_k([x_{k-1}, x_{k-2}, \dots, x_0]) = B2U_w([x_{w-1}, x_{w-2}, \dots, x_0]) \ mod \ 2^k
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有符号数截断：&lt;/p&gt;
&lt;p&gt;$$
\tag{2.10} B2T_k([x_{k-1}, x_{k-2}, \dots, x_0]) = U2T_k(B2U_w([x_{w-1}, x_{w-2}, \dots, x_0]) \ mod \ 2^k)
$$&lt;/p&gt;
&lt;p&gt;其中， $B2U_w([x_{w-1}, x_{w-2}, \dots, x_0]) \ mod \ 2^k$ 先将有符号数转换成无符号数并用无符号方法截断，然后把无符号数转换成有符号数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.24&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;十六进制&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;二进制&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;无符号&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;补码&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;原始值&lt;/td&gt;
&lt;td&gt;截断值&lt;/td&gt;
&lt;td&gt;原始值&lt;/td&gt;
&lt;td&gt;截断值&lt;/td&gt;
&lt;td&gt;原始值&lt;/td&gt;
&lt;td&gt;截断值&lt;/td&gt;
&lt;td&gt;原始值&lt;/td&gt;
&lt;td&gt;截断值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0000&lt;/td&gt;
&lt;td&gt;000&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0010&lt;/td&gt;
&lt;td&gt;010&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1001&lt;/td&gt;
&lt;td&gt;001&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;-7&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1011&lt;/td&gt;
&lt;td&gt;011&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;-5&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;1111&lt;/td&gt;
&lt;td&gt;111&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;-1&lt;/td&gt;
&lt;td&gt;-1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;都先将二进制表示转换为无符号数，然后对 $2^k$ 取模截断，所得结果视作 $k$ 位有/无符号数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.25&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传入的 &lt;code&gt;length&lt;/code&gt; 为 $0$ 时，&lt;code&gt;length - 1&lt;/code&gt; 为无符号数，值为 &lt;code&gt;~0x0&lt;/code&gt; ，比较 &lt;code&gt;i&lt;/code&gt; 与 &lt;code&gt;length - 1&lt;/code&gt; 的大小时，&lt;code&gt;i&lt;/code&gt; 会被转换为无符号数将其比较，设 &lt;code&gt;length&lt;/code&gt; 是一个 &lt;code&gt;k&lt;/code&gt; 位无符号数，则 &lt;code&gt;i&lt;/code&gt; 若视作无符号数，表示范围为 $[0, 2^k - 1]$ 或 $[0, 2^32 - 1]$ ，总之 &lt;code&gt;a[i]&lt;/code&gt; 将出现越界访问，导致内存错误。&lt;/p&gt;
&lt;p&gt;解决方法是第 $4$ 行修改为 &lt;code&gt;for(int i=0; i &amp;lt;= (int)length - 1; i++)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习 2.26&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;s&lt;/code&gt; 比 &lt;code&gt;t&lt;/code&gt; 短时，结果不正确。&lt;/p&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;p&gt;在 A. 的条件下， &lt;code&gt;strlen(s) - strlen(t)&lt;/code&gt; 仍是一个无符号正整数 ，右边的 &lt;code&gt;0&lt;/code&gt; 将被视作无符号数，返回真。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int strLonger(char *s, char *t)
{
        return strlen(s) &amp;gt; strlen(t);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h3&gt;2.3 整数的运算&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习 2.27&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int uadd_ok(unsigned x, unsigned y)
{
        return x + y &amp;gt;= x;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.28&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$x$&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;$-_4^ux$&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;十六进制&lt;/td&gt;
&lt;td&gt;十进制&lt;/td&gt;
&lt;td&gt;十进制&lt;/td&gt;
&lt;td&gt;十六进制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;s&gt;16&lt;/s&gt; 0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;&lt;s&gt;13&lt;/s&gt; 3&lt;/td&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.29&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$x$&lt;/th&gt;
&lt;th&gt;$y$&lt;/th&gt;
&lt;th&gt;$x+y$&lt;/th&gt;
&lt;th&gt;$x + _t^5y$&lt;/th&gt;
&lt;th&gt;情况&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$[100101]$&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;$-27$&lt;/td&gt;
&lt;td&gt;$[00101]$&lt;/td&gt;
&lt;td&gt;情况&lt;s&gt;3&lt;/s&gt; 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$[110000]$&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;$-16$&lt;/td&gt;
&lt;td&gt;$[10000]$&lt;/td&gt;
&lt;td&gt;情况 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;s&gt;$[011111]$&lt;/s&gt; $[111111]$&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;&lt;s&gt;$31$&lt;/s&gt; $-1$&lt;/td&gt;
&lt;td&gt;$[11111]$&lt;/td&gt;
&lt;td&gt;情况&lt;s&gt;1&lt;/s&gt; 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$[000111]$&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;$7$&lt;/td&gt;
&lt;td&gt;$[00111]$&lt;/td&gt;
&lt;td&gt;情况 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$[010000]$&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;$16$&lt;/td&gt;
&lt;td&gt;$[10000]$&lt;/td&gt;
&lt;td&gt;情况 4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.30&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int tadd_ok(int x, int y)
{
    return !((x &amp;gt; 0 &amp;amp;&amp;amp; y &amp;gt; 0 &amp;amp;&amp;amp; x + y &amp;lt; 0) || (x &amp;lt; 0 &amp;amp;&amp;amp; y &amp;lt; 0 &amp;amp;&amp;amp; x + y &amp;gt; 0))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.31&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设发生正溢出，则 &lt;code&gt;sum = x + y - 2^k&lt;/code&gt; ， &lt;code&gt;sum - x = y - 2^k&lt;/code&gt; ，在模 $k$ 意义下就是 $y$ ，对 $x$ 同理，所以正溢出时仍然返回真；同理，负溢出也返回真。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.32&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用 &lt;code&gt;tadd_ok(int x, int y)&lt;/code&gt; 来判断 $x - y$ 是否溢出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int tsub_ok(int x, int y)
{
	return tadd_ok(x, -y);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种写法是在假设：对任意 $x - ^t_wy$ ，若 &lt;code&gt;tsub_ok(x, y)&lt;/code&gt; 判断没有溢出，即 $x + ^t_w(-y)$ 由 &lt;code&gt;tadd_ok(x, -y)&lt;/code&gt; 判断没有溢出，这要求 $-^t_wy = -y$ ，但其实不然。&lt;/p&gt;
&lt;p&gt;$y = TMin_w = -2^{w-1}$ 时， $-^t_wy = TMin_w = y$ ，若 $x &amp;lt; 0$ ，则 $x - y = x + 2^{w-1} \ge 0$ ，没有发生溢出，但是 $x + TMin_w = x - 2^{w-1} &amp;lt; 2^{w-1}$ ，将被 &lt;code&gt;tadd_ok()&lt;/code&gt; 判断为负溢出；若 $x &amp;gt; 0$ ， $x - y = x + 2^{w-1} &amp;gt; 2^{w-1} - 1$ ，发生正溢出，而 $x + TMin_w = x - 2^{w-1} &amp;gt; 2^{w-1}$ ，被 &lt;code&gt;tadd_ok()&lt;/code&gt; 判断为没有溢出。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int tsub_ok(int x, int y)
{
    if(y == -y) return x &amp;lt; 0;
	else return tadd_ok(x, -y);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.33&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$x$&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;$-^t_4x$&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;十六进制&lt;/td&gt;
&lt;td&gt;十进制&lt;/td&gt;
&lt;td&gt;十进制&lt;/td&gt;
&lt;td&gt;十六进制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;-5&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;s&gt;8&lt;/s&gt; -8&lt;/td&gt;
&lt;td&gt;&lt;s&gt;8&lt;/s&gt; -8&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;-3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;-1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;h4&gt;无符号乘法&lt;/h4&gt;
&lt;p&gt;对满足 $0 \le x,\ y \le UMax_w$ 的 $x$ 和 $y$ ：&lt;/p&gt;
&lt;p&gt;$$
\tag{2.16} x * ^u_wy = (x \cdot y)\ mod\ 2^w
$$&lt;/p&gt;
&lt;h4&gt;有符号乘法&lt;/h4&gt;
&lt;p&gt;对满足 $TMin_w \le x,\ y \le TMax_w$ 的 $x$ 和 $y$ ：&lt;/p&gt;
&lt;p&gt;$$
\tag{2.17} x * ^t_wy = U2T_w ((x \cdot y)\ mod\ 2^w )
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.34&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模式&lt;/th&gt;
&lt;th&gt;$x$&lt;/th&gt;
&lt;th&gt;$y$&lt;/th&gt;
&lt;th&gt;$x \cdot y$&lt;/th&gt;
&lt;th&gt;截断&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$[100]$&lt;/td&gt;
&lt;td&gt;$[101]$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无符号&lt;/td&gt;
&lt;td&gt;$4$&lt;/td&gt;
&lt;td&gt;$5$&lt;/td&gt;
&lt;td&gt;$20$&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;$[010100]$&lt;/td&gt;
&lt;td&gt;$[100]$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;有符号&lt;/td&gt;
&lt;td&gt;$-4$&lt;/td&gt;
&lt;td&gt;$-3$&lt;/td&gt;
&lt;td&gt;$12$&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;$[001100]$&lt;/td&gt;
&lt;td&gt;$[100]$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$[010]$&lt;/td&gt;
&lt;td&gt;$[111]$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;有符号&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;td&gt;$7$&lt;/td&gt;
&lt;td&gt;$14$&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;$[001110]$&lt;/td&gt;
&lt;td&gt;$[110]$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无符号&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;td&gt;$-1$&lt;/td&gt;
&lt;td&gt;$-2$&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;$111110$&lt;/td&gt;
&lt;td&gt;$[110]$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$[110]$&lt;/td&gt;
&lt;td&gt;$[110]$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;有符号&lt;/td&gt;
&lt;td&gt;$6$&lt;/td&gt;
&lt;td&gt;$6$&lt;/td&gt;
&lt;td&gt;$36$&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;$[100100]$&lt;/td&gt;
&lt;td&gt;$[100]$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无符号&lt;/td&gt;
&lt;td&gt;$-2$&lt;/td&gt;
&lt;td&gt;$-2$&lt;/td&gt;
&lt;td&gt;$4$&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;$[000100]$&lt;/td&gt;
&lt;td&gt;$[100]$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.35&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由有符号数乘法的定义，设 $z = x \cdot y$ ， $T2B_{w}(z\ mod\ 2^w) = [x_{w-1}, \dots , x_0]$ ，则 $p = (z\ mod\ 2^w) - x_{w-1} 2^{w}$ ，所以 $p + x_{w-1} 2^{w} = z\ mod\ 2^w$ ，即 $x \cdot y = z = k 2^w + p + x_{w-1}2^w = p + t2^w$ 。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;若计算溢出，则 $k \neq 0$ ，又 $x_{w-1} \in {0, 1}$ ，故 $t = k + x_{w-1} \neq 0$&lt;/p&gt;
&lt;p&gt;若 $t = k + w_{w-1} \neq 0$ ，由于 $k \ge 0$ ，且 $x_{w-1} \in {0, 1}$ ，有 $k \neq 0$ ，所以 $z \ge 2^w$ ，计算溢出。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;若 $p \le x$ ，则令 $q = 1$ ， $\exist\ r = x - p , \ s.t. p = xp + r$ .&lt;/p&gt;
&lt;p&gt;若 $p &amp;gt; x$ ，则令 $r = p\ mod\ x$ ， $\exist\ r = x - p , \ s.t. p = xp + r$ .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若 $q = y$ ，则由 $|r| &amp;lt; |x|$ ，且 $|x| &amp;lt; 2^w$ ，所以 $t = 0$ ，$p = x \cdot y$ ，$r = 0$ 。&lt;/p&gt;
&lt;p&gt;若 $r = t = 0$ ，则 $p = x \cdot y$ ，易得 $q = y$ 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综上，若没有溢出，则 $t = 0$ ，此时 $p = x \cdot y$ ，&lt;code&gt;!x || p / x == y&lt;/code&gt; 为真。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习 2.36&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int tmult_ok(int x, int y)
{
    int64_t p = x * y;
    return p == (int) p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习 2.37&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;使用 &lt;code&gt;uint64_t&lt;/code&gt; 保存 &lt;code&gt;ele_cnt * ele_size&lt;/code&gt; 的结果，防止溢出导致分配的空间过小，进而防止循环复制时超出缓冲区界限。&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;A. 这个改动没有帮助，因为 &lt;code&gt;malloc&lt;/code&gt; 只能接收 &lt;code&gt;int32_t&lt;/code&gt; 作为参数，仍然可能溢出。&lt;/p&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(asize != (unit32_t)asize) return NULL;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h4&gt;乘以常数&lt;/h4&gt;
&lt;p&gt;$$
x&amp;lt;&amp;lt;k = x \cdot 2^k
$$&lt;/p&gt;
&lt;p&gt;将 $K$ 分解为二进制序列 $[x_{w-1}, \dots, x_0]$ ，则有：&lt;/p&gt;
&lt;p&gt;$$
x \cdot K = x * \displaystyle\sum_{i=0}^{w-1}x_{i} \cdot 2^i = \displaystyle\sum_{i=0}^{w-1}x&amp;lt;&amp;lt;(x_i \cdot i)
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.38&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以计算 $a \cdot 2^k$ ， $a \cdot (2^k + 1)$ 等，即 $1, 2, 3, 4, 5, 8, 9$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.39&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$n$ 为最高位时， &lt;s&gt;&lt;code&gt;x&amp;lt;&amp;lt;(n + 1)&lt;/code&gt; = $x \cdot (2^{n + 1}) = x \cdot 2^{n} \cdot x$&lt;/s&gt; $n+1 = w-1+1 = w$ ， $x&amp;lt;&amp;lt;(n+1) = x&amp;lt;&amp;lt;w$ ，溢出截断后为 &lt;s&gt;$x$&lt;/s&gt; $0$ 本身。故改为 &lt;s&gt;&lt;code&gt;x - (x &amp;lt;&amp;lt; m)&lt;/code&gt;&lt;/s&gt; &lt;code&gt;- (x &amp;lt;&amp;lt; m)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.40&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$K$&lt;/th&gt;
&lt;th&gt;移位&lt;/th&gt;
&lt;th&gt;加法/减法&lt;/th&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(x&amp;lt;&amp;lt;3) - (x&amp;lt;&amp;lt;1)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(x&amp;lt;&amp;lt;5) - x&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt; (x&amp;lt;&amp;lt;1) - (x&amp;lt;&amp;lt;3)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(x&amp;lt;&amp;lt;6) - (x&amp;lt;&amp;lt;3) - x&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.41&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;视加减法、移位计算的开销决定，选择综合开销最小的那种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;除以 2 的幂&lt;/h4&gt;
&lt;p&gt;若 $x$ 是无符号数：&lt;/p&gt;
&lt;p&gt;$$
x&amp;gt;&amp;gt;k = \lfloor x / 2^k \rfloor
$$&lt;/p&gt;
&lt;p&gt;此处使用逻辑右移。&lt;/p&gt;
&lt;p&gt;若 $x$ 是有符号数且大于 $0$ ，操作与无符号数相同，但使用算术右移。&lt;/p&gt;
&lt;p&gt;若 $x$ 是有符号数且小于 $0$ ，除以 $2^k$ 时，要先加上偏置位 $2^k-1$，再算术右移：&lt;/p&gt;
&lt;p&gt;$$
(x+(1&amp;lt;&amp;lt;k)-1)&amp;gt;&amp;gt;k = \lceil x/2^k \rceil
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.42&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int div16(int x)
{
    return !(x &amp;amp; (1 &amp;lt;&amp;lt; 31)) * (x &amp;gt;&amp;gt; 4) + (x &amp;amp; (1 &amp;lt;&amp;lt; 31)) * ((x + (1 &amp;lt;&amp;lt; 4) - 1) &amp;gt;&amp;gt; 4);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.43&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x * M = x * (2^5 - 1)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;y = (y &amp;lt; 0 ? (y + (1 &amp;lt;&amp;lt; 3) - 1) : y) &amp;gt;&amp;gt; 3 = y / 3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以 &lt;code&gt;M = 31, N = 2^3 = 8&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习 2.44&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. 若 &lt;code&gt;x &amp;gt; 0 == true&lt;/code&gt; ，则为 &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;若 &lt;code&gt;x &amp;gt; 0 == false&lt;/code&gt; ，则 &lt;code&gt;x &amp;lt;= 0&lt;/code&gt; ，即 &lt;code&gt;((x - 1) &amp;lt; 0) == true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B. 若 &lt;code&gt;(x &amp;amp; 7) ==7&lt;/code&gt; ，则 &lt;code&gt;x&lt;/code&gt; 最低三位是 &lt;code&gt;111&lt;/code&gt; ，&lt;code&gt;x&lt;/code&gt; 是 $32$ 位 &lt;code&gt;int&lt;/code&gt; ，&lt;code&gt;x &amp;lt;&amp;lt; 29&lt;/code&gt; 的最高三位是 &lt;code&gt;111&lt;/code&gt; ，故其小于 $0$&lt;/p&gt;
&lt;p&gt;C. $x \cdot x$ 的最高位恒为 $0$ ，因此 &lt;code&gt;x * x &amp;gt;= 0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;D. 若 &lt;code&gt;x &amp;gt;= 0&lt;/code&gt; ，则根据有符号数的逆元定义，&lt;code&gt;-x &amp;lt;= 0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;E. 若 $x = TMin_w$ ，$-x = TMin_w &amp;lt; 0$ ，故为假&lt;/p&gt;
&lt;p&gt;F. $x = y = 2^{31} - 1$ 时，不成立&lt;/p&gt;
&lt;p&gt;G. $?$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;2.4 浮点数&lt;/h3&gt;
&lt;h4&gt;二进制小数&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.45&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;小数值&lt;/th&gt;
&lt;th&gt;二进制&lt;/th&gt;
&lt;th&gt;十进制&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\frac 1 8$&lt;/td&gt;
&lt;td&gt;$0.001$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\frac 3 4$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\frac {43} {16}$&lt;/td&gt;
&lt;td&gt;$10.1011$&lt;/td&gt;
&lt;td&gt;$2.6875$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$1.001$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\frac {63} 8$&lt;/td&gt;
&lt;td&gt;$101.111$&lt;/td&gt;
&lt;td&gt;$5.875$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$3.1875$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.46&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. 是 &lt;code&gt;0.000000000000000000000[0011]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B. $\frac 3 {15 \cdot 2^{21}}$&lt;/p&gt;
&lt;p&gt;C. $0.0171661377s$&lt;/p&gt;
&lt;p&gt;D. $34.3322753906m$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;浮点数的表示&lt;/h4&gt;
&lt;p&gt;$IEEE$ 用 $V = (-1)^s \times M \times 2^E$ 表示一个浮点数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$s$ 编码符号位， $0$ 为正， $1$ 为负。&lt;/li&gt;
&lt;li&gt;$k$ 位阶码，表示一个二进制整数 $e = e_{k-1} \dots e_0$ ，用来编码 $E$&lt;/li&gt;
&lt;li&gt;$n$ 位小数字段，表示一个二进制小数 $f = \overline{0.f_{n-1} \dots f_0}$ ，用来编码 $M$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;情况 1：规格化的值&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$e$ 的所有位不全为 $1$ 或 $0$&lt;/li&gt;
&lt;li&gt;$E = e - Bias$ ， 其中 $Bias = 2^{k-1} - 1$ ，使得双精度指数范围为 $-1022 \backsim 1023$ ，单精度为 $-126 \backsim 127$&lt;/li&gt;
&lt;li&gt;$M = 1+ f = \overline{1.f_{n-1} \dots f_0}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;情况 2：非规格化的值&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阶码字段 $e$ 所有位全为 $0$ ，即 $e = 0$&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;$E = 1 - Bias$&lt;/li&gt;
&lt;li&gt;$M = f = \overline{0.f_{n-1} \dots f_0}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$M = f = 0$ 时根据 $s$ 的取值决定表示 $+0.0$ 或 $-0.0$ ，二者有时候是不同的。&lt;/p&gt;
&lt;p&gt;$M = f \neq 0$ 时用来表示非常接近 $0$ 的数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况 3：特殊值&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阶码字段 $e$ 所有位全为 $1$&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;若 $f = 0$ ，表示 $+\infin$ 或 $-\infin$&lt;/li&gt;
&lt;li&gt;$f \neq 0$ 表示 $NaN$ （Not a number）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.47&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;位&lt;/th&gt;
&lt;th&gt;$e$&lt;/th&gt;
&lt;th&gt;$E$&lt;/th&gt;
&lt;th&gt;$2^E$&lt;/th&gt;
&lt;th&gt;$f$&lt;/th&gt;
&lt;th&gt;$M$&lt;/th&gt;
&lt;th&gt;$2^E \times M$&lt;/th&gt;
&lt;th&gt;$V$&lt;/th&gt;
&lt;th&gt;十进制&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0 00 00&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$0$&lt;/td&gt;
&lt;td&gt;$-1$&lt;/td&gt;
&lt;td&gt;$\frac 1 2$&lt;/td&gt;
&lt;td&gt;$\frac 0 4$&lt;/td&gt;
&lt;td&gt;$\frac 0 4$&lt;/td&gt;
&lt;td&gt;$\frac 0 8$&lt;/td&gt;
&lt;td&gt;$0$&lt;/td&gt;
&lt;td&gt;$0$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0 00 01&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$0$&lt;/td&gt;
&lt;td&gt;$-1$&lt;/td&gt;
&lt;td&gt;$\frac 1 2$&lt;/td&gt;
&lt;td&gt;$\frac 1 4$&lt;/td&gt;
&lt;td&gt;$\frac 1 4$&lt;/td&gt;
&lt;td&gt;$\frac 1 8$&lt;/td&gt;
&lt;td&gt;$\frac 1 8$&lt;/td&gt;
&lt;td&gt;$0.125$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0 00 10&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$0$&lt;/td&gt;
&lt;td&gt;$-1$&lt;/td&gt;
&lt;td&gt;$\frac 1 2$&lt;/td&gt;
&lt;td&gt;$\frac 2 4$&lt;/td&gt;
&lt;td&gt;$\frac 2 4$&lt;/td&gt;
&lt;td&gt;$\frac 2 8$&lt;/td&gt;
&lt;td&gt;$\frac 1 4$&lt;/td&gt;
&lt;td&gt;$0.25$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0 00 11&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$0$&lt;/td&gt;
&lt;td&gt;$-1$&lt;/td&gt;
&lt;td&gt;$\frac 1 2$&lt;/td&gt;
&lt;td&gt;$\frac 3 4$&lt;/td&gt;
&lt;td&gt;$\frac 3 4$&lt;/td&gt;
&lt;td&gt;$\frac 3 8$&lt;/td&gt;
&lt;td&gt;$\frac 3 8$&lt;/td&gt;
&lt;td&gt;$0.375$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0 01 00&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$0$&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$\frac 0 4$&lt;/td&gt;
&lt;td&gt;$\frac 4 4$&lt;/td&gt;
&lt;td&gt;$\frac 4 4$&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0 01 01&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$0$&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$\frac 1 4$&lt;/td&gt;
&lt;td&gt;$\frac 5 4$&lt;/td&gt;
&lt;td&gt;$\frac 5 4$&lt;/td&gt;
&lt;td&gt;$\frac 5 4$&lt;/td&gt;
&lt;td&gt;$1.25$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0 01 10&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$0$&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$\frac 2 4$&lt;/td&gt;
&lt;td&gt;$\frac 6 4$&lt;/td&gt;
&lt;td&gt;$\frac 6 4$&lt;/td&gt;
&lt;td&gt;$\frac 3 2$&lt;/td&gt;
&lt;td&gt;$1.5$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0 01 11&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$0$&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$\frac 3 4$&lt;/td&gt;
&lt;td&gt;$\frac 7 4$&lt;/td&gt;
&lt;td&gt;$\frac 7 4$&lt;/td&gt;
&lt;td&gt;$\frac 7 4$&lt;/td&gt;
&lt;td&gt;$1.75$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0 10 00&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;td&gt;$\frac 0 4$&lt;/td&gt;
&lt;td&gt;$\frac 4 4$&lt;/td&gt;
&lt;td&gt;$\frac 8 2$&lt;/td&gt;
&lt;td&gt;$4$&lt;/td&gt;
&lt;td&gt;$4$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0 10 01&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;td&gt;$\frac 1 4$&lt;/td&gt;
&lt;td&gt;$\frac 5 4$&lt;/td&gt;
&lt;td&gt;$\frac {10} 2$&lt;/td&gt;
&lt;td&gt;$5$&lt;/td&gt;
&lt;td&gt;$5$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0 10 10&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;td&gt;$\frac 2 4$&lt;/td&gt;
&lt;td&gt;$\frac 6 4$&lt;/td&gt;
&lt;td&gt;$\frac {12} 2$&lt;/td&gt;
&lt;td&gt;$6$&lt;/td&gt;
&lt;td&gt;$6$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0 10 11&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;td&gt;$\frac 3 4$&lt;/td&gt;
&lt;td&gt;$\frac 7 4$&lt;/td&gt;
&lt;td&gt;$\frac {14} 2$&lt;/td&gt;
&lt;td&gt;$7$&lt;/td&gt;
&lt;td&gt;$7$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0 11 00&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0 11 01&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0 11 10&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0 11 11&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;td&gt;$-$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.49&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. $2^{n+1} + 1$&lt;/p&gt;
&lt;p&gt;B. $2^{24} + 1$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;舍入&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.50&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. $10.0_2$&lt;/p&gt;
&lt;p&gt;B. &lt;s&gt;$10.0_2$&lt;/s&gt; $10.1_2$&lt;/p&gt;
&lt;p&gt;C. &lt;s&gt;$11.00_2$&lt;/s&gt; $11.0_2$&lt;/p&gt;
&lt;p&gt;D. $11.0_2$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.51&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. $0.00011001100110011001100[1100]_2$ 精确到小数点右边 $23$ 位，使用舍入到偶数方法得 $0.0.00011001100110011001101$&lt;/p&gt;
&lt;p&gt;B. $x&apos; - 0.1 = 0.00000000000000000000000[0011] = 0.1 \cdot 2^{-22}$&lt;/p&gt;
&lt;p&gt;C. $60 \cdot 60 \cdot 100 \cdot 10 0.2 \cdot 2^{-22} = 0.086$&lt;/p&gt;
&lt;p&gt;D. $0.086 \cdot 2000 = 171.67$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.52&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;格式 A&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;格式 B&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;位&lt;/td&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt;位&lt;/td&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;011 0000&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0111 000&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;101 1110&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$2^{2} \times 1.1110_2$&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1001 111&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$2^2 \times 1.111_2$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;010 1001&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$2^{-1} \times 1.1001_2$&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0110 100&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$2^{-1} \times 1.100_2$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;110 1111&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$2^3 \times 1.1111_2$&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1011 000&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$2^{4} \times 1.000_2$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;000 0001&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$2^{-2} \times 0.0001$&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0001 000&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$2^{-6} \times 1.000_2$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.53&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define POS_INFINITY 0x7FF0000000000000
#define NEG_INFINITY 0xFFF0000000000000
#define NEG_ZERO 0x8000000000000000
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;练习题 2.54&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. &lt;code&gt;int&lt;/code&gt; 转 &lt;code&gt;double&lt;/code&gt; 没有精度丢失，再转回来也没事&lt;/p&gt;
&lt;p&gt;B. &lt;code&gt;x = 0x7fffffff&lt;/code&gt; 时，转成 &lt;code&gt;float&lt;/code&gt; 会舍入，精度下降，甚至比 &lt;code&gt;x&lt;/code&gt; 大的值，再转回 &lt;code&gt;int&lt;/code&gt; 会溢出&lt;/p&gt;
&lt;p&gt;C. &lt;code&gt;double&lt;/code&gt; 转 &lt;code&gt;float&lt;/code&gt; 精度会丢失&lt;/p&gt;
&lt;p&gt;D. &lt;code&gt;float&lt;/code&gt; 转 &lt;code&gt;double&lt;/code&gt; 精度不会丢失&lt;/p&gt;
&lt;p&gt;E. 浮点数取加法逆元只需要把符号位取反即可，取两次加法逆元符号不变&lt;/p&gt;
&lt;p&gt;F. 两侧都会变成 &lt;code&gt;double/double&lt;/code&gt; ，且 &lt;code&gt;int&lt;/code&gt; 转 &lt;code&gt;double&lt;/code&gt; 精度不丢失，所以值相等&lt;/p&gt;
&lt;p&gt;G. 浮点数取平方，一定为正数，且大于等于 $0$&lt;/p&gt;
&lt;p&gt;H. 若 &lt;code&gt;f + d&lt;/code&gt; 溢出 &lt;code&gt;double&lt;/code&gt; 最大规格化数值成 &lt;code&gt;inf&lt;/code&gt; ，则 &lt;code&gt;f + d - f&lt;/code&gt; 为 &lt;code&gt;inf&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;第 3 章  程序的机器级表示&lt;/h2&gt;
&lt;h3&gt;3.4 访问信息&lt;/h3&gt;
&lt;p&gt;x86_64 寄存器：&lt;/p&gt;
&lt;p&gt;格式为 $Immm(r_b, r_i, s)$ 的操作数格式表示的操作数为 $M[Imm + R[r_b] + R[r_i] \cdot s]$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.1&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作数&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%rax&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x100&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0x104&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0xAB&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0x108&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x13&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(%rax)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0xFF&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;4(%rax)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0xAB&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;9(%rax, %rdx)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x11&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;260(%rcx, %rdx)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x13&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xFC(, %rcx, 4)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0xFF&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(%rax, %rdx, 4)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x11&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movl %eax, (%rsp)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movw (%rax), %dx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movb $0xFF, %bl&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movb (%rsp, %rdx, 4), %dl&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movq (%rdx), %rax&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movw %dx, (%rax)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movb $0xF, (%ebx)&lt;/code&gt; ：&lt;code&gt;%ebx&lt;/code&gt; 不可以作为内存引用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movl %rax, (%rsp)&lt;/code&gt; ：&lt;code&gt;%rax&lt;/code&gt; 是四字，应该用 &lt;code&gt;movq&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movw (%rax), 4(%rsp)&lt;/code&gt; ：两个操作数都指向内存&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movb %al, %sl&lt;/code&gt; ：似乎不存在 &lt;code&gt;%sl&lt;/code&gt; 寄存器&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movq %rax, $0x123&lt;/code&gt; ：目的操作数不能是立即数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movl %eax, %rdx&lt;/code&gt;：&lt;strong&gt;目的寄存器大小应该和 &lt;code&gt;%rax&lt;/code&gt; 保持一致，即 &lt;code&gt;edx&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movb %si, 8(%rbp)&lt;/code&gt;：&lt;code&gt;%si&lt;/code&gt; 是双字，应该用 &lt;code&gt;movw&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movzbl (%rdi), %eax&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movb %eax, (%rsi)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;&lt;code&gt;movzbl (%rdi), %eax&lt;/code&gt;&lt;/s&gt; &lt;code&gt;movsbl (%rdi), %eax&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movb %eax, (%rsi)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movzbq (%rdi), %rax&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mob %rax, (%rsi)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movl (%rdi), %eax&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movb %al, (%rsi)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movl (%rdi), %eax&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movb %al, (%rsi)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movzbw (%rdi), %ax&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movw %ax, (%rsi)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.5&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void decode1(long *xp, long *yp, long *zp)
{
    long *ap = *xp;
    long *bp = *yp;
    long *cp = *zp;
    yp = ap;
    zp = bp;
    xp = cp;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.6&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;6 + (x mod 2^16)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x + y&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x + 4y&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;7 + 9x&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0xA + 4y&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;9 + x + 2y&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.7&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;5x + 2y + 8z&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0x100&lt;/code&gt;  &lt;code&gt;0x11&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0x108&lt;/code&gt;  &lt;code&gt;0xA8&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0x118&lt;/code&gt;  &lt;code&gt;0x110&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0x110&lt;/code&gt;  &lt;code&gt;0x14&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%rcx&lt;/code&gt;  &lt;code&gt;0x0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%rax&lt;/code&gt;  &lt;code&gt;0xFD&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.9&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movl %rdi, %rax&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;salq $4, %rax&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;&lt;code&gt;movb (%rsi), %cl&lt;/code&gt;&lt;/s&gt;  &lt;code&gt;movq (%esi), %rcx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sarq %cl, %rax&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.10&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long t1 = x | y;
long t2 = t1 &amp;gt;&amp;gt; 3;
long t3 = ~t2;
long t4 = z - t3;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.11&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. 将 &lt;code&gt;%rdx&lt;/code&gt; 所有位置 &lt;code&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B. &lt;code&gt;movq $0, %rdx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;C.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.12&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;urerndiv:
	movq %rdx, %r8
    movq $rdi, %rax
    movq $0, %rdx
    divq %rsi
    movq %rax, (%r8)
    movq %rad, (%rcx)
    ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.13&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. &lt;code&gt;int &amp;lt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B. &lt;code&gt;short &amp;gt;=&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;C. &lt;code&gt;unsigned char &amp;lt;=&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;D. &lt;code&gt;long long !=&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.14&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. &lt;code&gt;long long &amp;gt;=&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B. &lt;code&gt;short/unsigned short ==&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;C. &lt;code&gt;unsign char &amp;lt;=&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;D. &lt;code&gt;int !=&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.15&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. &lt;code&gt;0x4003fe&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B. &lt;code&gt;0x400521&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;C. &lt;code&gt;0x400543 0x400545&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;D. &lt;code&gt;0x400560&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.16&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void cond_goto(long a, long *p)
{
    if(!p) goto p_nq_zero;
    if(!(a &amp;gt; *p)) goto a_g_p;
    *p = a;
p_nq_zero:
a_g_p:
    return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该判断条件由两个子条件构成，任意一个条件不满足函数都将返回，因此需要两个分支语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.17&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long gotodiff_se2(long x, long y)
{
    long result;
    if(x &amp;gt;= y) goto _true;
    else goto _false;
_true:
    lt_cnt++;
    result = y - x;
    goto: end_if
_false:
    ge_cnt++;
    result = x - y;
end_if:
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选用本例中的方法代码更加清晰易读，但是可能产生额外的转跳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.18&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long test(long x, long y, long z)
{
    long val = x + y + z;
    if(x &amp;lt; -3)
    {
        if(y &amp;lt; z)
            val = x * y;
        else
            val = y * z;
    }
    else if(x &amp;gt; 2)
        val = x * z;
    return val;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.19&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. $T_{mp} = 2 \times (T_{ran} - T_{ok}) , \ T_{ok} = 16, \ T_{ran} = 31 \to T_{mp} = 30$&lt;/p&gt;
&lt;p&gt;B. $30 + 16 = 46$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.20&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long arith(long x)
{
    long v = x + 7;
    if(x) v = x;
    v &amp;gt;&amp;gt;= 3;
    return v;
}
// =&amp;gt;
long arith(long x)
{
	return (x &amp;lt; 0 ? x + 7 : x) / 8;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;OP&lt;/code&gt; 表示除法 &lt;code&gt;/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.21&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long test(long x, long y)
{
    long val = 8x;
	long val2 = y - x;
    long val3 = x &amp;amp; y;
    long val4 = x + y;
    if(y &amp;lt;= 0)
    {
        if(y &amp;lt;= -2) val = val4;
    }
    else
    {
        val = val2;
        if(x - y &amp;gt;= 0) val = val3;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;long test(long x, long y)
{
    long val = 8x;
	long val2 = y - x;
    long val3 = x &amp;amp; y;
    long val4 = x + y;
	if(y &amp;gt; 0)
    {
        if(x - y &amp;gt;= 0) val = x &amp;amp; y;
        else val = y - x;
    }
    else if(y &amp;lt;= -2) val = x + y;
    return val;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.23&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%rax -&amp;gt; x
%rcx -&amp;gt; y
%rdx -&amp;gt; n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(*p)++&lt;/code&gt; 表示令 &lt;code&gt;x+=1&lt;/code&gt; ，则在第 &lt;code&gt;7&lt;/code&gt; 行与 &lt;code&gt;x += y&lt;/code&gt; 一起计算.&lt;/p&gt;
&lt;p&gt;C.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dw_loop:
    movq %rdi, %rax
    movq %rdi, %rcx
    imulq %rdi, %rcx	// y = x * x
    leaq (%rdi,%rdi), %rdx	// n = 2 * x
.L2:
    leaq 1(%rcx,%rax), %rax	// x += y; (*p)++
    subq $1, %rdx	// n--;
    testq %rdx, %rdx	//if(n &amp;gt; 0) goto dw_loop:
    jg .L2
    rep; ret 	// return x;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.24&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long loop_while(long a, long b)
{
    long result = 1;
    while(a &amp;gt; b)
    {
        result *= a + b;
        a++;
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.25&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long loop_while2(long a, long b)
{
    long result = b;
    while(b &amp;gt; 0)
    {
        result *= a;
        b -= a;
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.26&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long fun_a(unsigned long x)
{
    long val = 0;
    while(x != 0)
    {
        val ^= x;
        x &amp;gt;&amp;gt;= 1;
    }
    return val &amp;amp; 0x1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.27&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long fact_for(long n)
{
    long i;
    long result = 1;
    for(i = 2; i &amp;lt;= n; i++)
    {
        result += i;
    }
    return result;
}

long fact_for_while(long n)
{
    long result = 1;
    long i = 2;
    while(i &amp;lt;= n)
    {
        result += i;
        i++;
    }
    return result;
}

long fact_for_while_guarded_do(long n)
{
    long i = 2;
    long result = 1;
    if(i &amp;gt; n) goto done;
loop:
    result *= i;
    i++;
    if(i &amp;lt;= n) goto loop:
done:
    return result;
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.28&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long fun_b(unsigned long x)
{
    long val = 0;
    long i;
    for(i = 64; i &amp;gt; 0; i--)
    {
        val *= 2;
        val |= x &amp;amp; 1;
        x &amp;gt;&amp;gt;= 1;
    }
    return val;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.29&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long sum = 0;
long i = 0;
while(i &amp;lt; 10)
{
    if(i &amp;amp; 1) continue;
    sum += i;
    i++;
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long sum = 0;
long i = 0;
if(i &amp;gt;= 10) goto done;
loop:
if((i &amp;amp; 1) &amp;amp;&amp;amp; (i&amp;lt;10)) goto update;
sum += i;
update:
i++;
if(i &amp;lt; 10) goto loop;
done:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.30&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void switch2(long x, long *dest)
{
    long val = 0;
    switch(x) {
        case -1:
            goto L9;
            break;
        case 0:
        case 7:
            goto L5;
            break;
        case 1:
            goto L6;
            break;
        case 2:
        case 4:
            goto L7;
            break;
        case 3:
        case 6:
            goto L2;
            break;
        case 5:
            goto L8;
            break;
        default:
            goto L2;
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B. &lt;code&gt;L5&lt;/code&gt; &lt;code&gt;L7&lt;/code&gt; &lt;code&gt;L2&lt;/code&gt; 均有多个标号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.31&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void switcher(long a, long b, long c, long *dest)
{
    long val;
    switch(a)
    {
        case 5:
            c = b ^ 15;
        case 0:
            val = 112 + c;
        	break;
        case 2:
        case 7:
            val = (b + c) &amp;lt;&amp;lt; 2;
            break;
        case 4:
            val = a;
            break;
        default:
            val = b;
    }
    *dest = val;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;3.7 过程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.32&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;状态值&lt;/th&gt;
&lt;th&gt;（指令&lt;/th&gt;
&lt;th&gt;执行&lt;/th&gt;
&lt;th&gt;前）&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;标号&lt;/td&gt;
&lt;td&gt;PC&lt;/td&gt;
&lt;td&gt;指令&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%rdi&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%rsi&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%rax&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%rsp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*%rsp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;M1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0X400560&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;callq&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;10&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x7fffffffe820&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;调用&lt;code&gt;first(10)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;F1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x400548&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lea&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;10&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x7fffffffe828&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x400565&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;调用&lt;code&gt;lea&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;F2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x40054c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sub&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;10&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;11&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x7fffffffe828&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x400565&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;F3&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x400550&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;callq&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;9&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;11&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x7fffffffe828&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x400565&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;L1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x400540&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;mov&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;9&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;11&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x7fffffffe830&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x400555&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;L2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x400543&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;imul&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;9&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;11&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;11&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x7fffffffe830&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x400555&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;L3&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x400547&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;retq&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;9&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;11&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;99&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x7fffffffe830&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x400555&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;F4&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x400555&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;repz&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;9&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;11&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;99&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x7fffffffe828&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x400565&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;M2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x400565&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;mov&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;9&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;11&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;99&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x7fffffffe820&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.33&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(int a, short b, long long *u, char*v)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(int b, short b, long long *v, char*u)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.34&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. &lt;code&gt;a0 ... a5&lt;/code&gt; 存储在被调用者保存及寻求&lt;/p&gt;
&lt;p&gt;B. &lt;code&gt;a6, a7&lt;/code&gt; 存储在栈上&lt;/p&gt;
&lt;p&gt;C. 因为被调用者保存寄存器总共只有 $6$ 个&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.35&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. 是参数 &lt;code&gt;x&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long rfun(unsigned long x)
{
    if(x == 0) 
        return 0;
    unsigned long nx = x;
    long rv = rfun(nx);
    return nx * rv;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;3.8 数组&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习 3.36&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数组&lt;/th&gt;
&lt;th&gt;元素大小&lt;/th&gt;
&lt;th&gt;整个数组的大小&lt;/th&gt;
&lt;th&gt;起始地址&lt;/th&gt;
&lt;th&gt;元素 $i$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;td&gt;$14$&lt;/td&gt;
&lt;td&gt;$x_s$&lt;/td&gt;
&lt;td&gt;$x_s + 2i$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$8$&lt;/td&gt;
&lt;td&gt;$24$&lt;/td&gt;
&lt;td&gt;$x_T$&lt;/td&gt;
&lt;td&gt;$x_T + 8i$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;U&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$8$&lt;/td&gt;
&lt;td&gt;$48$&lt;/td&gt;
&lt;td&gt;$x_U$&lt;/td&gt;
&lt;td&gt;$x_U + 8i$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$4$&lt;/td&gt;
&lt;td&gt;$32$&lt;/td&gt;
&lt;td&gt;$x_V$&lt;/td&gt;
&lt;td&gt;$x_v+4i$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$8$&lt;/td&gt;
&lt;td&gt;$32$&lt;/td&gt;
&lt;td&gt;$x_w$&lt;/td&gt;
&lt;td&gt;$x_w+8i$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.37&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;short*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$x_s+2$&lt;/td&gt;
&lt;td&gt;&lt;code&gt;leal 2(%rdx), %rax&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;short&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$M[x_s+6]$&lt;/td&gt;
&lt;td&gt;&lt;code&gt;mov 6(%rdx), %al&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;short*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$x_s+2i$&lt;/td&gt;
&lt;td&gt;&lt;code&gt;leal (%rdx, %rcx, 2), %rax&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;short&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$M[x_s+8i+2]$&lt;/td&gt;
&lt;td&gt;&lt;code&gt;mov 2(%rdx, %rcx, 8), %al&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;short*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$x_s+2i-10$&lt;/td&gt;
&lt;td&gt;&lt;code&gt;leal -10(%rdx, %rcx, 2), %rax&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.38&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;M(P + 8(7i + 5j)) + M(Q + 8(i + 5j))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;得 &lt;code&gt;N = 7&lt;/code&gt; &lt;code&gt;M = 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.39&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;T D[R][C]&lt;/code&gt;$\to$ &lt;code&gt;D[i][j] = *(D + L(C * i + j))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;A[i][0] = A + 4 * (16 * i) = 64i&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;B[0][k] = B + 4 * (k) = B + 4k&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;B[N][k] = B + 4 * (N * 16 + k) = B + 4k + 1024&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.40&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void fix_set_diag_opt(fix_matrix A, int val, int N)
{
    int *Aend = A + N * (N + 1);
    do
    {
        *A = val;
        A += N + 1;
    } while(A != Aend);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;3.9 异质的数据结构&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.41&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;p: 0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;s.x: 8&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;s.y: 12&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;next: 16&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;24&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;C.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void sp_init(struct prob *sp)
{
    sp-&amp;gt;s.x = sp-&amp;gt;s.y;
    sp-&amp;gt;p = &amp;amp;(sp-&amp;gt;s.x);
    sp-&amp;gt;next = sp;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.42&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long fun(struct ELE *ptr)
{
    int result = 0;
    while(ptr != NULL)
    {
        result += ptr-&amp;gt;v;
        prt = ptr-&amp;gt;p;
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;p&gt;遍历以 &lt;code&gt;ELE&lt;/code&gt; 为头节点的链表，求 &lt;code&gt;v&lt;/code&gt; 的和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.43&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$expr$&lt;/th&gt;
&lt;th&gt;$type$&lt;/th&gt;
&lt;th&gt;代码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;short&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;movw 8(%rdi), %ax&lt;/code&gt;&amp;lt;br&amp;gt;&lt;code&gt;movw %ax, (%si)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;char*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;addq \$10, %rdi &lt;/code&gt; &amp;lt;br&amp;gt;&lt;code&gt;movq %rdi, (%rsi)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;int*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;movq %rdi, (%rsi)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;movq (%rdi), %rax&lt;/code&gt;&amp;lt;br&amp;gt;&lt;code&gt;movl (%rdi, %rax, 4), %eax&lt;/code&gt; &amp;lt;br&amp;gt;&lt;code&gt;movl %eax, (%rsi)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;char&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;movq 8(%rdi), %rax&lt;/code&gt; &amp;lt;br&amp;gt;&lt;code&gt;movb (%rax), %al&lt;/code&gt; &amp;lt;br&amp;gt;&lt;code&gt;movb %al, (%rsi)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.44&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0	4	8	12
i	c	j	d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0	4	5	8
i	c	d	j
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0		2		4		6		7		8
w[0]	w[1]	w[2]	c[0]	c[1]	c[2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;D.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0		2		4		6		8		16		24		32
w[0]	w[1]	w[2]	w[3]	w[4]	c[0]	c[1]	c[2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;E.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0		10		24
a[0]	a[1]	t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.45&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a	b	c	d	e	f	g	h
8	2	8	1	4	1	8	4
0	8	16	24	28	32	40	48
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;p&gt;$52$&lt;/p&gt;
&lt;p&gt;C.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a	c	g	e	h	b	d	f
8	8	8	4	4	2	1	1
0	8	16	24	28	32	34	35
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优化后需要填充至 $40$ 确保下一个实例内存对齐，故大小为 $40$&lt;/p&gt;
&lt;h3&gt;3.10 在机器级程序中将控制与数据结合起来&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.46&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 00 00 00 00 40 00 76		返回地址
01 23 45 67 89 AB CD EF		%rbx
							
							&amp;lt;- buf = %rsp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 00 00 00 00 40 00 34		返回地址
33 32 31 30 39 38 37 36		%rbx
35 34 33 32 31 30 39 38
37 36 35 34 33 32 31 30	&amp;lt;- buf = %rsp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C.&lt;/p&gt;
&lt;p&gt;返回到 &lt;code&gt;0x00 40 00 34&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;D.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%rbx&lt;/code&gt; 被破坏了，它的值会被加载为 &lt;code&gt;0x33 32 31 30 39 38 37 36&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;E.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;malloc&lt;/code&gt;函数调用时应该分配 &lt;code&gt;len(buf)+1&lt;/code&gt; 长度的内存来容纳字符串结尾的 &lt;code&gt;\0&lt;/code&gt; ，同时还应该检查 &lt;code&gt;result&lt;/code&gt; 是否为 &lt;code&gt;NULL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.47&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. 大约 $2^{13}$ 个&lt;/p&gt;
&lt;p&gt;B. &lt;code&gt;128&lt;/code&gt; 字节即 $2^7$ ，使得只需要 $2^6 = 64$ 次尝试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.48&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;p&gt;不带保护：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;buf&lt;/code&gt; 在 &lt;code&gt;%rsp&lt;/code&gt; ，&lt;code&gt;v&lt;/code&gt; 在 &lt;code&gt;%rsp+24&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;带保护：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;buf&lt;/code&gt; 在 &lt;code&gt;%rsp+16&lt;/code&gt; ，&lt;code&gt;v&lt;/code&gt; 在 &lt;code&gt;%rsp+8&lt;/code&gt; ，金丝雀值在 &lt;code&gt;%rsp+40&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;v&lt;/code&gt; 比 &lt;code&gt;buf&lt;/code&gt; 更靠近栈顶，使得溢出更不容易影响到 &lt;code&gt;buf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 3.49&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;p&gt;首先将 &lt;code&gt;%rax&lt;/code&gt; 设为 $8n+22$ ，接着让它 &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;-16&lt;/code&gt; ，等价于让其向下舍入到最接近的 &lt;code&gt;16&lt;/code&gt; 的倍数，保证内存对齐。得到 $s_2$ 的值&lt;/p&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;p&gt;先将 &lt;code&gt;%rsp&lt;/code&gt; 加 $7$ ，而后除以 $8$ 再乘以 $8$ ，可向上舍入到最近的 $8$ 的倍数，得到 &lt;code&gt;p&lt;/code&gt; 的值。&lt;/p&gt;
&lt;p&gt;C.&lt;/p&gt;
&lt;p&gt;对应最大化与最小化 $e_1$ $e_2$ 的情况。&lt;/p&gt;
&lt;p&gt;D.&lt;/p&gt;
&lt;p&gt;实现 $s_2$ 的 $16$ 字节对齐，$p$ 的 $8$ 字节对齐。&lt;/p&gt;
&lt;h2&gt;第 4 章  处理器的体系结构&lt;/h2&gt;
&lt;h3&gt;4.1 Y86-64 指令集体系结构&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.1&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x100: 30f30f00000000000000
0x10a: 2031
0x10c: 4013fdffffffffffffff
0x116: 6231
0x118: 70c010000000000000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x100: 30f3fcffffffffffffff	irmovq $-4, %rbx
0x10c: 40630008000000000000	rmmovq %rsi, 0x800(%rbx)
0x114: 00					halt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x200: a06f					push %rsi
0x202: 800c0200000000000000	call proc
0x20b: 00					halt
0x20c: 						proc.
0x20c: 30f3a000000000000000	irmovq $10, %rbx
0x216: 90					ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.4&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.x86-64
rsum(long*, long):
        push    rbp
        mov     rbp, rsp
        push    rbx
        sub     rsp, 24
        mov     QWORD PTR [rbp-24], rdi
        mov     QWORD PTR [rbp-32], rsi
        cmp     QWORD PTR [rbp-32], 0
        jg      .L2
        mov     eax, 0
        jmp     .L3
.L2:
        mov     rax, QWORD PTR [rbp-24]
        mov     rbx, QWORD PTR [rax]
        mov     rax, QWORD PTR [rbp-32]
        lea     rdx, [rax-1]
        mov     rax, QWORD PTR [rbp-24]
        add     rax, 8
        mov     rsi, rdx
        mov     rdi, rax
        call    rsum(long*, long)
        add     rax, rbx
.L3:
        mov     rbx, QWORD PTR [rbp-8]
        leave
        ret
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.y86
		pushq	%rsp
		rrmovq	%rsp, %rbp
		pushq	%rbx
		irmovq	$24, %r8
		subq	%r8, %rsp
		mrmovq	-24(%rbp), %r8
		mrmovq	(%r8), %rdi
		mrmovq	-32(%rbp), %r8
		mrmovq	(%r8), %rsi
		andq	%rsi, %rsi
		jg		.L2
.L2:
		...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.5&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sum:
	irmovq	$8, %r8
	irmovq	$1, %r9
	xorq	%rax, %rax
	andq	%rsi, %rsi
	jmp		test
loop:
	mrmovq	(%rdi), %r10
	irmovq	$0, %r11
	subq	%r10, %r11
	andq 	%r10, %r10
	jg endif
	rrmovq	%r11, %r10
endif:
	addq	%r10, %rax
	addq	%r8, %rdi
	subq	%r9, %rsi
test:
	jne		loop
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.6&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sum:
	irmovq	$8, %r8
	irmovq	$1, %r9
	xorq	%rax, %rax
	andq	%rsi, %rsi
	jmp		test
loop:
	mrmovq	(%rdi), %r10
	irmovq	$0, %r11
	subq	%r10, %r11
	andq	%r10, %r10
	cmovl	%r11, %r10
	addq	%r10, %rax
	addq	%r8, %rdi
	subq	%r9, %rsi
test:
	jne		loop
	ret
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;4.2 逻辑设计和硬件语言控制 HCL&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.9&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool xor = (!a &amp;amp;&amp;amp; b) || (a &amp;amp;&amp;amp; !b);
// eq == (xor == 0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.10&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按位 &lt;code&gt;xor&lt;/code&gt; ，将所有结果取 &lt;code&gt;and&lt;/code&gt;，再取 &lt;code&gt;not&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.11&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;word Min3 = [
    A &amp;lt;= B &amp;amp;&amp;amp; A &amp;lt;= C: A;
    B &amp;lt;= C : B;
    1 : C;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.12&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;word Mid3 = [
	(A &amp;lt;= B &amp;amp;&amp;amp; B &amp;lt;= C) || (C &amp;lt;= B &amp;amp;&amp;amp; B &amp;lt;= A) : B;
    (A &amp;lt;= C &amp;amp;&amp;amp; C &amp;lt;= B) || (B &amp;lt;= C &amp;amp;&amp;amp; C &amp;lt;= A) : C;
    (B &amp;lt;= A &amp;amp;&amp;amp; A &amp;lt;= C) || (C &amp;lt;= A &amp;amp;&amp;amp; A &amp;lt;= B) : A;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;4.3 Y86-64 的顺序实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.13&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;阶段&lt;/th&gt;
&lt;th&gt;通用&lt;/th&gt;
&lt;th&gt;具体&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;irmoq V, rB&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;irmovq $128, %rsp&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;取指&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;icode:ifun &amp;lt;- M_1[0x016] = 3:0&lt;/code&gt; &amp;lt;br&amp;gt;&lt;code&gt;rA:rB &amp;lt;- M_1[0x017] = f:4&lt;/code&gt; &amp;lt;br&amp;gt; &lt;code&gt;valC &amp;lt;- M_8[0x018] = 128&lt;/code&gt; &amp;lt;br&amp;gt; &lt;code&gt;valP &amp;lt;- 0x020&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;译码&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;执行&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;valE &amp;lt;- 128&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;访存&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;写回&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;R[rB] &amp;lt;- 128&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;更新 PC&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;PC &amp;lt;= 0x020&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.14&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0x02c: b00f&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%rsp = 0x120&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;阶段&lt;/th&gt;
&lt;th&gt;通用&lt;/th&gt;
&lt;th&gt;具体&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;popq rA&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;popq %rax&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;取指&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;icode:ifun &amp;lt;- M_1[0x02c] = b:0&lt;/code&gt; &amp;lt;br&amp;gt; &lt;code&gt;rA:rB &amp;lt;- m_1[0x02d] = 0:f&lt;/code&gt; &amp;lt;br&amp;gt; &lt;code&gt;valP &amp;lt;- 0x02e&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;译码&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;valA &amp;lt;- R[%rsp] = 0x120&lt;/code&gt; &amp;lt;br&amp;gt;&lt;code&gt;valB &amp;lt;- R[5rsp] = 0x120&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;执行&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;valE &amp;lt;- valB + 8 = 0x128&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;访存&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;valM &amp;lt;- M_8[0x120] = 9&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;写回&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;R[%rsp] &amp;lt;- valE = 0x128&lt;/code&gt; &amp;lt;br&amp;gt;&lt;code&gt;R[rA] &amp;lt;- valM = 9&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;更新 PC&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;PC &amp;lt;- valP = 0x02e&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.15&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将 &lt;code&gt;%rsp&lt;/code&gt; 变更前 &lt;code&gt;%rsp&lt;/code&gt; 的值写入&lt;code&gt;%rsp&lt;/code&gt; 变更后指向的栈顶内存中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.16&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将 &lt;code&gt;%rsp&lt;/code&gt; 变更前栈顶的值写入 &lt;code&gt;%rsp&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.17&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;阶段&lt;/th&gt;
&lt;th&gt;&lt;code&gt;cmovXX rA, rB&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;取指&lt;/td&gt;
&lt;td&gt;&lt;code&gt;icode:ifun &amp;lt;- M_1p[PC]&lt;/code&gt; &amp;lt;br&amp;gt; &lt;code&gt;rA:rB &amp;lt;- M-1[PC+1]&lt;/code&gt; &amp;lt;br&amp;gt; &lt;code&gt;valP &amp;lt;- PC + 2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;译码&lt;/td&gt;
&lt;td&gt;&lt;code&gt;valA &amp;lt;- R[rA]&lt;/code&gt; &amp;lt;br&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;执行&lt;/td&gt;
&lt;td&gt;&lt;code&gt;valE &amp;lt;- 0 + valA&lt;/code&gt;  &amp;lt;br&amp;gt;&lt;code&gt;Cnd &amp;lt;- Cond(CC, ifun)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;写回&lt;/td&gt;
&lt;td&gt;&lt;code&gt;R[rB] &amp;lt;- valE&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;更新 PC&lt;/td&gt;
&lt;td&gt;&lt;code&gt;PC &amp;lt;- valP&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.18&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0x037: 804100000000000000&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;阶段&lt;/th&gt;
&lt;th&gt;通用&lt;/th&gt;
&lt;th&gt;具体&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;call Dest&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;call 0x041&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;取指&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;icode:ifun &amp;lt;- M_1[0x037] = 8:0&lt;/code&gt; &amp;lt;br&amp;gt; &lt;code&gt;valC &amp;lt;- 0x041&lt;/code&gt; &amp;lt;br&amp;gt; &lt;code&gt;valP &amp;lt;- 0x037+9 = 0x040&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;译码&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;valB &amp;lt;- R[%rsp] = 0x128&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;执行&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;valE &amp;lt;- valB + (-8) = 0x120&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;访存&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;M_8[valE] &amp;lt;- valP = 0x040&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;写回&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;R[%rsp] &amp;lt;- valE = 0x120&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;更新 PC&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;PC &amp;lt;- valC = 0x041&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.19&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool need_valC = icode in {IIRMIVQ, IRMMOVQ, IMRMOVQ, ICALL, IJXX}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.20&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;word srcB = [
    icode in { IOPQ, IRMMOVQ, IMRMOVQ} : rB;
    icode in { IPUSHQ, ICALL, IPOPQ, IRET} : RRSP;
    1 : RNONE;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.22&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由 &lt;strong&gt;练习题 4.8&lt;/strong&gt; 知 &lt;code&gt;popq %rsp&lt;/code&gt; 最终将写入内存的值，因此 &lt;code&gt;M&lt;/code&gt; 口的优先级应该更高.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.24&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;word dstE = [
  	icode in { IRRMOVQ } &amp;amp;&amp;amp; cnd : rB;
    icode in { IRMMOVQ, IPOPQ } : rB;
    icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
    1 : RNONE；
];
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;4.4 流水线的通用原理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.28&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. &lt;code&gt;C&lt;/code&gt; 与 &lt;code&gt;D&lt;/code&gt; 之间，延迟为 $380ns$ ，一个时钟周期为 $190ns$&lt;/p&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 4.29&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;p&gt;$Y(k) = 300 + 20k (ns)$&lt;/p&gt;
&lt;p&gt;$T(k) = 1s / (300 / k + 20)ns$&lt;/p&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;p&gt;$1 / 20 * 10^9 = 50\ GIPS$&lt;/p&gt;
&lt;h3&gt;4.5 Y86-64 d的流水线实现&lt;/h3&gt;
&lt;h2&gt;第 5 章  优化程序性能&lt;/h2&gt;
&lt;h3&gt;5.1 优化编译器的能力和局限性&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 5.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若 &lt;code&gt;xp&lt;/code&gt; 和 &lt;code&gt;yp&lt;/code&gt; 在同一个位置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void swap(long *xp, long *xp)
{
    *xp = *xp + *xp;	// 2 * *xp;
    *xp = *xp - *xp;	// 0
    *xp = *xp - *xp;	// 0
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;5.4 消除循环的低效率&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 5.3&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;代码&lt;/th&gt;
&lt;th&gt;&lt;code&gt;min&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;max&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;incr&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;square&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$91$&lt;/td&gt;
&lt;td&gt;$90$&lt;/td&gt;
&lt;td&gt;$90$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;$91$&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$90$&lt;/td&gt;
&lt;td&gt;$90$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$90$&lt;/td&gt;
&lt;td&gt;$90$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 5.4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. 在第一个循环中 &lt;code&gt;%xmm0&lt;/code&gt; 是临时值，被初始化为 &lt;code&gt;%rbx&lt;/code&gt; 的值，每次循环结束后写回 &lt;code&gt;%rbx&lt;/code&gt; ，第二个循环中 &lt;code&gt;%xmm0&lt;/code&gt; 是累计值。&lt;/p&gt;
&lt;p&gt;B. 与 &lt;code&gt;combine3&lt;/code&gt; 行为相同。&lt;/p&gt;
&lt;p&gt;C. 因为除了每次循环开头没有 将 &lt;code&gt;%rbx&lt;/code&gt; 指向内存传给 &lt;code&gt;%xmm0&lt;/code&gt; ，其他都一样，而 &lt;code&gt;%xmm0&lt;/code&gt; 本身就是累计值，在循环开始前就初始化为 &lt;code&gt;IDENT&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 5.5&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;p&gt;加法：$n$ 次&lt;/p&gt;
&lt;p&gt;乘法： $2n$ 次&lt;/p&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;p&gt;乘法： $n$ 次&lt;/p&gt;
&lt;h3&gt;5.9 提高并行性&lt;/h3&gt;
&lt;p&gt;**练习题 5.8 ? **&lt;/p&gt;
&lt;p&gt;A1: $15.0$&lt;/p&gt;
&lt;p&gt;A2: $10.0$&lt;/p&gt;
&lt;p&gt;A3: $5.0$&lt;/p&gt;
&lt;p&gt;A4: $5.0$&lt;/p&gt;
&lt;p&gt;A5: $10.0$&lt;/p&gt;
&lt;h3&gt;5.11 一些限制因素&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 5.9&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int take = src1[i1] &amp;lt; src2[i1];
dest[id++] = src1[i1] &amp;lt; src2[i1] ? src1[i1] : src2[i2];
i1 += take;
i2 += 1 - take;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 5.10&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;p&gt;将数组变为： &lt;code&gt;2, ..., 1000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;p&gt;将数组变为： &lt;code&gt;1, ..., 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;C.&lt;/p&gt;
&lt;p&gt;A 情况中所有循环不想关，可以独立执行； B 情况中，前后迭代存在读/写相关，将导致性能下降。&lt;/p&gt;
&lt;p&gt;D.&lt;/p&gt;
&lt;p&gt;与情况 A 相同，因为相邻迭代不存在数据相关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 5.11&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相邻的迭代存在数据相关，因此形成了 “存储——加载——加法” 的关键路径，导致性能下降。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 5.12&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void psumv(float *a, int len, float *p)
{
    float acc = 0;
    for(int i=0; i&amp;lt;len; i++)
    {
    	acc += a[i];
        p[i] = acc;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;第 6 章  存储器层次结构&lt;/h2&gt;
&lt;h3&gt;6.1 存储技术&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;越接近正方形需要的地址位越少。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;组织&lt;/th&gt;
&lt;th&gt;$r$&lt;/th&gt;
&lt;th&gt;$c$&lt;/th&gt;
&lt;th&gt;$b_r$&lt;/th&gt;
&lt;th&gt;$b_c$&lt;/th&gt;
&lt;th&gt;&lt;code&gt;max(b_r, b_c)&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$4$&lt;/td&gt;
&lt;td&gt;$4$&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$4$&lt;/td&gt;
&lt;td&gt;$4$&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$16$&lt;/td&gt;
&lt;td&gt;$8$&lt;/td&gt;
&lt;td&gt;$4$&lt;/td&gt;
&lt;td&gt;$3$&lt;/td&gt;
&lt;td&gt;$4$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$32$&lt;/td&gt;
&lt;td&gt;$16$&lt;/td&gt;
&lt;td&gt;$5$&lt;/td&gt;
&lt;td&gt;$4$&lt;/td&gt;
&lt;td&gt;$5$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$32$&lt;/td&gt;
&lt;td&gt;$32$&lt;/td&gt;
&lt;td&gt;$5$&lt;/td&gt;
&lt;td&gt;$5$&lt;/td&gt;
&lt;td&gt;$5$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$512 \times 400 \times 10000 \times 2 \times 2 = 8.192GB$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;平均旋转延迟： $1/2 \times (60/15000) \times 1000ms = 2ms$&lt;/p&gt;
&lt;p&gt;平均传送时间：$(60/15000) / 500 \times 1000ms = 0.008ms$&lt;/p&gt;
&lt;p&gt;总时间： $8 + 2 + 0.008 = 10ms$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;p&gt;读 $1 \times 1024 \times 1024 / 512 = 2048$ 个逻辑块，这也是扇区数，最优情况是寻到后立刻开始读取数据，且数据在同一个柱面上，需要旋转两圈来读取所有数据。&lt;/p&gt;
&lt;p&gt;旋转一圈时间： $60 / 10000 \times 1000ms = 6ms$&lt;/p&gt;
&lt;p&gt;总时间：$5 + 6/2 + 2 \times 6 = 20ms$&lt;/p&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;p&gt;每个块都随机分布在磁盘上，每次都要 $5 + 3 = 8ms$&lt;/p&gt;
&lt;p&gt;共 $8 \times 2000 = 16000ms$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.5&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. $(10^9 \times 128) \times (1 / 470) \times (1 / (86400 \times 365)) = 8 years$&lt;/p&gt;
&lt;p&gt;B. $(10^9 \times 128) \times (1 / 330) \times (1 / (86400 \times 365)) = 13 years$&lt;/p&gt;
&lt;p&gt;C. $(10^9 \times 128) \times (1 / 20000) \times (1/365) = 17.535 years$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.6&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$1PB = 10^6GB$&lt;/p&gt;
&lt;p&gt;每 GB 价格 $500 / 10^6$&lt;/p&gt;
&lt;p&gt;大约 $2025$ 年可以实现。&lt;/p&gt;
&lt;h3&gt;6.2 局部性&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.7&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sum += a[i][j][k]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设 $N = 2$&lt;/p&gt;
&lt;p&gt;数据布局为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;地址	0	4	8	12	16	20	24	28	32	36	40	44
元素	v0	v1	v2	a0	a1	a2	v0	v1	v2	a0	a1	a2	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;clear1&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;地址	0	4	8	12	16	20	24	28	32	36	40	44
元素	v0	v1	v2	a0	a1	a2	v0	v1	v2	a0	a1	a2	
访问	1	2	3	4	5	6	7	8	9	10	11	12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;clear2&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;地址	0	4	8	12	16	20	24	28	32	36	40	44
元素	v0	v1	v2	a0	a1	a2	v0	v1	v2	a0	a1	a2	
访问	1	3	5	2	4	6	7	9	11	8	10	12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;clear3&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;地址	0	4	8	12	16	20	24	28	32	36	40	44
元素	v0	v1	v2	a0	a1	a2	v0	v1	v2	a0	a1	a2	
访问	1	5	9	3	7	11	2	6	10	4	8	12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;空间局部性从好到差：&lt;code&gt;clear1 clear2 clear3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;clear1&lt;/code&gt; 顺序访问，&lt;code&gt;clear2&lt;/code&gt; 以步长为 $3$ 转跳，&lt;code&gt;clear3&lt;/code&gt; 以步长为 $6$ 转跳。&lt;/p&gt;
&lt;h3&gt;6.4 高速缓存存储器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.9&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;高速缓存&lt;/th&gt;
&lt;th&gt;$m$&lt;/th&gt;
&lt;th&gt;$C$&lt;/th&gt;
&lt;th&gt;$B$&lt;/th&gt;
&lt;th&gt;$E$&lt;/th&gt;
&lt;th&gt;$S$&lt;/th&gt;
&lt;th&gt;$t$&lt;/th&gt;
&lt;th&gt;$s$&lt;/th&gt;
&lt;th&gt;$b$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$256$&lt;/td&gt;
&lt;td&gt;$22$&lt;/td&gt;
&lt;td&gt;$8$&lt;/td&gt;
&lt;td&gt;$2$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$64$&lt;/td&gt;
&lt;td&gt;$23$&lt;/td&gt;
&lt;td&gt;$5$&lt;/td&gt;
&lt;td&gt;$3$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$27$&lt;/td&gt;
&lt;td&gt;$0$&lt;/td&gt;
&lt;td&gt;$5$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.10&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于消除了抖动，下列标记为 $1$ 的是命中的，$0$ 为不命中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	0	1	2	3	4	5	6	7
x	0	1	1	1	0	1	1	1
y	0	1	1	1	0	1	1	1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此命中率为 $75%$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.11&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. 相同组索引的块被映射到同一个高速缓存，缓存内每个块的标记位有 $t$ 位，因此一个 chunk 有 $2^t$ 个块。&lt;/p&gt;
&lt;p&gt;B. $S = 512， B = 32$ ，因此 $s = 9， b = 5$ ，当使用高 $s$ 位来作为组索引时，数组中所有块都会被映射到组 $0$ ，任意时刻缓存中数组的块数都是 $1$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.12&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;12&lt;/th&gt;
&lt;th&gt;11&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CT&lt;/td&gt;
&lt;td&gt;CT&lt;/td&gt;
&lt;td&gt;CT&lt;/td&gt;
&lt;td&gt;CT&lt;/td&gt;
&lt;td&gt;CT&lt;/td&gt;
&lt;td&gt;CT&lt;/td&gt;
&lt;td&gt;CT&lt;/td&gt;
&lt;td&gt;CT&lt;/td&gt;
&lt;td&gt;CI&lt;/td&gt;
&lt;td&gt;CI&lt;/td&gt;
&lt;td&gt;CI&lt;/td&gt;
&lt;td&gt;CO&lt;/td&gt;
&lt;td&gt;CO&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.13&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;12&lt;/th&gt;
&lt;th&gt;11&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CO&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CI&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x5&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CT&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x71&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;命中？&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;返回字节&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0xB&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.14&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;12&lt;/th&gt;
&lt;th&gt;11&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CO&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CI&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x5&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CT&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x6E&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;命中？&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;返回字节&lt;/td&gt;
&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.15&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;12&lt;/th&gt;
&lt;th&gt;11&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CO&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CI&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CT&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0xFF&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;命中？&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;返回字节&lt;/td&gt;
&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.16&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000 0110 0100 1100	0x064C
0000 0110 0100 1101	0x064D
0000 0110 0100 1102	0X064E
0000 0110 0100 1103	0X064F
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;6.5 编写高速缓存友好的代码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.27&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dst&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;src&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;h&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dst&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;h&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;src&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;h&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.19&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. $512$&lt;/p&gt;
&lt;p&gt;B. 缓存一行能存储两个元素，每隔两次读就会出现一次缓存不命中，共 $256$ 次。&lt;/p&gt;
&lt;p&gt;C. $50%$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.20&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. $512$&lt;/p&gt;
&lt;p&gt;B. 读取每一个 &lt;code&gt;grid[j][i].x&lt;/code&gt; 都会缓存不命中，读取 &lt;code&gt;grid[j][i].y&lt;/code&gt; 缓存会命中，共不命中 $256$ 次。&lt;/p&gt;
&lt;p&gt;C. $50%$&lt;/p&gt;
&lt;p&gt;D. 能存下整个数组，只存在冷不命中，不命中率为 $25%$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.21&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. $512$&lt;/p&gt;
&lt;p&gt;B. 每两次读取 &lt;code&gt;grid[i][j].x&lt;/code&gt; 会出现一次缓存不命中，而读取所有的 &lt;code&gt;grid[i][j].y&lt;/code&gt; 缓存命中，不命中 $128$ 次。&lt;/p&gt;
&lt;p&gt;C. $25%$&lt;/p&gt;
&lt;p&gt;D. 能存下整个数组，只存在冷不命中，不命中率为 $25%$&lt;/p&gt;
&lt;h3&gt;6.6 综合：高速缓存对程序性能的影响&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 6.21&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由图可知， $L1$ 峰值为 $12000MB/s$ ，每秒读 $12000 / 8$ 次，每秒周期数 $2100M$ ，得 $21000 / 12000 * 8 = 1.4$&lt;/p&gt;
&lt;h2&gt;第 7 章  链接&lt;/h2&gt;
&lt;h3&gt;7.5 符号和符号表&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 7.1&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;外部&lt;/td&gt;
&lt;td&gt;&lt;code&gt;m.c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;.data&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;全局&lt;/td&gt;
&lt;td&gt;&lt;code&gt;swap.c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;.data&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;全局&lt;/td&gt;
&lt;td&gt;&lt;code&gt;swap.c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;COMMON&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;全局&lt;/td&gt;
&lt;td&gt;&lt;code&gt;swap.c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;.text&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;7.6 符号解析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 7.2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(a) -&amp;gt; DEF(main.1)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(b) -&amp;gt; DEF(main.1)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;a -&amp;gt; DEF(错误)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(b) -&amp;gt; DEF(错误)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;C.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(a) -&amp;gt; DEF(x.2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(b) -&amp;gt; DEF(x.2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 7.3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc p.o libx.a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc p.o lilbx.a liby.a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc p.o libx.a liby.a libx.a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 7.4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. &lt;code&gt;0x4004e8&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B. &lt;code&gt;0x5&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 7.5&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;refaddr = ADDR(.text) + r.offset  = 0x4004da&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;*refptr = (unsigned)ADDR(swap) + r.addend - refaddr = 0x400e8 - 4 - 0x4004da = 0xa&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;重定位的值为 &lt;code&gt;4004d9 e8 0a 00 00 00 	callq 4004e8 &amp;lt;swap&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;第 8 章  异常控制流&lt;/h2&gt;
&lt;h3&gt;8.2 进程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 8.1&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;8.4 进程控制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 8.2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A&lt;/p&gt;
&lt;p&gt;&lt;code&gt;p1: x = 2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;p1 x = 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B&lt;/p&gt;
&lt;p&gt;&lt;code&gt;p2: x = 0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 8.3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bacc&lt;/code&gt; 或 &lt;code&gt;abcc&lt;/code&gt; 或 &lt;code&gt;acbc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习题 8.4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. $6$ 行&lt;/p&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;p&gt;设子进程&lt;code&gt;id&lt;/code&gt;为&lt;code&gt;123&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hello
0
Bye
1
2
Bye
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 8.5&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

unsigned int snooze(unsigned int secs)
{
    int snoozeTime = sleep(secs);
    printf(&quot;Slept for %d of %d secs\n&quot;, secs - snoozeTime, secs);
    return snoozeTime;
}

int main()
{
    snooze(5);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 8.6&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char *argv[], char *envp[])
{

    for (int i = 0; argv[i] != NULL; i++)
    {
        printf(&quot;argv[ %d]: %s\n&quot;, i, argv[i]);
    }

    for (int i = 0; envp[i] != NULL; i++)
    {
        printf(&quot;envp[ %d]: %s\n&quot;, i, envp[i]);
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题 8.7&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &quot;../lib/csapp.h&quot;

unsigned int snooze(unsigned int secs)
{
    int snoozeTime = sleep(secs);
    printf(&quot;Slept for %d of %d secs\n&quot;, secs - snoozeTime, secs);
    return snoozeTime;
}

void handler(int sig)
{
    return;
}

int main(int argc, char *argv[])
{
    if (signal(SIGINT, handler) == SIG_ERR)
        unix_error(&quot;signal error&quot;);

    snooze(atoi(argv[1]));

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习题8.8&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;213
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;第 9 章  虚拟内存&lt;/h2&gt;
&lt;h3&gt;9.2 地址空间&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 9.1&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;虚拟地址位数&lt;/th&gt;
&lt;th&gt;虚拟地址数&lt;/th&gt;
&lt;th&gt;最大可能虚拟地址数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$2^8 = 256$&lt;/td&gt;
&lt;td&gt;$255$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$16$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$2^{16} - 1$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$32$&lt;/td&gt;
&lt;td&gt;$2^{32} = 4G$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$48$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$2^{48} - 1$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$64$&lt;/td&gt;
&lt;td&gt;$2^{64} = 16E$&lt;/td&gt;
&lt;td&gt;$2^{64} - 1$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;9.3 虚拟内存作为缓存的工具&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 9.2&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$n$&lt;/th&gt;
&lt;th&gt;$P = 2^p$&lt;/th&gt;
&lt;th&gt;PTE数量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$2^{20}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$2^{19}$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;9.6 地址翻译&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 9.3&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$P$&lt;/th&gt;
&lt;th&gt;$VPN$ 位数&lt;/th&gt;
&lt;th&gt;$VPO$ 位数&lt;/th&gt;
&lt;th&gt;$PPN$ 位数&lt;/th&gt;
&lt;th&gt;$PPO$ 位数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$22$&lt;/td&gt;
&lt;td&gt;$10$&lt;/td&gt;
&lt;td&gt;$14$&lt;/td&gt;
&lt;td&gt;$10$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$21$&lt;/td&gt;
&lt;td&gt;$11$&lt;/td&gt;
&lt;td&gt;$13$&lt;/td&gt;
&lt;td&gt;$11$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$20$&lt;/td&gt;
&lt;td&gt;$12$&lt;/td&gt;
&lt;td&gt;$12$&lt;/td&gt;
&lt;td&gt;$12$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$19$&lt;/td&gt;
&lt;td&gt;$13$&lt;/td&gt;
&lt;td&gt;$11$&lt;/td&gt;
&lt;td&gt;$13$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;练习题 9.4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;13	12	11	10	9	8	7	6	5	4	3	2	1	0
0	0	0	0	1	1	1	1	0	1	0	1	1	1
|			VPN				  |		VPO				|
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;VPN&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0xf&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0X03&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0X03&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x0D&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x357&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;C&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;11	10	9	8	7	6	5	4	3	2	1	0
0	0	1	1	0	1	0	1	0	1	1	1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;D&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x11&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x5&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0xD&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x1D&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;9.8 内存映射&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习题 9.5&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;附录&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;x86寄存器对照表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;63&lt;/th&gt;
&lt;th&gt;31&lt;/th&gt;
&lt;th&gt;15&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%rax&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%eax&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%ax&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%al&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%rbx&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%ebx&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%bx&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%bl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;被调用者保存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%rcx&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%ecx&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%cx&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%cl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第4个参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%rdx&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%edx&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%dx&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%dl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第3个参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%rsi&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%esi&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%si&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%sil&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第2个参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%rdi&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%edi&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%di&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%dil&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第1个参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%rbp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%ebp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%bp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%bpl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;被调用者保存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%rsp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%esp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%sp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%spl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;栈指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%r8&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r8d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r8w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r8b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第5个参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%r9&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r9d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r9w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r9b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第6个参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%r10&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r10d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r10w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r10b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;调用者保存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%r11&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r11d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r11w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r11b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;调用者保存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%r12&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r12d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r12w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r12b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;被调用者保存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%r13&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r13d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r13w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r13b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;被调用者保存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%r1&lt;/code&gt;4&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r14d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r14w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r14b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;被调用者保存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%r15&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r15d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r15w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%r15b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;被调用者保存&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;二进制、十进制、十六进制对照表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;二进制&lt;/th&gt;
&lt;th&gt;十进制&lt;/th&gt;
&lt;th&gt;十六进制&lt;/th&gt;
&lt;th&gt;二进制&lt;/th&gt;
&lt;th&gt;十进制&lt;/th&gt;
&lt;th&gt;十六进制&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0000&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0001&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1001&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0010&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1010&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0011&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1011&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0100&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1100&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0101&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;1101&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0110&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;1110&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;E&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0111&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;1111&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
</content:encoded></item><item><title>【课程笔记】Udemy - The Complete JavaScript Course 2022: From Zero to Expert!</title><link>https://blog.vonbrank.com/posts/udemy-note-the-complete-javascript-course/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/udemy-note-the-complete-javascript-course/</guid><description>The modern JavaScript course for everyone! Master JavaScript with projects, challenges and theory. Many courses in one!</description><pubDate>Sat, 08 Jan 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;JavaScript 基础&lt;/h2&gt;
&lt;h3&gt;数据、运算与判断&lt;/h3&gt;
&lt;h4&gt;隐式转换&lt;/h4&gt;
&lt;p&gt;当运算符两端数据类型不同时，如 &lt;code&gt;&apos;1&apos; + 2&lt;/code&gt; ，若没有进行显式类型转换，则 JavaScript 解释器将对其做隐式类型转换。JavaScripit 的隐式类型转换常常让初学者感到疑惑，这是因为 JavaScript 不同基本数据类型之间没有明确的优先级关系，不存在所谓的“低级转向高级”，也不存在类似 C/C++ 的重载运算符操作；此外，优先级相同的运算符如 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; 可导致截然不同的隐式转换逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/07/tnfHlk5C2ewQVx1.jpg&quot; alt=&quot;post-udemy-javascript-js-vs-christianity&quot; /&gt;&lt;/p&gt;
&lt;p&gt;即便如此，JavaScript 的的隐式转换规则仍然有迹可循。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt; 运算可将两侧变量隐式转换为 &lt;code&gt;String&lt;/code&gt; 类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;12&quot; + 34; //  -&amp;gt;  &apos;1234&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-&lt;/code&gt; 运算可将两侧变量隐式转换为 &lt;code&gt;Number&lt;/code&gt; 类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;12&quot; - 34; //  -&amp;gt;  -22
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;=, &amp;lt;, &amp;gt;=, &amp;gt;&lt;/code&gt; 可将两侧变量隐式转换为 &lt;code&gt;Number&lt;/code&gt; 类型：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同级运算与隐式转换从左到右顺次进行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5 + 6 + &quot;4&quot; + 9 - 4 - 2; //  -&amp;gt;  1143
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;函数与对象&lt;/h3&gt;
&lt;h4&gt;函数的三种形式&lt;/h4&gt;
&lt;p&gt;JavaScript 有三种主要的函数表示形式，假设我们要定义一个函数，传入一个参数 &lt;code&gt;population&lt;/code&gt; ，返回传入人口参数占世界的百分比，三种形式如下所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;声明形式（Declaration）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function percentageOfWorld1(population) {
    const totalPopulationOfWorld = 7900;
    return `${(population / totalPopulationOfWorld) * 100}%`;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;匿名形式（Expressions）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const percentageOfWorld2 = function (population) {
    const totalPopulationOfWorld = 7900;
    return `${(population / totalPopulationOfWorld) * 100}%`;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;箭头函数（Arrow Function）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const percentageOfWorld3 = (population) =&amp;gt; {
    const totalPopulationOfWorld = 7900;
    return `${(population / totalPopulationOfWorld) * 100}%`;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设全球总人口为 &lt;code&gt;7900M&lt;/code&gt; ，中国人口为 &lt;code&gt;1441M&lt;/code&gt; ，调用结果如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;percentageOfWorld1(1441); //  -&amp;gt;  18.240506329113924%
percentageOfWorld2(1441); //  -&amp;gt;  18.240506329113924%
percentageOfWorld3(1441); //  -&amp;gt;  18.240506329113924%
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;箭头函数的不适用场景&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数作为对象属性时，应该使用匿名函数，而不是箭头函数，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let myCountry = {
    country: &quot;China&quot;,
    capital: &quot;Beijing&quot;,
    language: &quot;Chinese&quot;,
    population: 1300,
    neighbours: [&quot;Japan&quot;, &quot;Russia&quot;, &quot;Korea&quot;, &quot;India&quot;],
    describe: function () {
        console.log(
            `${this.country} has ${this.population} million ${this.language}-speaking people, ${this.neighbours.length} neighbouring countries and a capital called ${this.capital}`
        );
    },

    // 不应该使用箭头函数
    // describe: () =&amp;gt; {
    //     console.log(
    //         `${this.country} has ${this.population} million ${this.language}-speaking people, ${this.neighbours.length} neighbouring countries and a capital called ${this.capital}.`
    //     );
    // },
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;箭头函数作为对象属性时， &lt;code&gt;this&lt;/code&gt; 并非指向对象本身，原型链失效，从而使得用 &lt;code&gt;this&lt;/code&gt; 访问对象属性将导致意外情况。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数组与循环&lt;/h3&gt;
&lt;h2&gt;DOM 树与事件处理&lt;/h2&gt;
&lt;p&gt;HTML 文件在浏览器内被解析为 DOM 树。&lt;/p&gt;
&lt;h3&gt;获取 HTML 元素&lt;/h3&gt;
&lt;p&gt;浏览器的 Web API 提供了 &lt;code&gt;document&lt;/code&gt; 对象，用于对 DOM 树进行操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;document.querySelector()&lt;/code&gt; 可通过传入 CSS 选择器，选择符合要求的第一个元素节点，返回对该元素对象的引用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const body = document.querySelector(&quot;body&quot;); //  选择 body 元素，
const guess = document.querySelector(&quot;.guess&quot;); // 选择第一个 class=&quot;guess&quot; 的元素
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;document.querySelectorAll()&lt;/code&gt; 返回符合选择器的所有元素节点，即一个元素对象数组。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;监听点击事件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;element.addEventListener()&lt;/code&gt; 为 &lt;code&gt;element&lt;/code&gt; 元素对象注册一个监听器，当元素符合监听行为时，立刻执行传入的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 为 check 元素注册点击事件的监听器
check.addEventListener(&quot;click&quot;, () =&amp;gt; {
    statements...
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意到传入的第二个参数是一个函数，这里体现了 JavaScript 中函数和其他对象（&lt;code&gt;object&lt;/code&gt;）地位等同，函数的内容就是其本身 &lt;code&gt;object&lt;/code&gt; 的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;编辑元素 CSS 样式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;element.style.property&lt;/code&gt; 返回对元素某个样式的引用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const message = document.querySelector(&quot;.message&quot;);
message.style.fontSize = &quot;2rem&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意到 CSS 中字体大小属性为 &lt;code&gt;font-size&lt;/code&gt; ，但是这在 JavaScript 中不是合法的变量名，需改为驼峰命名法的 &lt;code&gt;fontSize&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;处理元素的 class&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;element.classList&lt;/code&gt; 返回元素的 &lt;code&gt;class&lt;/code&gt; 列表，可使用 &lt;code&gt;.add()&lt;/code&gt; 与 &lt;code&gt;.remove()&lt;/code&gt; 对其进行增删；使用 &lt;code&gt;.toggle()&lt;/code&gt; 可实现在没有该类时添加该类，有该类时移除该类；&lt;code&gt;.contains()&lt;/code&gt; 判断是否存在某个类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const modal = document.querySelector(&quot;.modal&quot;);
modal.classList.add(&quot;hidden&quot;); //添加 hidden 类
modal.classList.remove(&quot;hidden&quot;); //移除 hidden 类
modal.classList.toggle(&quot;hidden&quot;); //检查是否存在 hidden 类，若不存在则添加，否则移除
modal.classList.contains(&quot;hidden&quot;); //检查是否存在 hidden 类
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;element.className.includes(&quot;class&quot;)&quot;&lt;/code&gt; 同样返回是否存在该类。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const modal = document.querySelector(&quot;.modal&quot;);
modal.className.includes(&quot;hidden&quot;); //检查是否存在 hidden 类
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;JavaScript 幕后解析&lt;/h2&gt;
&lt;h3&gt;总览&lt;/h3&gt;
&lt;p&gt;现代 JavaScript 语言拥有如下特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是一门高级语言&lt;/li&gt;
&lt;li&gt;支持内存回收&lt;/li&gt;
&lt;li&gt;解释型或 JIT 编译型语言&lt;/li&gt;
&lt;li&gt;支持多种编程范式：面向过程、面向对象、函数式&lt;/li&gt;
&lt;li&gt;基于原型与面向对象&lt;/li&gt;
&lt;li&gt;函数与变量同级&lt;/li&gt;
&lt;li&gt;动态类型&lt;/li&gt;
&lt;li&gt;单线程&lt;/li&gt;
&lt;li&gt;非阻塞性事件循环&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;JavaScript 引擎与运行环境&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JavaScript 引擎主要由两个部分组成：调用栈和堆。&lt;/p&gt;
&lt;p&gt;调用栈主要用于存储函数执行的上下文，堆用于存储引用指向的数据实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/15/t3OWJUbCNAM5as7.jpg&quot; alt=&quot;note-javascript-engine&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;”JavaScript 是一门解释型“语言可能是 JavaScript 普遍存在的最大认知误区之一。初出茅庐的 JavaScript 确实如此，但现代浏览器或形如 Node.js 的运行环境使用的是 JIT（Just-in-time）方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/15/6gstqolmwpikK4A.jpg&quot; alt=&quot;note-javascript-jit&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在 JIT 流程中，JavaScript 代码会先被转换成抽象语法树（AST），使用解释器执行，而 Baselines compiler 与 Optimization compiler 会在后台评估每行代码的执行命中率，逐渐执行与传统编译型语言类似的工作，提高运行效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器端的 JavaScript 的运行环境由 JavaScript 引擎，浏览器提供的 Web API ，回调队列构成。JavaScript 引擎和回调队列组成非阻塞性事件循环。 Node.js 中的运行环境则是移除了 Web API ，并添加了一些 Native 层的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/15/TI5jdBVkJflS1p8.jpg&quot; alt=&quot;note-javascript-browser-runtime&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;执行上下文&lt;/h3&gt;
&lt;p&gt;JavaScript 的执行上下文是一个很抽象的概念，其相当于代码执行的一个“环境”，存储了代码执行所需的一些信息，通常包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;环境中的变量&lt;/li&gt;
&lt;li&gt;作用域链&lt;/li&gt;
&lt;li&gt;&lt;code&gt;this&lt;/code&gt; 关键字对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这好比享用外卖 Pizza 时，我们不仅需要从包装盒里取出 Pizza 本身，还需要拿出一次性餐具，必要时取出收据进行检查。包装盒就是“上下文”，Pizza 是我们要执行的对象，餐具和收据是环境中的变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/15/8XmixJAZG6ubSwP.jpg&quot; alt=&quot;note-javascript-execution-context&quot; /&gt;&lt;/p&gt;
&lt;p&gt;运行在 JavaScript 最外层的代码所处的是全局上下文（Global execution context），在编译完成后被创建，并执行其中的代码，之后等待事件循环的回调函数。&lt;/p&gt;
&lt;p&gt;此外，每个函数的执行都会创建自己的上下文。&lt;/p&gt;
&lt;h3&gt;调用栈、作用域与作用域链&lt;/h3&gt;
&lt;p&gt;函数的每一次执行都会创建自己的上下文，并压入调用栈中，执行完后弹出栈顶，并回到调用这个函数的地方。这种设计可以防止上下文丢失。&lt;/p&gt;
&lt;p&gt;作用域指的是变量可被获得（access）的区域（scope），JavaScript 的作用域分为全局作用域、函数作用域、块级作用域。内部作用域可以访问外部作用域的变量，反之未然 ，这便是作用域链。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var&lt;/code&gt; 变量是函数级作用域的，&lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 均是块级。&lt;/p&gt;
&lt;p&gt;作用域链和调用栈没有任何关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/15/Mk15j4fSBDigosC.jpg&quot; alt=&quot;note-javascript-call-stack-and-scope-chain&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;声明提升与临时静默域（TDZ）&lt;/h3&gt;
&lt;p&gt;函数的声明提升，即运行调用写在声明之前，是高级语言解决函数相互引用问题的常见特性。而 &lt;code&gt;var&lt;/code&gt; 类型也变量允许声明则是 JavaScript 早期为支持 &lt;code&gt;first-class function&lt;/code&gt; 所产生的历史遗留问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var&lt;/code&gt; 变量在被声明前引用的值是 &lt;code&gt;undefined&lt;/code&gt; ，表面上看是 JavaScript 将声明提前了，其实不然。实际上 JavaScript 在每个执行上下文之前都会扫描整个作用域，检查那些变量需要做声明提升。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;是否声明提升&lt;/th&gt;
&lt;th&gt;初值&lt;/th&gt;
&lt;th&gt;作用域&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;函数变量&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;函数值本身&lt;/td&gt;
&lt;td&gt;块级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;var&lt;/code&gt; 变量&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;函数级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 变量&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;uninitialized&amp;gt;&lt;/code&gt;，TDZ&lt;/td&gt;
&lt;td&gt;块级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;函数表达式和箭头函数&lt;/td&gt;
&lt;td&gt;取决于是 &lt;code&gt;var&lt;/code&gt; ，&lt;code&gt;let&lt;/code&gt; 还是 &lt;code&gt;const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/15/LMGt75NPgQq2RyW.jpg&quot; alt=&quot;note-javascript-tdz&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var&lt;/code&gt; 类型变量、包括函数在内当前上下文内的对象都是父对象的成员变量&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;this&lt;/code&gt; 关键字&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt; 是每个上下文创建的特殊变量，最常见的用法是，对象的成员函数作用域内的 &lt;code&gt;this&lt;/code&gt; 指向对象本身。&lt;/p&gt;
&lt;p&gt;其他情况下 &lt;code&gt;this&lt;/code&gt; 的指向如表所示。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;指向&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;方法&lt;/td&gt;
&lt;td&gt;调用之的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;单独调用函数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;undefined&lt;/code&gt;（严格模式下）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;箭头函数&lt;/td&gt;
&lt;td&gt;外部作用域的 &lt;code&gt;this&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;监听器&lt;/td&gt;
&lt;td&gt;监听到的 DOM 元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;正则函数与箭头函数&lt;/h3&gt;
&lt;p&gt;声明式函数与匿名函数被称为正则函数（regular function），其与箭头函数的区别主要在 &lt;code&gt;this&lt;/code&gt; 和 &lt;code&gt;arguments&lt;/code&gt; 变量上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const vonbrank = {
    year: 2001,
    calcAge: function () {
        console.log(this);
        console.log(this.year);

        const foo1 = function () {
            console.log(this.year);
            // this == undefined，会报 reference error
        };
        foo1();

        const self = this;
        const foo1 = function () {
            this = self;
            console.log(this.year);
            // 将外部的 this 保存为 self 传进来，可以正常运行
        };
        foo2();


        const foo3 = () =&amp;gt; {
            console.log(this);
            console.log(this.year);
            // 箭头函数本身不不包含 this 对象，沿着作用域链网上找能找到 calcAge 的 this ，即 vonbrank
        };

        foo3();
    },
    greeting: () =&amp;gt; console.log(this),
    //同样的 greeting 内没有 this 参数，沿作用域链向上找到全局作用域，而全局作用域也没有 this 对象，所以输出 undefined
};
vonbrank.calcAge();
vonbrank.greeting();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正则函数拥有 &lt;code&gt;arguments&lt;/code&gt; 变量，这是传入参数构成的数组。箭头函数则没有。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const addExpr = function (a, b) {
    console.log(arguments);
};

const addArrow = (a, b) =&amp;gt; console.log(arguments);

addExpr(2, 5); //[2, 5]
addArrow(2, 5); //reference error
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;原始类型与对象引用&lt;/h3&gt;
&lt;p&gt;JavaScript 中的原始类型（primitive types）有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Number&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;Boolean&lt;/li&gt;
&lt;li&gt;Undefined&lt;/li&gt;
&lt;li&gt;Null&lt;/li&gt;
&lt;li&gt;Symbol&lt;/li&gt;
&lt;li&gt;BigInt&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对象类型（reference types）有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Object 字面量&lt;/li&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等。&lt;/p&gt;
&lt;p&gt;原始类型和对象引用的名称都存储在 JavaScript 引擎的 Identifier 中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/15/lfzIWQMVyEbUwsK.jpg&quot; alt=&quot;note-javascript-primitive-objects&quot; /&gt;&lt;/p&gt;
&lt;p&gt;原始类型的数据值存储在调用栈（CALL STACK）的上下文中，每次修改时，由于调用栈中的数据一旦创建便不可修改。因此会在调用栈中开辟新的内存，存储修改后的值，同时 Identifier 令名称指向新的内存。这便解释了如下代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const age = 30;
const oldAge = age;
age = 27;

console.log(age); //27
console.log(oldAge); //30
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据引用会将数据实际存储在堆区（HEAP），栈区存储指向堆区实例的地址（引用），多个变量名指向同一个引用，修改时也会改变堆区同一个地址的内容。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const me = {
    name: &quot;Jonas&quot;,
    age: 30,
};

const friend = me;
friend.age = 27;

console.log(friend.age); //27
console.log(me.age); //27
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果确实要创建两个值相同，引用不同的对象，可以使用 &lt;code&gt;Object.assign()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const source = { b: 4, c: 5 };
const newSource = Object.assign({}, source);
console.log(newSource); //{ b: 4, c: 5 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但这样只是浅度拷贝，即如果原对象有对象成员，拷贝结果仍然是该成员的引用。实现引用对象的深度拷贝很多时候是一件比较困难的事情，原生 JavaScript 并没有提供深度拷贝方法，可以自己手动实现，或调用外部库。&lt;/p&gt;
&lt;h2&gt;JavaScript 高级编程&lt;/h2&gt;
&lt;p&gt;为方便模拟实际项目的情况，本节默认全局上下文已执行以下语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;use strict&quot;;

// Data needed for a later exercise
const flights =
    &quot;_Delayed_Departure;fao93766109;txl2133758440;11:25+_Arrival;bru0943384722;fao93766109;11:45+_Delayed_Arrival;hel7439299980;fao93766109;12:05+_Departure;fao93766109;lis2323639855;12:30&quot;;

// Data needed for first part of the section
const restaurant = {
    name: &quot;Classico Italiano&quot;,
    location: &quot;Via Angelo Tavanti 23, Firenze, Italy&quot;,
    categories: [&quot;Italian&quot;, &quot;Pizzeria&quot;, &quot;Vegetarian&quot;, &quot;Organic&quot;],
    starterMenu: [&quot;Focaccia&quot;, &quot;Bruschetta&quot;, &quot;Garlic Bread&quot;, &quot;Caprese Salad&quot;],
    mainMenu: [&quot;Pizza&quot;, &quot;Pasta&quot;, &quot;Risotto&quot;],

    openingHours: {
        thu: {
            open: 12,
            close: 22,
        },
        fri: {
            open: 11,
            close: 23,
        },
        sat: {
            open: 0, // Open 24 hours
            close: 24,
        },
    },
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;解构赋值&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数组解构赋值&lt;/p&gt;
&lt;p&gt;数组解构赋值可以实现将数组批量赋值给一组变量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr = [2, 3, 4];
const [x, y, z] = arr;
console.log(x, y, z); //2 3 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以跳过某些元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr = [2, 3, 4];
const [x, , y] = arr;
console.log(x, y); //2 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用于快速交换变量的值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let x = 1,
    y = 2;
[x, y] = [y, x];
console.log(x, y); //2 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接受函数返回多个变量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const order = function () {
    return [2, 5];
};
let [x, y] = order();
console.log(x, y); //2 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;嵌套解构赋值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const nest = [2, 4, [5, 6]];
const [i, , [j, k]] = nest;
console.log(i, j, k);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认解构赋值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const [p = 1, q = 1, r] = [8, 9];
console.log(p, q, r); //8 9 undefined
[p = 1, q = 1, r = 1] = [8, 9];
console.log(p, q, r); //8 9 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象解构赋值&lt;/p&gt;
&lt;p&gt;对象解构赋值和数组类似，括号变成花括号。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const { name, openingHours, categories } = restaurant;
console.log(name, openingHours, categories);
/*
Classico 
Italiano {
    thu: { open: 12, close: 22 },
    fri: { open: 11, close: 23 },
    sat: { open: 0, close: 24 }
} 
[ &apos;Italian&apos;, &apos;Pizzeria&apos;, &apos;Vegetarian&apos;, &apos;Organic&apos; ]
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用不同的变量名。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const {
    name: restaurantName,
    openingHours: hours,
    categories: tags,
} = restaurant;
console.log(restaurantName, hours, tags);
/*
Classico 
Italiano {
    thu: { open: 12, close: 22 },
    fri: { open: 11, close: 23 },
    sat: { open: 0, close: 24 }
} 
[ &apos;Italian&apos;, &apos;Pizzeria&apos;, &apos;Vegetarian&apos;, &apos;Organic&apos; ]
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置默认值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const { menu = [], starterMenu: starters = [] } = restaurant;
console.log(menu, starters); //[] [ &apos;Focaccia&apos;, &apos;Bruschetta&apos;, &apos;Garlic Bread&apos;, &apos;Caprese Salad&apos; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多个变量重新赋值，注意，由于 JavaScript 会将大括号开头的行视作一个新的作用域，因此需要用括号括起来防止歧义。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = 111;
let b = 999;
const obj = { a: 23, b: 7, c: 14 };

({ a, b } = obj);
console.log(a, b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;子对象解构赋值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const { openingHours } = restaurant;
const {
    fri: { open, close },
} = openingHours;
console.log(open, close); // 11 23

//依然可以使用类似方法重命名，节省大量代码
const {
    fri: { open: o, close: c },
} = openingHours;
console.log(o, c); // 11 23
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作为函数参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;restaurant.orderDelivery = function ({
    starterIndex = 1,
    mainIndex = 0,
    time = &quot;20:00&quot;,
    address,
}) {
    console.log(starterIndex, mainIndex, time, address);
};
restaurant.orderDelivery({
    time: &quot;22:30&quot;,
    address: &quot;Via del sole, 21&quot;,
    mainIndex: 2,
    starterIndex: 2,
}); //2 2 22:30 Via del sole, 21
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;扩张运算符 &lt;code&gt;...&lt;/code&gt; 与 &lt;code&gt;rest&lt;/code&gt; 参数运算符&lt;/h3&gt;
&lt;p&gt;JavaScript 中的 &lt;code&gt;...&lt;/code&gt; 运算符用于将可迭代对象（包括数组，字符串，&lt;code&gt;map&lt;/code&gt;，&lt;code&gt;set&lt;/code&gt; 等）分解为一组单个元素，这些元素是原对象的浅层拷贝。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const name = &quot;vonbrank&quot;;
const letters = [...name, &quot; &quot;, &quot;.s&quot;];
console.log(letters);
//[&apos;v&apos;, &apos;o&apos;, &apos;n&apos;, &apos;b&apos;, &apos;r&apos;, &apos;a&apos;, &apos;n&apos;, &apos;k&apos;, &apos; &apos;, &apos;.s&apos;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;合并数组。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr = [7, 8, 9];
const newArr = [1, 2, ...arr];
console.log(newArr); //[1, 2, 7, 8, 9]
console.log(...arr); //[7, 8, 9]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作为函数参数传递。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;restaurant.orderPasta = function (ing1, ing2, ing3) {
    console.log(ing1, ing2, ing3);
};

const ingredients = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
restaurant.orderPasta(...ingredients); // a b c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rest&lt;/code&gt; 参数运算符和 &lt;code&gt;...&lt;/code&gt; 运算符写法几乎一致，但是却是执行相反的操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const [a, b, ...others] = [1, 2, 3, 4, 5];
console.log(a, b, others); //1 2 [ 3, 4, 5 ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与 &lt;code&gt;...&lt;/code&gt; 运算符配合使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const [pizza, , risotto, ...otherFoods] = [
    ...restaurant.mainMenu,
    ...restaurant.starterMenu,
];
console.log(pizza, risotto, otherFoods); //Pizza Risotto [ &apos;Focaccia&apos;, &apos;Bruschetta&apos;, &apos;Garlic Bread&apos;, &apos;Caprese Salad&apos; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造能处理任意参数的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const add = function (...numbers) {
    let sum = 0;
    for (let number of numbers) {
        sum += number;
    }
    console.log(sum);
};

add(2, 4); //6
add(2, 5, 8, 10); //25
add(1, 2, 3, 5, 7, 13, 17); //48
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一个函数使用 &lt;code&gt;rest&lt;/code&gt; 参数的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;restaurant.orderPizza = function (mainIngredient, ...otherIngredients) {
    console.log(mainIngredient);
    console.log(otherIngredients);
};

restaurant.orderPizza(&quot;mushrooms&quot;, &quot;onion&quot;, &quot;olives&quot;, &quot;spinach&quot;); //[ &apos;onion&apos;, &apos;olives&apos;, &apos;spinach&apos; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;逻辑短路与分配运算符&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;，&lt;code&gt;||&lt;/code&gt;，&lt;code&gt;??&lt;/code&gt; 可以实现逻辑短路。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;||&lt;/code&gt; 划分的语句返回第一个真值语句的值，如果都是假值，则返回最后一个。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(3 || &quot;vonbrank&quot;); //3
console.log(false || 0); //0
console.log(null || undefined); //undefiend
console.log(undefined || null); //null

console.log(0 || null || undefined || &quot;&quot; || &quot;hello&quot; || 23);
// hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种操作可以检测并初始化变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;restaurant.numGuests = 20;

//方案1
const guests1 = restaurant.numGuests ? restaurant.numGuests : 10;
console.log(guests1); //20

//方案2
const guests2 = restaurant.numGuests || 10;
console.log(guests2); //20

//相比之下使用短路运算符更方便。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 与 &lt;code&gt;||&lt;/code&gt; 相反，其返回第一个为假值的语句的返回值，如果都是真值，则返回最后一个。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&quot;vonbrank&quot; &amp;amp;&amp;amp; false);
console.log(0 &amp;amp;&amp;amp; &quot;vonbrank&quot;);
console.log(7 &amp;amp;&amp;amp; &quot;vonbrank&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;??&lt;/code&gt; 与 &lt;code&gt;||&lt;/code&gt; 几乎一样，但是它只会跳过 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; ， &lt;code&gt;0&lt;/code&gt; 、 &lt;code&gt;&quot;&quot;&lt;/code&gt; 、 &lt;code&gt;false&lt;/code&gt; 不受影响。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;restaurant.numGuests = null;
const guests2 = restaurant.numGuests ?? 10;
console.log(guests2); //10

console.log(undefined ?? 0 ?? &quot;hello&quot;); //0
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;短路运算符不仅仅会返回值，被其隔开的每一个语句在短路之前都将被执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (restaurant.orderPizza) {
    restaurant.orderPizza(&quot;mushrooms&quot;, &quot;spinach&quot;);
}

restaurant.orderPizza &amp;amp;&amp;amp; restaurant.orderPizza(&quot;mushrooms&quot;, &quot;spinach&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述 &lt;code&gt;restaurant.orderPizza&lt;/code&gt; 为真值，所以 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 右边的语句被继续执行，实现了 &lt;code&gt;if&lt;/code&gt; 的功能，但需要注意的是，我们不提倡滥用短路运算符乃至放弃使用 &lt;code&gt;if&lt;/code&gt; 语句，因为滥用会影响代码的可读性。&lt;/p&gt;
&lt;p&gt;因此短路运算符的实质是：执行被运算符隔开的每一条语句，直至短路，并返回最后一条语句的返回值。其中， &lt;code&gt;||&lt;/code&gt; 被真值短路，&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 被假值短路，&lt;code&gt;??&lt;/code&gt; 被除了 &lt;code&gt;null&lt;/code&gt; 、 &lt;code&gt;undefined&lt;/code&gt; 外的值短路。&lt;/p&gt;
&lt;p&gt;JavaScript ES2020 提供了全新的逻辑分配符： &lt;code&gt;||=&lt;/code&gt;、&lt;code&gt;&amp;amp;&amp;amp;=&lt;/code&gt;、&lt;code&gt;??=&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可用于化简包含短路运算符的语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;restaurant1.numGuests = restaurant1.numGuests || 10;

restaurant1.numGuests ||= 10;
//等价于 restaurant1.numGuests = restaurant1.numGuests || 10;

restaurant2.numGuests ||= 10;
//等价于 restaurant2.numGuests = restaurant2.numGuests || 10;

console.log(restaurant1.numGuests); //10
console.log(restaurant2.numGuests); //10

restaurant2.owner &amp;amp;&amp;amp;= &quot;&amp;lt;ANONYMOUS&amp;gt;&quot;;
//等价于 restaurant2.owner = restaurant2.owner &amp;amp;&amp;amp; &quot;&amp;lt;ANONYMOUS&amp;gt;&quot;
console.log(restaurant2.owner);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处需要注意，分配符左侧需要是有效左值，即可被赋值的变量。&lt;/p&gt;
&lt;h3&gt;高级循环&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;for-of&lt;/code&gt; 循环&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for-of&lt;/code&gt; 循环写法如下，可以免去自定义循环变量的麻烦：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const menu = [...restaurant.starterMenu, ...restaurant.mainMenu];

for (const item of menu) {
    console.log(item);
}
// Focaccia
// Bruschetta
// Garlic Bread
// Caprese Salad
// Pizza
// Pasta
// Risotto
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;for-of&lt;/code&gt; 依然可以使用索引：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (const [i, item] of menu.entries()) {
    console.log(`${i + 1}. ${item}`);
}
//1. Focaccia
//2. Bruschetta
//3. Garlic Bread
//4. Caprese Salad
//5. Pizza
//6. Pasta
//7. Risotto
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;for-of&lt;/code&gt; 循环也适用于对象：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object.keys()&lt;/code&gt; 可以返回对象关键字的数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (const day of Object.keys(openingHours)) {
    console.log(day);
}
//Thu
//Fri
//Sat
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Object.values()&lt;/code&gt; 可以返回对象值的数组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object.entries()&lt;/code&gt; 返回对象 &lt;code&gt;[key, value]&lt;/code&gt; 的数组。&lt;/p&gt;
&lt;p&gt;一个灵活使用对象迭代器、解构赋值与 &lt;code&gt;for-of&lt;/code&gt; 的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (const [key, { open, close }] of Object.entries(openingHours)) {
    console.log(`On ${key}, we open at ${open} and close at ${close}`);
}
//On Thu, we open at 12 and close at 22
//On Fri, we open at 11 and close at 23
//On Sat, we open at 0 and close at 24
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;增强型对象字面值与可选链&lt;/h3&gt;
&lt;p&gt;JavaScript 对象成员的名称是可计算的，只需要用 &lt;code&gt;[]&lt;/code&gt; 包裹即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const weekdays = [&quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;];

const openingHours = {
    [`${weekdays[4]}`]: {
        open: 12,
        close: 22,
    },
    Fri: {
        open: 11,
        close: 23,
    },
    Sat: {
        open: 0, // Open 24 hours
        close: 24,
    },
};
console.log(openingHours);
/*
{
  Thu: { open: 12, close: 22 },
  Fri: { open: 11, close: 23 },
  Sat: { open: 0, close: 24 }
}
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际项目中常常需要操作一个未知对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(restaurant.openingHours.mon.open);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们不确定 &lt;code&gt;restaurant.openingHours&lt;/code&gt; 是否有 &lt;code&gt;mon&lt;/code&gt; 这个成员，一旦没有，就会报异常。所以通常这么写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (restaurant.openingHours.mon) {
    console.log(restaurant.openingHours.mon.open);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ES6 提供了可选链简化此类代码。&lt;/p&gt;
&lt;p&gt;若不知道某个成员是否存在，可以在其后加一个 &lt;code&gt;?&lt;/code&gt; ，若不存在则直接返回 &lt;code&gt;undefined&lt;/code&gt; ，防止访问形如 &lt;code&gt;undefined.open&lt;/code&gt; 导致异常。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(restaurant.openingHours.mon?.open); //undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可用来判断方法是否存在：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(restaurant.order1?.(0, 1) ?? &quot;Method does not exist&quot;); //Method does not exist
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;判断对象成员是否存在：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const users = [
    { name: &quot;vonbrank&quot;, job: &quot;student&quot; },
    { name: &quot;alice&quot;, job: &quot;Engineer&quot; },
];
console.log(users[0]?.name || &quot;user property does not exist&quot;); ///vonbrank
console.log(users[2]?.name || &quot;user property does not exist&quot;); //user property does not exist
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;code&gt;Map&lt;/code&gt; 和 &lt;code&gt;Set&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;和数学上的 &lt;code&gt;集合&lt;/code&gt; 完全类似， JavaScript 中的 &lt;code&gt;Set&lt;/code&gt; 是一种只允许任何元素出现一次的数据结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const orderSet = new Set([
    &quot;Pizza&quot;,
    &quot;Pasta&quot;,
    &quot;Pizza&quot;,
    &quot;Pizza&quot;,
    &quot;Risotto&quot;,
    &quot;Pasta&quot;,
    &quot;Pizza&quot;,
]);

console.log(orderSet); //Set(3) { &apos;Pizza&apos;, &apos;Pasta&apos;, &apos;Risotto&apos; }
console.log(orderSet.size); //3
console.log(orderSet.has(&quot;Pizza&quot;)); //true
console.log(orderSet.has(&quot;Bread&quot;)); //false

orderSet.add(&quot;Garlic Bread&quot;);
console.log(orderSet); //Set(4) { &apos;Pizza&apos;, &apos;Pasta&apos;, &apos;Risotto&apos;, &apos;Garlic Bread&apos; }
orderSet.delete(&quot;Risotto&quot;);
// orderSet.clear();
console.log(orderSet); //Set(3) { &apos;Pizza&apos;, &apos;Pasta&apos;, &apos;Garlic Bread&apos; }

//Set 是可迭代对象，可使用 for-of 循环
for (const order of orderSet) {
    console.log(order);
}

//Set 拆解字符串
console.log(new Set(&quot;hello, world!&quot;));
//Set(10) { &apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;o&apos;, &apos;,&apos;, &apos; &apos;, &apos;w&apos;, &apos;r&apos;, &apos;d&apos;, &apos;!&apos; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Map&lt;/code&gt; 可建立其两个元素的配对。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const restaurant3 = new Map();

restaurant3.set(&quot;name&quot;, &quot;origus&quot;);
restaurant3.set(1, &quot;Italy&quot;);
restaurant3.set(2, &quot;Franch&quot;);
restaurant3
    .set(&quot;categories&quot;, [&quot;Italian&quot;, &quot;Pizzeria&quot;, &quot;Vegetarian&quot;, &quot;Organic&quot;])
    .set(&quot;open&quot;, &quot;11&quot;)
    .set(&quot;close&quot;, &quot;23&quot;)
    .set(true, &quot;we are open&quot;)
    .set(false, &quot;we are closed&quot;);

console.log(restaurant3);
/*
Map(8) {
  &apos;name&apos; =&amp;gt; &apos;origus&apos;,
  1 =&amp;gt; &apos;Italy&apos;,
  2 =&amp;gt; &apos;Franch&apos;,
  &apos;categories&apos; =&amp;gt; [ &apos;Italian&apos;, &apos;Pizzeria&apos;, &apos;Vegetarian&apos;, &apos;Organic&apos; ],
  &apos;open&apos; =&amp;gt; &apos;11&apos;,
  &apos;close&apos; =&amp;gt; &apos;23&apos;,
  true =&amp;gt; &apos;we are open&apos;,
  false =&amp;gt; &apos;we are closed&apos;
}
*/

console.log(restaurant3.get(&quot;name&quot;)); //origus
restaurant3.delete(2);
console.log(restaurant3);

console.log([...restaurant3.entries()]);
/*
[
  [ &apos;name&apos;, &apos;origus&apos; ],
  [ 1, &apos;Italy&apos; ],
  [ &apos;categories&apos;, [ &apos;Italian&apos;, &apos;Pizzeria&apos;, &apos;Vegetarian&apos;, &apos;Organic&apos; ] ],
  [ &apos;open&apos;, &apos;11&apos; ],
  [ &apos;close&apos;, &apos;23&apos; ],
  [ true, &apos;we are open&apos; ],
  [ false, &apos;we are closed&apos; ]
]
*/

console.log(restaurant3.has(&quot;categories&quot;)); //true
console.log(restaurant3.size); //7
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;字符串操作&lt;/h3&gt;
&lt;p&gt;JavaScript 提供许多操作字符串的方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;索引搜索与切片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const airline = &quot;TAP Air Portugal&quot;;
const plane = &quot;A320&quot;;

console.log(plane[0]); //A
console.log(&quot;B747&quot;[0]); //B

//搜索字符串第一个索引位置，找不到返回 -1
console.log(airline.indexOf(&quot;Portugal&quot;)); //10

//搜索字符串最后一个索引位置
console.log(airline.lastIndexOf(&quot;r&quot;)); //8

//.slice 用于字符串切片
console.log(airline.slice(5)); //ir Portugal
console.log(airline.slice(4, 7)); //Air

//字符串切片结合索引位置实现切片第一个单词
console.log(airline.slice(0, airline.indexOf(&quot; &quot;))); //TAP
//切片最后一个单词
console.log(airline.slice(airline.lastIndexOf(&quot; &quot;) + 1)); //Portugal

//负数切片表示倒数位置
console.log(airline.slice(-2)); //al
console.log(airline.slice(1, -1)); //AP Air Portuga
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例：判断座位是不是在中间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const checkMiddleSeat = function (seat) {
    //B and E are middle seats
    const s = seat.slice(-1);
    if (s === &quot;B&quot; || s === &quot;E&quot;) {
        console.log(&quot;You get a middle seat.&quot;);
    } else {
        console.log(&quot;You got lucky.&quot;);
    }
};

checkMiddleSeat(&quot;11B&quot;); //You get a middle seat.
checkMiddleSeat(&quot;23C&quot;); //You got lucky.
checkMiddleSeat(&quot;3E&quot;); //You get a middle seat.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大小写转换、去除空白字符、替换、前后缀判断&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const airline = &quot;TAP Air Portugal&quot;;

//大小写转换
console.log(airline.toUpperCase());
console.log(airline.toLowerCase());

//字符串格式化转为首字母大写
const passenger = &quot;vONBrNk&quot;;
const passengerLower = passenger.toLowerCase();
const passengerCorrect =
    passenger[0].toUpperCase() + passengerLower.slice(1);
console.log(passengerCorrect);

//格式化邮箱，去除末尾回车字符
const email = &quot;hello@vonbrank.com&quot;;
const emailLogin = &quot;HelLo@vOnBRnk.CoM \n&quot;;
const emailLower = emailLogin.toLowerCase();
const emailTrimmed = emailLower.trim();
console.log(emailTrimmed);

//字符串方法均返回新字符串引用，因此可以连续调用
const emailNormalized = emailLogin.toLowerCase().trim();
console.log(emailNormalized);
console.log(emailTrimmed === emailNormalized);

// .replace(d, t) 可以把第一个 d 替换为 t
const priceGB = &quot;288,97￡&quot;;
const priceUS = priceGB.replace(&quot;￡&quot;, &quot;$&quot;).replace(&quot;,&quot;, &quot;.&quot;);
console.log(priceUS);

const announcements =
    &quot;All passengers come to boarding door 23. Boarding door 23!&quot;;
console.log(announcements.replace(&quot;door&quot;, &quot;gate&quot;));

//ReplaceAll 是 ES2021 新特性
console.log(announcements.replaceAll(&quot;door&quot;, &quot;gate&quot;));

//使用正则表达式可以实现仅用 replace 方法替换所有字符串
console.log(announcements.replace(/door/g, &quot;gate&quot;));

const plane = &quot;Airbus A320neo&quot;;
console.log(plane.includes(&quot;A320&quot;)); //true
console.log(plane.includes(&quot;Boeing&quot;)); //false
// console.log(plane.startsWith(&quot;A3&quot;)); //true
console.log(plane.startsWith(&quot;Air&quot;)); //false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个例子，实现违禁品判断：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (plane.startsWith(&quot;Airbus&quot;) &amp;amp;&amp;amp; plane.endsWith(&quot;neo&quot;)) {
    console.log(&quot;Part of the new Airbus family&quot;);
}

const checkBaggage = function (items) {
    const baggage = items.toLowerCase();
    if (baggage.includes(&quot;knife&quot;) || baggage.includes(&quot;gun&quot;)) {
        console.log(&quot;You are not allowed on board.&quot;);
    } else console.log(&quot;Welcome aboard.&quot;);
};

checkBaggage(&quot;I have a laptop, some Food and a pocket Knife.&quot;);
checkBaggage(&quot;Socks and camera&quot;);
checkBaggage(&quot;Got some snacks and a gun for protection&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符串分割与合并、追加与扩充、倍增&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//split 用来分割字符串，传入需要分割的字符
console.log(&quot;a+very+nice+string&quot;.split(&quot;+&quot;));
//[ &apos;a&apos;, &apos;very&apos;, &apos;nice&apos;, &apos;string&apos; ]

console.log(&quot;von brank&quot;.split(&quot; &quot;));
//[ &apos;von&apos;, &apos;brank&apos; ]

const [firstName, lastName] = &quot;von brank&quot;.split(&quot; &quot;);
console.log(firstName, lastName);

//join 可将数组里的字符串用传入字符连接
const newName = [&quot;Mr.&quot;, firstName, lastName.toUpperCase()].join(&quot; &quot;);
console.log(newName); //  Mr. von BRANK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个将首字母转大写的例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const capitalizeName = function (name) {
    const names = name.split(&quot; &quot;);
    const capitalizedName = [];
    for (const n of names) {
        // n[0]  &amp;amp;&amp;amp; capitalizedName.push(n[0].toUpperCase() + n.slice(1));
        n[0] &amp;amp;&amp;amp; capitalizedName.push(n.replace(n[0], n[0].toUpperCase()));
    }
    return capitalizedName.join(&quot; &quot;);
};

const passenger = &quot;jassica ann smith davis&quot;;
console.log(capitalizeName(passenger));
//Jassica Ann Smith Davis
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;padStart&lt;/code&gt; 与 &lt;code&gt;padEnd&lt;/code&gt; 可以实现在字符串前后或填充字符至指定长度：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const message = &quot;Go to gate 23&quot;;
console.log(message.padStart(25, &quot;+&quot;));
//++++++++++++Go to gate 23
console.log(&quot;vonbrank&quot;.padEnd(23, &quot;+&quot;));
//vonbrank+++++++++++++++
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个创建掩码的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const maskCreditCard = function (number) {
    const str = String(number);
    const last = str.slice(-4);
    return last.padStart(str.length, &quot;*&quot;);
};

console.log(maskCreditCard(14285731415926));
//**********5926
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;string.repeat(n)&lt;/code&gt; 可以实现将 &lt;code&gt;string&lt;/code&gt; 重复 &lt;code&gt;n&lt;/code&gt; 次&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const message2 = &quot;Bad weather... All departures delayed...\n&quot;;
console.log(message2.repeat(5));
/*
Bad weather... All departures delayed...
Bad weather... All departures delayed...
Bad weather... All departures delayed...
Bad weather... All departures delayed...
Bad weather... All departures delayed...
*/

const planesInLine = function (n) {
    console.log(`There are ${n} planes in line. ${&quot;✈️&quot;.repeat(n)}`);
};

planesInLine(5); //There are 5 planes in line. ✈️✈️✈️✈️✈️
planesInLine(3); //There are 3 planes in line. ✈️✈️✈️
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;深入理解 JavaScript 函数&lt;/h2&gt;
&lt;h3&gt;默认参数与引用传递&lt;/h3&gt;
&lt;p&gt;ES6 的新特性之一就是允许函数设置默认参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const bookings = [];
const createBooking = function (
    flightNum,
    numPassengers = 1,
    price = 100 * numPassengers
) {
    //ES5 way
    // numPassengers ||= 1;
    // price ||= 100;
    const booking = {
        flightNum,
        numPassengers,
        price,
    };
    console.log(booking);
    bookings.push(booking);
};

createBooking(&quot;CZ6369&quot;);
createBooking(&quot;CZ6371&quot;, undefined, 200);
createBooking(&quot;CZ6371&quot;, 10, 399);
/*
{ flightNum: &apos;CZ6369&apos;, numPassengers: 1, price: 100 }
{ flightNum: &apos;CZ6371&apos;, numPassengers: 1, price: 200 }
{ flightNum: &apos;CZ6371&apos;, numPassengers: 10, price: 399 }
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数参数如果是基本类型，则传入值，对象传入引用，因此在函数内修改对象将使得原对象被修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const flight = &quot;CZ6371&quot;;
const vonbrank = {
    name: &quot;Von Brank&quot;,
    passport: 1234567,
};

const checkIn = function (flightNum, passenger) {
    flightNum = &quot;CZ6666&quot;;
    passenger.name = &quot;Mr.&quot; + passenger.name;

    if (passenger.passport === 1234567) {
        console.log(&quot;check in&quot;);
    } else console.log(&quot;wrong passport&quot;);
};

checkIn(flight, vonbrank);
console.log(flight, vonbrank);
// CZ6371 { name: &apos;Mr.Von Brank&apos;, passport: 1234567 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;高阶函数与回调函数&lt;/h3&gt;
&lt;p&gt;JavaScript 的重要特性之一就是所谓的 Firt-Class Function ，即函数与普通变量同等看待，有 First-Class Function 便有 High Order Function&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const oneWord = function (str) {
    return str.replace(/ /g, &quot;&quot;).toLowerCase();
};

const upperFirstWord = function (str) {
    const [first, ...other] = str.split(&quot; &quot;);
    return [first.toUpperCase(), ...other].join(&quot; &quot;);
};

const transformer = function (str, fn) {
    console.log(`Original string: ${str}`);
    console.log(`Transformed string: ${fn(str)}`);

    console.log(`Transformed by: ${fn.name}`);
};

transformer(&quot;JavaScript is the best language!&quot;, upperFirstWord);
/*
Original string: JavaScript is the best language!
Transformed string: JAVASCRIPT is the best language!
Transformed by: upperFirstWord
*/

transformer(&quot;JavaScript is the best language!&quot;, oneWord);
/*
Original string: JavaScript is the best language!
Transformed string: javascriptisthebestlanguage!
Transformed by: oneWord
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个例子展示了 &lt;code&gt;transformer&lt;/code&gt; 接收一个 &lt;code&gt;string&lt;/code&gt; 和一个 &lt;code&gt;fn&lt;/code&gt; ，&lt;code&gt;transformer&lt;/code&gt; 不在乎 &lt;code&gt;fn&lt;/code&gt; 将以怎样的方式处理 &lt;code&gt;string&lt;/code&gt; ，只需要 &lt;code&gt;fn&lt;/code&gt; 接收 &lt;code&gt;str&lt;/code&gt; 处理并返回一个值即可， &lt;code&gt;transformer&lt;/code&gt; 内部将调用 &lt;code&gt;fn&lt;/code&gt; 传入 &lt;code&gt;string&lt;/code&gt; 并执行。&lt;/p&gt;
&lt;p&gt;这里的 &lt;code&gt;fn&lt;/code&gt; 便是所谓的回调函数（call back function） ，意思是把函数当作值传入，稍后再调用。&lt;/p&gt;
&lt;p&gt;JavaScript 总是以回调的形式执行函数；&lt;code&gt;forEach&lt;/code&gt;、&lt;code&gt;addEventListener&lt;/code&gt; 也是接受回调函数的高阶函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//JavaScript used callback all the time
const high5 = function (item) {
    console.log(&quot;Hooray!&quot;);
    console.log(item);
};

document.body.addEventListener(&quot;click&quot;, high5);

[&quot;VonBrank&quot;, &quot;Alice&quot;, &quot;Bob&quot;, &quot;Cathy&quot;].forEach(high5);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;code&gt;call&lt;/code&gt;、&lt;code&gt;apply&lt;/code&gt; 与 &lt;code&gt;bind&lt;/code&gt; 方法&lt;/h3&gt;
&lt;p&gt;通常，对对象的成员函数，我们可以用 &lt;code&gt;.&lt;/code&gt; 运算符来直接执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const nanHang = {
    airline: &quot;nanHang&quot;,
    iataCode: &quot;CZ&quot;,
    bookings: [],
    book: function (flightNum, passengerName) {
        console.log(
            `${passengerName} booked a seat on ${this.airline} flight ${this.iataCode}${flightNum}.`
        );
        this.bookings.push({
            flight: `${this.iataCode}${flightNum}`,
            name: passengerName,
        });
    },
};

nanHang.book(&quot;6371&quot;, &quot;VonBrank&quot;);
nanHang.book(&quot;6317&quot;, &quot;Smith&quot;);
console.log(nanHang);
/*
VonBrank booked a seat on nanHang flight CZ6371.
Smith booked a seat on nanHang flight CZ6317.
{
  airline: &apos;nanHang&apos;,
  iataCode: &apos;CZ&apos;,
  bookings: [
    { flight: &apos;CZ6371&apos;, name: &apos;VonBrank&apos; },
    { flight: &apos;CZ6317&apos;, name: &apos;Smith&apos; }
  ],
  book: [Function: book]
}
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前文提到过，函数执行上下文中的 &lt;code&gt;this&lt;/code&gt; 在不同调用条件下可能是不一样的。&lt;/p&gt;
&lt;p&gt;如果我们想要把方法保存到另外的变量里，单独执行将导致 &lt;code&gt;this&lt;/code&gt; 变成 &lt;code&gt;defined&lt;/code&gt;，除了手动传入 &lt;code&gt;this&lt;/code&gt; 参数，我们没有其他方法指定 &lt;code&gt;this&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因此 JavaScript 提供了 &lt;code&gt;call&lt;/code&gt;，&lt;code&gt;apply&lt;/code&gt;和&lt;code&gt;bind&lt;/code&gt; 三种方法便于开发者手动指定 &lt;code&gt;this&lt;/code&gt; 变量的值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;call&lt;/code&gt; 方法的第一个参数指定的的是函数执行时的 &lt;code&gt;this&lt;/code&gt; 变量，之后依照调用函数的写法用逗号隔开所有传入的参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const chuanHang = {
    airline: &quot;chuangHang&quot;,
    iataCode: &quot;3U&quot;,
    bookings: [],
};

const book = nanHang.book;

book.call(chuanHang, &quot;3456&quot;, &quot;Steven&quot;);
console.log(chuanHang);
/*
Steven booked a seat on chuangHang flight 3U3456.
{
  airline: &apos;chuangHang&apos;,
  iataCode: &apos;3U&apos;,
  bookings: [ { flight: &apos;3U3456&apos;, name: &apos;Steven&apos; } ]
}

*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;apply&lt;/code&gt; 方法与 &lt;code&gt;call&lt;/code&gt; 略有不同，对于函数原本接收的参数，需要以数组的形式传入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const shenHang = {
    airline: &quot;Shenzhen Airline&quot;,
    iataCode: &quot;ZH&quot;,
    bookings: [],
};

book.call(shenHang, 538, &quot;Alice&quot;);
console.log(shenHang);

const flightData = [583, &quot;Cooper&quot;];
book.apply(shenHang, flightData);
console.log(shenHang);
/*
Alice booked a seat on Shenzhen Airline flight ZH538.
Cooper booked a seat on Shenzhen Airline flight ZH583.
{
  airline: &apos;Shenzhen Airline&apos;,
  iataCode: &apos;ZH&apos;,
  bookings: [
    { flight: &apos;ZH538&apos;, name: &apos;Alice&apos; },
    { flight: &apos;ZH583&apos;, name: &apos;Cooper&apos; }
  ]
}
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bind&lt;/code&gt; 将 &lt;code&gt;this&lt;/code&gt; 等参数的绑定与函数的执行分开：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const book3U = book.bind(chuanHang);
book3U(1234, &quot;Bob&quot;); //Bob booked a seat on chuangHang flight 3U1234.

const bookCZ6371 = book.bind(nanHang, 6371);
bookCZ6371(&quot;Cathy&quot;); //Cathy booked a seat on nanHang flight CZ6371.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本例中 &lt;code&gt;const book3U = book.bind(chuanHang);&lt;/code&gt; 将 &lt;code&gt;book3U&lt;/code&gt; 的 &lt;code&gt;this&lt;/code&gt; 变量永久钦定为 &lt;code&gt;chuanHang&lt;/code&gt; 之后单独执行 &lt;code&gt;book3U&lt;/code&gt; 时就像直接执行 &lt;code&gt;chuanHang.book&lt;/code&gt; 一样； &lt;code&gt;const bookCZ6371 = book.bind(nanHang, 6371);&lt;/code&gt; 则不仅绑定了 &lt;code&gt;this&lt;/code&gt; 参数，还绑定了 &lt;code&gt;flightNum&lt;/code&gt; 参数，之后 &lt;code&gt;bookCZ6371(&quot;Cathy&quot;)&lt;/code&gt; 相当于原本执行 &lt;code&gt;nanHang.book(6371, &quot;Cathy&quot;);&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bind&lt;/code&gt; 还可以用在 &lt;code&gt;addEventListener&lt;/code&gt; 中传入的回调函数是某个对象的方法，通过 &lt;code&gt;bind&lt;/code&gt; 指定方法的 &lt;code&gt;this&lt;/code&gt; 来防止出错。&lt;/p&gt;
&lt;h3&gt;自执行匿名函数与闭包&lt;/h3&gt;
&lt;p&gt;想要创建一个独立的作用域，执行某些代码块，是编程中常见的需求， ES5 前常使用 Immediately Invoke Function Expression (IIFE) 实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(functino () {

    console.log(`This function executes only once.`);
})();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现代 JavaScript 的做法是使用 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 变量将作用域限制在块级，然后使用单一的大括号创建代码块实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    console.log(`This function executes only once.`);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;闭包（closure）是 JavaScript 中最容易让初学者感到困惑的东西。&lt;/p&gt;
&lt;p&gt;先看一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const greet = function (greeting) {
    return function (name) {
        console.log(`${greeting} ${name}!`);
    };
};

const greeterHey = greet(&quot;Hey&quot;);
greeterHey(&quot;Jonas&quot;); //Hey Jonas
greeterHey(&quot;Von Brank&quot;); //Hey Von Brank

greet(&quot;Hello&quot;)(&quot;Alice&quot;); //Hello Alice

const greetArrow = (greeting) =&amp;gt; (name) =&amp;gt; console.log(`${greeting} ${name}!`);

const greeterArrowHey = greetArrow(&quot;Hey&quot;);
greeterArrowHey(&quot;Jonas&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;greeting&lt;/code&gt; 接收一个参数，返回的却是一个函数；本例中 &lt;code&gt;greeterHey&lt;/code&gt; 就是一个从 &lt;code&gt;greet&lt;/code&gt; 返回的函数，既然它是函数，就是可执行的。&lt;/p&gt;
&lt;p&gt;问题在于， 执行 &lt;code&gt;greeterHey&lt;/code&gt; 时需要访问 &lt;code&gt;greet&lt;/code&gt; 函数中的 &lt;code&gt;greeting&lt;/code&gt; 变量，而 &lt;code&gt;greet&lt;/code&gt; 函数的上下文在此时早已结束，被弹出调用栈了，那这里的 &lt;code&gt;greeting&lt;/code&gt; 是哪来的？ What the hell is it?&lt;/p&gt;
&lt;p&gt;实现这一切的便是 JavaScript 的闭包机制！闭包的原理解释如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/22/7fBAHnpctKyQ8i3.jpg&quot; alt=&quot;note-javascript-closure&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果函数返回的是另外一个函数，那么返回的函数会有一个成员变量，名为 &lt;code&gt;closure&lt;/code&gt; ，里面包含了创建这个函数位置所处作用域内的所有变量的引用，当携带闭包的函数被执行时，若任何不在其作用域内的变量被访问，JavaScript 引擎都会先去闭包里搜索该变量，若找不到才接着到作用域链里搜索。&lt;/p&gt;
&lt;p&gt;嵌套的箭头函数也是闭包：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const greetArrow = (greeting) =&amp;gt; (name) =&amp;gt; console.log(`${greeting} ${name}!`);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;数组的使用&lt;/h2&gt;
&lt;h3&gt;数组基础方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;slice&lt;/code&gt; 与 &lt;code&gt;splice&lt;/code&gt; 用于数组切片，与字符串切片类似，不同之处在于， &lt;code&gt;splice&lt;/code&gt; 将直接修改原数组，而 &lt;code&gt;slice&lt;/code&gt; 不会：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;];
console.log(arr.slice(2, 4)); //[ &apos;c&apos;, &apos;d&apos; ]
console.log(arr.slice(3)); //[ &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos; ]
console.log(arr.slice(-1)); //[ &apos;g&apos; ]
console.log(arr.slice(1, -2)); //[ &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]
console.log(arr.slice());
/*
[
  &apos;a&apos;, &apos;b&apos;, &apos;c&apos;,
  &apos;d&apos;, &apos;e&apos;, &apos;f&apos;,
  &apos;g&apos;
]
*/

arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;];
console.log(arr.splice(2)); // [&quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]
console.log(arr); // [&quot;a&quot;, &quot;b&quot;]
//splice 会移除元素中中使用 splice 切片的部分
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;reverse&lt;/code&gt; 用于数组翻转，会直接修改原数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;];
const arr2 = [&quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;];
console.log(arr2.reverse()); //[ &apos;l&apos;, &apos;k&apos;, &apos;j&apos;, &apos;i&apos;, &apos;h&apos; ]
console.log(arr2); //[ &apos;l&apos;, &apos;k&apos;, &apos;j&apos;, &apos;i&apos;, &apos;h&apos; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;concat&lt;/code&gt; 用于拼接数组， &lt;code&gt;a.concat(b)&lt;/code&gt; 表示将 &lt;code&gt;b&lt;/code&gt; 拼接在 &lt;code&gt;a&lt;/code&gt; 后面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;];
const arr2 = [&quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;];
const letters = arr.concat(arr2);
console.log(letters);
/*
[
  &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;,
  &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;,
  &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;
]
*/
console.log([...arr, ...arr2]);
/*
[
  &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;,
  &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;,
  &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;
]
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;join&lt;/code&gt; 可以用指定符号连接数组中所有元素，并连接成字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;];
console.log(arr.join(&quot;-&quot;)); //a-b-c-d-e-f-g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全新的 &lt;code&gt;.at()&lt;/code&gt; 函数可以用于取代数组下标， &lt;code&gt;arr.at(i)&lt;/code&gt; 返回第 &lt;code&gt;i&lt;/code&gt; 个元素：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr = [23, 11, 64];
console.log(arr[0]); //23
console.log(arr.at(0)); //23
console.log(arr[arr.length - 1]); //64
console.log(arr.slice(-1)[0]); //64
console.log(arr.at(-1)); //64

//字符串也可以用
console.log(&quot;vonbrank&quot;.at(-1)); // &apos;k&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;code&gt;forEach&lt;/code&gt; 方法&lt;/h3&gt;
&lt;p&gt;遍历数组进行某种操作是一种常见的需求，通常使用 &lt;code&gt;for&lt;/code&gt; 循环实现， JavaScript 提供了 &lt;code&gt;forEach&lt;/code&gt; 函数简化代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr = [&quot;USD&quot;, &quot;EUR&quot;, &quot;GBP&quot;, &quot;CNY&quot;, &quot;USD&quot;, &quot;EUR&quot;, &quot;USD&quot;];

arr.forEach((value, i, arr) =&amp;gt; {
    console.log(value, i);
});

for (let i = 0; i &amp;lt; arr.length; i++) console.log(arr[i], i);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出 &lt;code&gt;forEach&lt;/code&gt; 方法传入一个回调函数，接收三个参数：值、索引和数组本身的引用。实现相同的功能 &lt;code&gt;for&lt;/code&gt; 可能需要更多代码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;forEach&lt;/code&gt; 可以直接用于 &lt;code&gt;Set&lt;/code&gt; 和 &lt;code&gt;Map&lt;/code&gt; 等可迭代对象，不同之处只是回调函数的参数而已：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Map&lt;/code&gt;: &lt;code&gt;fn : (value, key, map) =&amp;gt; {}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Set&lt;/code&gt;: &lt;code&gt;fn : (value, value, set) =&amp;gt; {}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意因为 &lt;code&gt;Set&lt;/code&gt; 没有 &lt;code&gt;Array&lt;/code&gt; 中 &lt;code&gt;index&lt;/code&gt; 或 &lt;code&gt;Map&lt;/code&gt; 中 &lt;code&gt;key&lt;/code&gt; 之类的东西，所以传入的都是 &lt;code&gt;value&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;node.insertAdjacentHTML()&lt;/code&gt; 方法可以往 DOM 树的 node 节点中插入文本，这些内容同时更新为新的 DOM 元素：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;movements__row&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;const movementsRow = document.querySelector(&quot;.movements__row&quot;);
const type = &quot;abc&quot;;
const i = 0;
const mov = 1000;
const html = `
    &amp;lt;div class=&quot;movements__type movements__type--${type}&quot;&amp;gt;
        ${i + 1} ${type.toUpperCase()}
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;movements__value&quot;&amp;gt;${mov}€&amp;lt;/div&amp;gt;
`;
movementsRow.insertAdjacentHTML(`afterbegin`, html);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;movements__row&quot;&amp;gt;
    &amp;lt;div class=&quot;movements__type movements__type--ABC&quot;&amp;gt;1 ABC&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;movements__value&quot;&amp;gt;1000€&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;insertAdjacentHTML&lt;/code&gt; 本身第一个参数有四种取值，除了 &lt;code&gt;afterbegin&lt;/code&gt; 外，其他用法效果如图所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- beforebegin --&amp;gt;
&amp;lt;p&amp;gt;
    &amp;lt;!-- afterbegin --&amp;gt;
    foo
    &amp;lt;!-- beforeend --&amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;!-- afterend --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;JavaScriip 实现面向对象编程 (OOP)&lt;/h2&gt;
&lt;p&gt;传统 OOP 中，我们使用 &lt;code&gt;class&lt;/code&gt; 定义对象的模板，但是 JavaScript 中没有真正的 &lt;code&gt;class&lt;/code&gt; ，即使是 ES6 中的 &lt;code&gt;class&lt;/code&gt; 关键字也不过是语法糖而已，JavaScript 使用原型（prototype）来实现面向对象编程。&lt;/p&gt;
&lt;h3&gt;构造函数与 &lt;code&gt;new&lt;/code&gt; 运算符&lt;/h3&gt;
&lt;p&gt;JavaScript 中的对象构造函数只能用显式声明函数和匿名函数表达式定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const Person = function (firstName, birthYear) {
    this.firstName = firstName;
    this.birthYear = birthYear;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意不能使用箭头函数，因为众所周知箭头函数没有 &lt;code&gt;this&lt;/code&gt; 变量。&lt;/p&gt;
&lt;p&gt;当拥有构造函数后，我们就拥有了创建对象的模板，基于模板创建对象的过程称为“实例化”：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const jonas = new Person(&quot;Jonas&quot;, 1991);
console.log(jonas); //Person { firstName: &apos;Jonas&apos;, birthYear: 1991 }

const jassica = new Person(&quot;Jassica&quot;, 2017);
const jack = new Person(&quot;Jack&quot;, 1975);
console.log(jassica, jack); //Person { firstName: &apos;Jassica&apos;, birthYear: 2017 } Person { firstName: &apos;Jack&apos;, birthYear: 1975 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用 &lt;code&gt;instanceof&lt;/code&gt; 关键字判断一个对象是不是某个构造函数的实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(jonas instanceof Person); //true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;对象原型 (Prototype)&lt;/h3&gt;
&lt;p&gt;有了对象，自然就要定义操作对象的方法，我们虽然可以这样定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const Person = function (firstName, birthYear) {
    this.firstName = firstName;
    this.birthYear = birthYear;
    this.calcAge = function () {
        return 2037 - birthYear;
    };
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是实际项目中千万不要这样做，否则每次实例化都会创建一个新的函数对象，造成极大的性能浪费。&lt;/p&gt;
&lt;p&gt;JavaScript 使用原型来定义方法。&lt;/p&gt;
</content:encoded></item><item><title>【课程笔记】Udemy - Advanced CSS and Sass: Flexbox, Grid, Animations and More!</title><link>https://blog.vonbrank.com/posts/udemy-note-advanced-css-and-sass/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/udemy-note-advanced-css-and-sass/</guid><description>The most advanced and modern CSS course on the internet: master flexbox, CSS Grid, responsive design, and so much more.</description><pubDate>Fri, 07 Jan 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;CSS 幕后解析&lt;/h2&gt;
&lt;h3&gt;概述&lt;/h3&gt;
&lt;h3&gt;层叠与优先级&lt;/h3&gt;
&lt;h3&gt;数值处理&lt;/h3&gt;
&lt;h3&gt;继承&lt;/h3&gt;
&lt;h3&gt;盒模型&lt;/h3&gt;
&lt;h3&gt;架构、组件与 BEM 命名法&lt;/h3&gt;
&lt;p&gt;项目的可维护性与可扩展性应满足这些要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;干净&lt;/li&gt;
&lt;li&gt;模块化&lt;/li&gt;
&lt;li&gt;可重用&lt;/li&gt;
&lt;li&gt;可扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体来说，工作流应呈现以下形态：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;THINK&lt;/li&gt;
&lt;li&gt;BUILD&lt;/li&gt;
&lt;li&gt;ARCHITECT&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;THINK | 布局与组件设计&lt;/h4&gt;
&lt;h4&gt;BUILD | 使用 BEM 命名法&lt;/h4&gt;
&lt;h4&gt;ARCHITECT | 使用 7-1 设计模式&lt;/h4&gt;
&lt;p&gt;7-1 设计模式为基于 CSS 预处理器（后面的章节将介绍 SASS 预处理器）的前端设计提供了一种文件布局思路，目的在于提升代码的可重用性、可维护性可扩展性。&lt;/p&gt;
&lt;p&gt;具体来说，所有 Sass 文件均放在 &lt;code&gt;sass/&lt;/code&gt; 目录内，其中包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;7&lt;/strong&gt; 个子文件夹，用于定义各类组件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1&lt;/strong&gt; 个 &lt;code&gt;main.scss&lt;/code&gt; 文件用于导入与组织 7 个文件夹内的组件，并编译成最终的 &lt;code&gt;css/style.css&lt;/code&gt; 文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这 &lt;strong&gt;7&lt;/strong&gt; 个文件夹的名称和功能分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;base/&lt;/code&gt;
定义页面的基本元素属性，如：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_base.scss&lt;/code&gt;：定义 &lt;code&gt;html&lt;/code&gt;、&lt;code&gt;body&lt;/code&gt;等元素的基本属性，响应式设计的设置等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_typography.scss&lt;/code&gt;：定义排版、标题的样式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_utilities.scss&lt;/code&gt;：各种工具类，如 &lt;code&gt;margin-bottom-sm&lt;/code&gt;、&lt;code&gt;grid-vertical-center&lt;/code&gt; 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;components/&lt;/code&gt;
定义各类原子组件的样式等，如：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_btn.scss&lt;/code&gt;：页面按钮样式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;layout/&lt;/code&gt;
定义页面的布局设置：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_grid.scss&lt;/code&gt;：网格系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pages/&lt;/code&gt;
针对每个页面各自布局的特化设置：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_home.scss&lt;/code&gt;：主页。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;themes/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;abstracts/&lt;/code&gt;
包含各类常量与可重用样式：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;variables&lt;/code&gt;：颜色，字体，间隔设置等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mixins&lt;/code&gt;：各种 &lt;code&gt;mixins&lt;/code&gt; 的定义。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;functions&lt;/code&gt;：各种 &lt;code&gt;functions&lt;/code&gt; 的定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vendors/&lt;/code&gt;
包含可能用到的外部库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;SASS 与 NPM 简介&lt;/h2&gt;
&lt;h3&gt;SASS 预处理器&lt;/h3&gt;
&lt;p&gt;SASS 是一种 CSS 预处理器，即对原生 CSS 语法进行扩展，使之具备比 CSS 更强的表达能力，然后编译成标准 CSS ，便于写出简洁明了、可维护性与可扩展性更强的代码。&lt;/p&gt;
&lt;h4&gt;变量与嵌套&lt;/h4&gt;
&lt;p&gt;重复出现的值可以通过变量来定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SCSS：&lt;pre&gt;&lt;code&gt;$color-primary: #f9ed69;
.navigation {
  background-color: $color-primary;
  display: flex;
  list-style: none;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;CSS：&lt;pre&gt;&lt;code&gt;.navigation {
  background-color: #f9ed69;
  display: flex;
  list-style: none;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选择器可以嵌套：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SCSS：&lt;pre&gt;&lt;code&gt;.navigation {
  display: flex;
  list-style: none;
  li {
    text-decoration: none;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;CSS：&lt;pre&gt;&lt;code&gt;.navigation {
  display: flex;
  list-style: none;
}
.navigation li {
  text-decoration: none;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Mixin、Extend 与 Function&lt;/h4&gt;
&lt;p&gt;Mixin 将可重用的若干属性封装在特定代码块内，可用 &lt;code&gt;@include&lt;/code&gt; 调用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SCSS：&lt;pre&gt;&lt;code&gt;@mixin absCenter {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.heading-primary {
  font-size: 5.2rem;
  letter-spacing: -0.2rem;
  @include absCenter;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;CSS：&lt;pre&gt;&lt;code&gt;.heading-primary {
  font-size: 5.2rem;
  letter-spacing: -0.2rem;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Extend 同样用于封装代码，与 Mixin 不同之处在于，其声明名称被替换为 使用 &lt;code&gt;@extend&lt;/code&gt; 引用处的选择器，便于设置多个类的共有默认属性，同时避免覆盖各自的客制化属性设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SCSS：&lt;pre&gt;&lt;code&gt;$color-primary: #f9ed69;
$color-secondary: #f08a5d;

%btn--placeholder {
  padding: 1.2rem 2.4rem;
  border-radius: 100rem;
}

.btn--main {
  background-color: $color-primary;
  @extend %btn--placeholder;
}

.btn--sub {
  background-color: $color-secondary;
  @extend %btn--placeholder;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;CSS：&lt;pre&gt;&lt;code&gt;.btn--sub, .btn--main {
  padding: 1.2rem 2.4rem;
  border-radius: 100rem;
}

.btn--main {
  background-color: #f9ed69;
}

.btn--sub {
  background-color: #f08a5d;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SASS 可以定义和使用函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SCSS:&lt;pre&gt;&lt;code&gt;@function divide($a, $b) {
  @return $a / $b;
}

nav {
  margin: divide(60, 2) * 1px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;CSS:&lt;pre&gt;&lt;code&gt;nav {
  margin: 30px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Minix 中亦可以使用变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SCSS：&lt;pre&gt;&lt;code&gt;$color-primary: #f9ed69;
@mixin style-link-text($color) {
  padding: 1.2rem 2.4rem;
  background-color: $color;
  border-radius: 100rem;
  display: inline-block;
}

a {
  text-decoration: none;
  @include style-link-text($color-primary);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;CSS：&lt;pre&gt;&lt;code&gt;a {
  text-decoration: none;
  padding: 1.2rem 2.4rem;
  background-color: #f9ed69;
  border-radius: 100rem;
  display: inline-block;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;NPM 包管理器&lt;/h3&gt;
&lt;h4&gt;安装 Node.js&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接去&lt;a href=&quot;https://nodejs.org/zh-cn/download/&quot;&gt;官网&lt;/a&gt;下载安装包安装，或者使用 &lt;a href=&quot;https://github.com/coreybutler/nvm-windows/releases&quot;&gt;NVM&lt;/a&gt; 创建虚拟 Node.js 环境即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装完成后注意环境变量设置，并检查一下环境：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;node -v
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;使用 NPM 配置 SASS 环境&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;初始化 Node.js 环境：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据提示配置参数即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装 &lt;code&gt;node-sass&lt;/code&gt; 预处理器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install node-sass --save-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于这是在开发环境下使用 &lt;code&gt;node-sass&lt;/code&gt; ，当工作环境迁移时，我们不可能将生成的 &lt;code&gt;node_modules&lt;/code&gt; 一并拷贝或加入 &lt;code&gt;commit&lt;/code&gt;，因此我们需要添加 &lt;code&gt;--save-dev&lt;/code&gt; 参数，将 &lt;code&gt;node-sass&lt;/code&gt; 添加为依赖项，之后在其他设备上进行开发时，只需要输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install node-sass --save-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可从 &lt;code&gt;npm&lt;/code&gt; 镜像源安装所有依赖项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加 SCSS 编译脚本&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;package.json&lt;/code&gt; 里找到 &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; 字段，修改成如下形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;,
    &quot;compile:sass&quot;: &quot;node-sass sass/main.scss css/style.css -w&quot;
},
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处定义了一个 &lt;code&gt;complie:sass&lt;/code&gt; 脚本，你可以通过：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm run compile:sass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来运行此脚本。&lt;code&gt;sass/main.scss&lt;/code&gt; 与 &lt;code&gt;css/style.css&lt;/code&gt; 分别是编译的源文件和目标文件。 &lt;code&gt;-w&lt;/code&gt; 参数用于监听 SASS 组件的更新情况，每次更新 &lt;code&gt;.scss&lt;/code&gt; 文件都会重新编译。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;code&gt;float-clearfix hack&lt;/code&gt; 布局&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;flex&lt;/code&gt; 布局&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;grid&lt;/code&gt; 布局&lt;/h2&gt;
&lt;h2&gt;响应式设计&lt;/h2&gt;
&lt;h3&gt;先决条件&lt;/h3&gt;
&lt;p&gt;SASS 中的 &lt;code&gt;@media&lt;/code&gt; 也可以嵌套：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SCSS：&lt;pre&gt;&lt;code&gt;html {
  @media (max-width: 1200px) {
    font-size: 62.5%;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;CSS：&lt;pre&gt;&lt;code&gt;@media (max-width: 1200px) {
  html {
    font-size: 62.5%;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 &lt;code&gt;@include&lt;/code&gt; 调用 Mixin 代码块时， &lt;code&gt;@content&lt;/code&gt; 将被替换成调用处的代码块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SCSS：&lt;pre&gt;&lt;code&gt;@mixin respond-phone {
  @media (max-width: 600px) { @content }
}

html {
  @include respond-phone {
    font-size: 50%;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;CSS：&lt;pre&gt;&lt;code&gt;@media (max-width: 600px) {
  html {
    font-size: 50%;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt; 语句用于选择性替换内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SCSS：&lt;pre&gt;&lt;code&gt;@mixin respond($breakpoint) {
    if $breakpoint == phone {
        font-size: 50%;
    }
  
}

html {
  @include respond(phone);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;CSS：&lt;pre&gt;&lt;code&gt;html {
  font-size: 50%;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;使用 SASS 快速实现响应式设计&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;abstracts/mixins&lt;/code&gt; 内声明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
phone: 0 ~ 600px
tab-port: 600px ~ 900px
tab-land: 900px ~ 1200px
desktop(default): 1200px ~ 1800px
big-desktop: 1800px ~ infinity
*/

@mixin respond($breakpoint) {
    @if $breakpoint == phone {
        @media (max-width: 37.5em) { @content }	//37.5em = 600px
    }
    @if $breakpoint == tab-port {
        @media (max-width: 56.25em) { @content }//56.25em = 900px
    }
    @if $breakpoint == tab-land {
        @media (max-width: 75em) { @content }	//75em = 1200px
    }
    @if $breakpoint == big-desktop {
        @media (min-width: 112.5em) { @content }//112.5em = 1800px
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以选中 &lt;code&gt;html&lt;/code&gt; 元素并响应式地设置 &lt;code&gt;font-size&lt;/code&gt; 为例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;html {
    // define what 1rem is
    font-size: 62.5%;	//1rem = 16px * 62.5% = 10px
    
    @include respond(phone) {
        font-size: 37.5%	//1rem = 16px * 37.5% = 6px
    }
    
    @include respond(tab-port) {
        font-size: 50%;	//1rem = 16px * 50% = 8px
    }
    
    @include respond(tab-land) {
        font-size: 56.25%	//1rem = 16px * 56.25% = 9px
    }
    
    @include respond(big-desktop) {
        font-size: 75%		//1rem = 16px * 75% = 12px
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;其他常用技巧&lt;/h2&gt;
</content:encoded></item><item><title>【课程笔记】Udemy - Build Responsive Real-World Websites with HTML and CSS</title><link>https://blog.vonbrank.com/posts/udemy-note-build-responsive-real-world-websites-with-html-and-css/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/udemy-note-build-responsive-real-world-websites-with-html-and-css/</guid><description>Learn modern HTML5, CSS3 and web design by building a stunning website for your portfolio! Includes flexbox and CSS Grid</description><pubDate>Wed, 05 Jan 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;HTML 基础&lt;/h2&gt;
&lt;h2&gt;CSS 基础&lt;/h2&gt;
&lt;h3&gt;CSS 选择器&lt;/h3&gt;
&lt;h4&gt;概述&lt;/h4&gt;
&lt;h4&gt;竞争处理&lt;/h4&gt;
&lt;h3&gt;盒模型&lt;/h3&gt;
&lt;h4&gt;概述&lt;/h4&gt;
&lt;h4&gt;元素定位&lt;/h4&gt;
&lt;h3&gt;伪类&lt;/h3&gt;
&lt;h2&gt;CSS 布局&lt;/h2&gt;
&lt;h3&gt;传统 &lt;code&gt;float-clearfix hack&lt;/code&gt; 布局&lt;/h3&gt;
&lt;h3&gt;&lt;code&gt;flex&lt;/code&gt; 布局&lt;/h3&gt;
&lt;h3&gt;&lt;code&gt;grid&lt;/code&gt; 布局&lt;/h3&gt;
&lt;h2&gt;前端设计原则&lt;/h2&gt;
&lt;h3&gt;选择限制&lt;/h3&gt;
&lt;p&gt;在设计布局时，同一种类的组件使用同一尺寸，不同类不同等级的组件使用不同尺寸，有助于实现层次分明的视觉效果。&lt;/p&gt;
&lt;p&gt;然而，具体实现时，“每种组件尺寸设置为多少合适？”常常是一个令人头疼的问题，例如 “段落字体的大小应该为 &lt;code&gt;18px&lt;/code&gt; 还是 &lt;code&gt;19px&lt;/code&gt; 或是 &lt;code&gt;20px&lt;/code&gt; 呢？”、&quot;如果某个 &lt;code&gt;div&lt;/code&gt; 的高度为 &lt;code&gt;31px&lt;/code&gt; 那为什么不能是 &lt;code&gt;32px&lt;/code&gt; 或 &lt;code&gt;33px&lt;/code&gt; 呢？&quot;。此类问题常常困扰着开发人员和设计师，这也是 Markdown 产生的原因之一。不过 Markdown 文本最终仍然会被解析为 HTML 文本，并使用 CSS 定义样式。&lt;/p&gt;
&lt;p&gt;为解决上述问题，我们引入选择限制（limit choices），从连续的 &lt;code&gt;font-size&lt;/code&gt; 范围内抽取少许离散的点，这些点集产生的集合称为系统（system），比较典型的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;字体系统:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- FONT SIZE SYSTEM (px)
10 / 12 / 14 / 16 / 18 / 20 / 24 / 30 / 36 /
44 / 52 / 62 / 74 / 86 / 98
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;间隔系统&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- SPACING SYSTEM (px)
2 / 4 / 8 / 12 / 16 / 24 / 32 / 48 /
64 / 80 / 96 / 128
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;形式看起来很简单，但是很有用。实际开发时，我们只需要从上述 SYSTEM 里逐一选择数据进行测试，直到选择满意的数据即可。&lt;/p&gt;
&lt;p&gt;如对于较长的段落，&lt;code&gt;font-size&lt;/code&gt; 通常在 &lt;code&gt;20px&lt;/code&gt; 左右，因此我们在 &lt;code&gt;18px&lt;/code&gt;，&lt;code&gt;20px&lt;/code&gt;，&lt;code&gt;24px&lt;/code&gt; 中选择做选择即可，节省了开发时间。&lt;/p&gt;
&lt;h2&gt;组件与布局&lt;/h2&gt;
&lt;h2&gt;响应式设计&lt;/h2&gt;
&lt;h2&gt;Omnifood 项目实战&lt;/h2&gt;
</content:encoded></item><item><title>【OI考古】图论 | 拓扑排序</title><link>https://blog.vonbrank.com/posts/oi-graph-theory-toposort/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/oi-graph-theory-toposort/</guid><pubDate>Mon, 26 Jul 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;对于一个有向无环图（DAG），我们要找出一种顶点的排序方式，使得对于图中任意 $u, v$ ，如果 $u, v$ 之间有一条 $u$ 指向 $v$ 的有向路，则 $u$ 排在 $v$ 的前面。这种排序方式被称为拓扑排序（Topological sorting）。&lt;/p&gt;
&lt;p&gt;下图是一个 DAG：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/07/26/WfjVIS.png&quot; alt=&quot;WfjVIS.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;$2, 1, 3, 5, 4, 6$ 是其一个拓扑排序。&lt;/p&gt;
&lt;h2&gt;模板题&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1038&quot;&gt;P1038 [NOIP2003 提高组] 神经网络&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。&lt;/p&gt;
&lt;h3&gt;题目描述&lt;/h3&gt;
&lt;p&gt;在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.luogu.com.cn/upload/pic/13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.luogu.com.cn/upload/pic/58251.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;每条边有一个权值，输入点有一个初始权值 $C[i]$ ，非输入点有一个阈值 $U[i]$ ，每个非输入点的 $C[i] = \displaystyle\sum_{j \to i}^{C[j] &amp;gt; 0} C[j] \times w_{i,j}$ ，输出所有输出节点中 $C[i]$ 值大于等于 $0$ 的值。&lt;/p&gt;
&lt;h3&gt;输入格式&lt;/h3&gt;
&lt;p&gt;第一行两个整数 $n, m$ ，表示点数和边数。&lt;/p&gt;
&lt;p&gt;接下来 $n$ 行表示每个节点的初始 $C[i], \ U[i]$ 值。&lt;/p&gt;
&lt;p&gt;最后 $m$ 行每行三个整数 $u, v, w$ ，表示从 $u$ 指向 $v$ 权值为 $w$ 的边。&lt;/p&gt;
&lt;h3&gt;输出格式&lt;/h3&gt;
&lt;p&gt;输出输出节点的编号及其大于等于 $0$ 的 $C[i]$ 值。&lt;/p&gt;
&lt;p&gt;如果没有，则输出 &lt;code&gt;NULL&lt;/code&gt; 。&lt;/p&gt;
&lt;h3&gt;输入输出样例&lt;/h3&gt;
&lt;h4&gt;输入&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;5 6
1 0
1 0
0 1
0 1
0 1
1 3 1
1 4 1
1 5 1
2 3 1
2 4 1
2 5 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;输出&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;3 1
4 1
5 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;说明/提示&lt;/h3&gt;
&lt;h2&gt;解决方案&lt;/h2&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;题目实际是一道模拟题，按顺序从输入节点逐层模拟神经网络的前向传播即可。不幸的是，只给出点的邻接关系不足以让我们执行这样的模拟操作，我们需要先对节点进行拓扑排序。&lt;/p&gt;
&lt;p&gt;拓扑排序的算法的流程描述非常简洁：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找出图中入度为 $0$ 的点，将其放入已排好的序列末尾。&lt;/li&gt;
&lt;li&gt;删除与与该点相关的所有边。&lt;/li&gt;
&lt;li&gt;重复上述过程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;显然，这个过程可以开一个队列来实现。&lt;/p&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;
const int maxn = 110;
int n, m, cc, cnt;
int head[maxn], C[maxn], U[maxn], indegree[maxn], outdegree[maxn], topo[maxn];
queue&amp;lt;int&amp;gt; q;
struct Node
{
    int to, w, next;
} G[maxn * maxn];

void addedge(int u, int v, int w)
{
    ++cc;
    G[cc].to = v;
    G[cc].w = w;
    G[cc].next = head[u];
    head[u] = cc;
}

int main()
{
    scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;m);
    for (int i = 1; i &amp;lt;= n; i++)
    {
        scanf(&quot;%d %d&quot;, &amp;amp;C[i], &amp;amp;U[i]);
    }
    for (int i = 1; i &amp;lt;= m; i++)
    {
        int u, v, w;
        scanf(&quot;%d %d %d&quot;, &amp;amp;u, &amp;amp;v, &amp;amp;w);
        addedge(u, v, w);
        indegree[v]++;
        outdegree[u]++;
    }
    for (int i = 1; i &amp;lt;= n; i++)
    {
        if (!indegree[i])
        {
            q.push(i);
            U[i] = 0;
        }
    }
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        topo[++cnt] = u;
        C[u] -= U[u];
        for (int i = head[u]; i; i = G[i].next)
        {
            int v = G[i].to;
            int w = G[i].w;
            indegree[v]--;
            if (C[u] &amp;gt; 0)
            {
                C[v] += w * C[u];
            }
            if (!indegree[v])
                q.push(v);
        }
    }
    bool flag = true;
    for (int i = 1; i &amp;lt;= n; i++)
    {
        if (!outdegree[i] &amp;amp;&amp;amp; C[i] &amp;gt; 0)
        {
            flag = false;
            printf(&quot;%d %d\n&quot;, i, C[i]);
        }
    }
    if (flag)
    {
        printf(&quot;NULL&quot;);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>【OI考古】图论 | 最小生成树</title><link>https://blog.vonbrank.com/posts/oi-graph-theory-minimum-spanning-tree/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/oi-graph-theory-minimum-spanning-tree/</guid><pubDate>Thu, 22 Jul 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;最小生成树（MST），顾名思义，对于带权无向连通图 $G$ ，其所有生成树中的权值和最小者 $T$ ，是其最小生成树。&lt;/p&gt;
&lt;h2&gt;模板题&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3366&quot;&gt;洛谷 P3366 | 【模板】最小生成树&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 &lt;code&gt;orz&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行包含两个整数 $N,M$ ，表示该图共有 $N$ 个结点和 $M$ 条无向边。 接下来 $M$ 行每行包含三个整数 $X_i,Y_i,Z_i$​ ，表示有一条长度为 $Z_i$​ 的无向边连接结点 $X_i,Y_i$ ​ 。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 &lt;code&gt;orz&lt;/code&gt; 。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;4 5
1 2 2
1 3 2
1 4 3
2 3 4
3 4 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;7
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;p&gt;数据规模：&lt;/p&gt;
&lt;p&gt;对于 $20%$ 的数据， $N\le 5$ ， $M\le 20$ 。&lt;/p&gt;
&lt;p&gt;对于 $40%$ 的数据， $N\le 50$ ， $M\le 2500$ 。&lt;/p&gt;
&lt;p&gt;对于 $70%$ 的数据， $N\le 500$ ， $M\le 10^4$ 。&lt;/p&gt;
&lt;p&gt;对于 $100%$ 的数据： $1\le N\le 5000$ ， $1\le M\le 2\times 10^5$ ， $1\le Z_i \le 10^4$ .&lt;/p&gt;
&lt;p&gt;样例解释：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.luogu.com.cn/upload/pic/2259.png&quot; alt=&quot;2259.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以最小生成树的总边权为 $2+2+3=7$ 。&lt;/p&gt;
&lt;h2&gt;Kruscal 算法&lt;/h2&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;Kruscal 算法是求 MST 的一种比较简单的方法，其核心思想是用贪心的思想构造 MST。&lt;/p&gt;
&lt;p&gt;考虑图 $G$ 中权值最小的边 $e_1$ ，它一定在 MST 中。选中 $e_1$ 后，次小的边 $e_2$ ，它在 MST 中与 $e_1$ 在 MST 中不矛盾。以此类推，每次我们都考虑将未选边集中权值最小的边 $e_i$ 加入 MST。&lt;/p&gt;
&lt;p&gt;然而不是所有这样的边都能加入 MST，因为 MST 毕竟还是一棵树，即无圈连通图，因此若 $e_i$ 连结的两个顶点 $u, v$ 已经包含在已选边集的生成子图中，则 $e_i$ 不能加入 MST。如此往复，直到加入 $n-1$ 条边，MST 构造完成。&lt;/p&gt;
&lt;p&gt;为什么这样是正确的呢？我们注意到上述过程的的关键点是对于 $e_i$ ，如果 $e_i$ 连结的两个顶点 $u, v$ 已经包含在已选边集的生成子图中，则 $e_i$ 不加入 MST，其他部分都显然正确。只需要探讨不合法 $e_i$ 不加入的正确性即可。&lt;/p&gt;
&lt;p&gt;对于 $e_i$ ，如果 $e_i$ 不合法，我们却想让它成为 MST 的一条边，则只需要将 $e_i$ 之前的某条边从 MST 中去掉即可，假设其为 $e_j$ ，但是显然 $e_i$ 的权值 $\ge$ $e_j$ ，结果会更差。故 $e_i$ 应该去掉。&lt;/p&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
using namespace std;
const int maxn = 5050;
const int maxm = 200500;
int n, m, ans;
int fa[maxn];
class Node
{
public:
    int u, v, w;
    bool operator&amp;lt;(const Node &amp;amp;b) const
    {
        return w &amp;lt; b.w;
    }

} E[maxm];

int getfa(int x)
{
    return fa[x] == x ? x : fa[x] = getfa(fa[x]);
}

bool check(int x, int y)
{
    return getfa(x) == getfa(y);
}

void union_(int x, int y)
{
    fa[getfa(x)] = getfa(y);
}

int main()
{
    scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;m);
    for (int i = 1; i &amp;lt;= n; i++)
        fa[i] = i;
    for (int i = 1; i &amp;lt;= m; i++)
    {
        int u, v, w;
        scanf(&quot;%d %d %d&quot;, &amp;amp;u, &amp;amp;v, &amp;amp;w);
        E[i].u = u;
        E[i].v = v;
        E[i].w = w;
    }
    sort(E + 1, E + m + 1);
    for (int i = 1; i &amp;lt;= m; i++)
    {
        if (check(E[i].u, E[i].v))
            continue;
        ans += E[i].w;
        union_(E[i].u, E[i].v);
    }
    for (int i = 2; i &amp;lt;= n; i++)
    {
        if (getfa(i) != getfa(1))
        {
            printf(&quot;orz&quot;);
            return 0;
        }
    }
    printf(&quot;%d&quot;, ans);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;解释&lt;/h3&gt;
&lt;p&gt;为事先上述算法，我们需要先将边从小到大排序，每次检测 $e_i$ 两端的点 $u, v$ 在不在已选边集对应的点集内：如果不在，则将 $u$ 或 $v$ 加入该点集；如果在，则跳过这条边。检测点集的过程可以用并查集实现。&lt;/p&gt;
&lt;h2&gt;Prim 算法&lt;/h2&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>【OI考古】图论 | 二分图匹配</title><link>https://blog.vonbrank.com/posts/oi-graph-theory-bigraph-match/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/oi-graph-theory-bigraph-match/</guid><pubDate>Thu, 15 Jul 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;先决条件&lt;/h2&gt;
&lt;h3&gt;二分图&lt;/h3&gt;
&lt;h3&gt;二分图的匹配&lt;/h3&gt;
&lt;h3&gt;增广路&lt;/h3&gt;
&lt;p&gt;对于一个二分图 $G$ ，对于一个匹配 $M$ ，若 $\exist \ u, v \notin M$ ，则 $u, v$ 间任意路 $u, v_1, v_2, \dots , v_n , v$ 是一条增广路。&lt;/p&gt;
&lt;p&gt;显然，在该增广路上构造包含 $uv_1, v_nu$ 的匹配，其余匹配不变，所得的图 $G$ 的新匹配 $M&apos;$ 匹配数必大于 $M$ 。重复寻找这样的增广路，经过有限次操作后，必能最大化 $M$ 的匹配数。&lt;/p&gt;
&lt;h2&gt;模板题 - &lt;a href=&quot;https://www.luogu.com.cn/problem/P3386&quot;&gt;洛谷 P3386 | 【模板】二分图最大匹配&lt;/a&gt;&lt;/h2&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;题目描述
给定一个二分图，其左部点的个数为 $n$ ，右部点的个数为 $m$ ，边数为 $e$ ，求其最大匹配的边数。&lt;/p&gt;
&lt;p&gt;左部点从 $1$ 至 $n$ 编号，右部点从 $1$ 至 $m$ 编号。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;输入的第一行是三个整数，分别代表 $n，m$ 和 $e$ 。&lt;/p&gt;
&lt;p&gt;接下来 $e$ 行，每行两个整数 $u, v$ ，表示存在一条连接左部点 $u$ 和右部点 $v$ 的边。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一行一个整数，代表二分图最大匹配的边数。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入&lt;code&gt;1&lt;/code&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;1 1 1
1 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出&lt;code&gt;1&lt;/code&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输入&lt;code&gt;2&lt;/code&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;1 1 1
1 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出&lt;code&gt;2&lt;/code&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;p&gt;数据规模与约定
对于全部的测试点，保证：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$1 \leq n, m \leq 500$ 。&lt;/li&gt;
&lt;li&gt;$1 \leq e \leq 5 \times 10^4$ 。&lt;/li&gt;
&lt;li&gt;$1 \leq u \leq n$ ， $1 \leq v \leq m$ 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不保证给出的图没有重边。&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;h4&gt;思路&lt;/h4&gt;
&lt;p&gt;具体到代码上，假设已经匹配好了部分顶点（没有匹配任何顶点也行），考虑当前的某个顶点 $u$ ，只需要验证能不能找到一种匹配，让另一个顶点和 $u$ 匹配，总匹配数&lt;code&gt;+1&lt;/code&gt;就行，即要尝试寻找以 $u$ 为起点的增广路。&lt;/p&gt;
&lt;p&gt;对于与它邻接的某个顶点 $v$ ，如果 $v$ 没有和任何顶点匹配，则 $uv$ 就是一条增广路，匹配数&lt;code&gt;+1&lt;/code&gt;；如果 $v$ 已经和其他某个顶点 $w$ 匹配好了，那么尝试取消 $v, w$ 间的匹配，然后寻找以 $w$ 为起点的增广路。&lt;/p&gt;
&lt;p&gt;这个过程是递归进行的，如果持续递归，最终却没有找到某个没有匹配的顶点 $t$ 作为增广路的终点，则寻找以 $u$ 为起点的增广路失败，否则寻找增广路成功，匹配数&lt;code&gt;+1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于这题来说，建图的时候顶点不能重复，所以右部顶点编号全部由输入数据加 $n$ 得到&lt;/p&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
using namespace std;
const int maxn = 505;
const int maxe = 50050;
int n, m, e, cnt, ans;
bool used[maxn &amp;lt;&amp;lt; 1];
int head[maxn &amp;lt;&amp;lt; 1], girl[maxn &amp;lt;&amp;lt; 1];
struct Node
{
    int to, next;
} G[maxe &amp;lt;&amp;lt; 1];
void addedge(int u, int v)
{
    ++cnt;
    G[cnt].to = v;
    G[cnt].next = head[u];
    head[u] = cnt;
}
bool find(int u)
{
    for (int j = head[u]; j; j = G[j].next)
    {
        int v = G[j].to;
        if (!used[v])
        {
            used[v] = true;
            if (girl[v] == 0 || find(girl[v]))
            {
                girl[v] = u;
                return true;
            }
        }
    }
    return false;
}
int main()
{
    scanf(&quot;%d %d %d&quot;, &amp;amp;n, &amp;amp;m, &amp;amp;e);
    for (int i = 1; i &amp;lt;= e; i++)
    {
        int u, v;
        scanf(&quot;%d %d&quot;, &amp;amp;u, &amp;amp;v);
        addedge(u, n + v);
        addedge(n + v, u);
    }
    for (int i = 1; i &amp;lt;= n; i++)
    {
        memset(used, 0, sizeof(used));
        if (find(i))
            ans++;
    }
    printf(&quot;%d&quot;, ans);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>【OI考古】图论 | 割点和桥</title><link>https://blog.vonbrank.com/posts/oi-graph-theory-cut-point-and-bridge/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/oi-graph-theory-cut-point-and-bridge/</guid><pubDate>Sun, 30 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;割点&lt;/h2&gt;
&lt;p&gt;对于一个无向图 $G$ ，如果把一个点 $u$ 删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。&lt;/p&gt;
&lt;h3&gt;模板题： &lt;a href=&quot;https://www.luogu.com.cn/problem/P3388&quot;&gt;洛谷 P3388 - [模板]割点(割顶)&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;给出一个 $n$ 个点， $m$ 条边的无向图，求图的割点。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行输入两个正整数 $n,m$ 。&lt;/p&gt;
&lt;p&gt;下面 $m$ 行每行输入两个正整数 $x,y$ 表示 $x$ 到 $y$ 有一条边。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;第一行输出割点个数。&lt;/p&gt;
&lt;p&gt;第二行按照节点编号从小到大输出节点，用空格隔开。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;6 7
1 2
1 3
1 4
2 5
3 5
4 5
5 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;1
5
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;p&gt;对于全部数据， $1\leq n \le 2\times 10^4$ ， $1\leq m \le 1 \times 10^5$ 。&lt;/p&gt;
&lt;p&gt;点的编号均大于 $0$ 小于等于 $n$ 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tarjan 图不一定联通。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Tarjan 算法求割点&lt;/h2&gt;
&lt;p&gt;解决这类连通性相关的图论问题通常都要请出 Tarjan 算法。关于 Tarjan 算法的基本实现思路可以参考&amp;lt;a href=&quot;{% post_path oi-graph-theory-strongly-connected-components %}#DFS生成树&quot;&amp;gt;这里&amp;lt;/a&amp;gt;。&lt;/p&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;在无向图中使用 Tarjan 算法遍历图时，若对于某个点 $u$ ，若有&lt;code&gt;dfn[u]=low[u]&lt;/code&gt;，说明从 $u$ 向下 DFS 无法回到其祖先节点，这意味着以 $u$ 为根的 DFS 生成子树下的所有节点和 $u$ 的祖先节点之间的路全都经过 $u$ ，若去掉 $u$ 则图将不连通，说明 $u$ 就是割点。&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int maxn = 100500;
int n, m, cnt = -1, cc;
int head[maxn], dfn[maxn], low[maxn], fa[maxn], sum;
bool ans[maxn];
struct Node
{
	int to, next;
} edge[maxn*2];
void addedge(int u, int v)
{
	++cnt;
	edge[cnt].to = v;
	edge[cnt].next = head[u];
	head[u] = cnt;
}
void tarjan(int u)
{
	int son = 0, root;
	++cc;
	dfn[u] = cc;
	low[u] = cc;
	for(int i=head[u]; ~i; i=edge[i].next)
	{
		int v = edge[i].to;
		if(fa[u]!=v)
		{
			if(!dfn[v])
			{
				fa[v] = u;
				tarjan(v);
				low[u] = min(low[u], low[v]);
				if(low[v]&amp;gt;=dfn[u])
				{
					ans[u] = true;
					if(fa[u]==u)
					{
						root = u;
						son++;
					}
				}
			}
			else low[u] = min(low[u], dfn[v]);
		}
	}
	if(son==1) ans[root] = false;
}
int main()
{
	scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;m);
	memset(head, -1, sizeof(head));
	for(int i=1; i&amp;lt;=m; i++)
	{
		int u, v;
		scanf(&quot;%d %d&quot;, &amp;amp;u, &amp;amp;v);
		fa[u] = u;
		fa[v] = v;
		addedge(u, v);
		addedge(v, u);
	}
	for(int i=1; i&amp;lt;=n; i++)
	{
		if(!dfn[i]) tarjan(i);
	}
	for(int i=1; i&amp;lt;=n; i++)
	{
		if(ans[i]) sum++;
	}
	printf(&quot;%d\n&quot;, sum);
	for(int i=1; i&amp;lt;=n; i++)
	{
		if(ans[i]) printf(&quot;%d &quot;, i);
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;请参见&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://oi-wiki.org/graph/cut/&lt;/li&gt;
&lt;li&gt;https://www.cnblogs.com/letisl/p/12243273.html#%E5%89%B2%E7%82%B9%E4%B8%8E%E6%A1%A5&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>【OI考古】图论 | 强连通分量 SCC | 缩点</title><link>https://blog.vonbrank.com/posts/oi-graph-theory-strongly-connected-components/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/oi-graph-theory-strongly-connected-components/</guid><pubDate>Thu, 27 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;强连通分量（Strongly Connected Components）指有向图 $G$ 中的极大子图，其满足子图内所有顶点都可以互相到达。&lt;/p&gt;
&lt;p&gt;强连通分量是有向图 $G$ 上的一种等价关系，每个 SCC 可以缩成一个点，便于后续的处理。&lt;/p&gt;
&lt;p&gt;&lt;s&gt;顺便吐槽一下最近在学校学的图论：把“连通分量”称为“连通分支”我忍了，把“二分图”称为“偶图”我也忍了，把“二叉树”叫“二元树”是什么鬼。虽然在图论学界术语不统一的背景下，对对象的称呼仅仅是习惯问题，但血压依然上来了（（&lt;/s&gt;&lt;/p&gt;
&lt;h2&gt;模板题 | P3916 | &lt;a href=&quot;https://www.luogu.com.cn/problem/P3916&quot;&gt;图的遍历&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;题目描述&lt;/h3&gt;
&lt;p&gt;给出 $N$ 个点， $M$ 条边的有向图，对于每个点 $v$ ，求 $A(v)$ 表示从点 $v$ 出发，能到达的编号最大的点。&lt;/p&gt;
&lt;h3&gt;输入格式&lt;/h3&gt;
&lt;p&gt;第 $1$ 行， $2$ 个整数 $N$ , $M$ 。 接下来 $M$ 行，每行 $2$ 个整数 $U_i$ , $V_i$ ，表示边 $(U_i,V_i)$ 。点用 $1, 2, \cdots , N$ 编号。&lt;/p&gt;
&lt;h3&gt;输出格式&lt;/h3&gt;
&lt;p&gt;$N$ 个整数 $A(1), A(2) , \cdots , A(N)$ 。&lt;/p&gt;
&lt;h3&gt;输入输出样例&lt;/h3&gt;
&lt;h4&gt;输入&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;4 3
1 2
2 4
4 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;输出&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;4 4 3 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;说明/提示&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;说明/提示&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于 $60%$ 的数据， $1 \le N , \  M \le 10^3$ ；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 $100%$ 的数据， $1 \le N , M \le 10^5$ 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Tarjan 算法&lt;/h2&gt;
&lt;p&gt;没错，又是 Tarjan 算法，不过不是求 LCA 的 Tarjan 算法。&lt;/p&gt;
&lt;h3&gt;DFS 生成树&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://oi-wiki.org/graph/images/scc1.png&quot; alt=&quot;scc1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;顾名思义，对着图 $G$ 做 DFS 的时候生成的树。&lt;/p&gt;
&lt;p&gt;此过程会生成几种可能的边：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树边（tree edge）：绿色边，每次搜索找到一个还没有访问过的结点的时候就形成了一条树边。&lt;/li&gt;
&lt;li&gt;反祖边（back edge）：黄色边，也被叫做回边，即指向祖先结点的边。&lt;/li&gt;
&lt;li&gt;横叉边（cross edge）：红色边，它主要是在搜索的时候遇到了一个已经访问过的结点，但是这个结点 并不是 当前结点的祖先时形成的。&lt;/li&gt;
&lt;li&gt;前向边（forward edge）：蓝色边，它是在搜索的时候遇到子树中的结点的时候形成的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;求 SCC&lt;/h3&gt;
&lt;p&gt;主要维护两个变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dfn[u]&lt;/code&gt;表示 DFS 过程中&lt;code&gt;u&lt;/code&gt;是第几个被遍历的节点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;low[u]&lt;/code&gt;表示以&lt;code&gt;u&lt;/code&gt;为根的子树中，&lt;code&gt;dfn&lt;/code&gt;值最小的节点，或通过返祖边、横叉边所能到达的&lt;code&gt;dfn&lt;/code&gt;值最小的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依据此思路，DFS 过程中的做法就很显然了，当搜索到节点&lt;code&gt;u&lt;/code&gt;时，令其入栈，对于与&lt;code&gt;u&lt;/code&gt;邻接的节点&lt;code&gt;v&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果&lt;code&gt;v&lt;/code&gt;未被访问过，则&lt;code&gt;v&lt;/code&gt;是&lt;code&gt;u&lt;/code&gt;的子节点，对&lt;code&gt;v&lt;/code&gt;进行 DFS，回溯时令&lt;code&gt;low[u] = min(low[u], low[v])&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;v&lt;/code&gt;已被访问过，且在栈中，则令&lt;code&gt;low[u]=min(low[u],dfn[v])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;v&lt;/code&gt;已被访问过，但不在栈中，说明这个节点的 SCC 信息已经被处理完了，不用管了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
const int maxn = 1050;
int n, cc, tot, top, scc, st, end;
int head[maxn], dfn[maxn], low[maxn], stk[maxn], belong[maxn];
bool instk[maxn];
struct Node
{
    int to, next, from;
} edge[maxn * maxn];
void addedge(int u, int v)
{
    ++cc;
    edge[cc].from = u;
    edge[cc].to = v;
    edge[cc].next = head[u];
    head[u] = cc;
}
void tarjan(int u)
{
    low[u] = dfn[u] = ++tot;
    stk[++top] = u;
    instk[u] = true;
    for (int i = head[u]; i; i = edge[i].next)
    {
        int v = edge[i].to;
        if (!dfn[v])
        {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (instk[v])
        {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u])
    {
        ++scc;
        int v;
        do
        {
            v = stk[top--];
            belong[v] = scc;
            instk[v] = false;
        } while (v != u);
    }
}
int main()
{
    scanf(&quot;%d&quot;, &amp;amp;n);
    for (int i = 1; i &amp;lt;= n; i++)
    {
        int to;
        scanf(&quot;%d&quot;, &amp;amp;to);
        while (to != 0)
        {
            addedge(i, to);
            scanf(&quot;%d&quot;, &amp;amp;to);
        }
    }
    for (int i = 1; i &amp;lt;= n; i++)
    {
        if (!dfn[i])
            tarjan(i);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;请参见&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://oi-wiki.org/graph/scc/&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>【OI考古】基础算法 | 高精度计算</title><link>https://blog.vonbrank.com/posts/oi-basic-algorithm-big-num/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/oi-basic-algorithm-big-num/</guid><pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;高精度计算（Arbitrary-Precision Arithmetic），也被称作大整数（bignum）计算，运用了一些算法结构来支持更大整数间的运算（数字大小超过语言内建整型）。&lt;/p&gt;
&lt;h2&gt;先决条件&lt;/h2&gt;
&lt;h3&gt;快读&lt;/h3&gt;
&lt;h3&gt;C++重载运算符&lt;/h3&gt;
&lt;h2&gt;高精度算法&lt;/h2&gt;
&lt;h3&gt;模板题：&lt;a href=&quot;https://www.luogu.com.cn/problem/P1932&quot;&gt;洛谷 P1932 | A+B A-B A*B A/B A%B Problem&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;求 $A、B$ 的和差积商余！&lt;/p&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;两个数两行&lt;/p&gt;
&lt;p&gt;$A \ B$&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;五个数&lt;/p&gt;
&lt;p&gt;和 差 积 商 余&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;1
1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;2
0
1
1
0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;p&gt;$leng(A),leng(B)&amp;lt;=10^4$&lt;/p&gt;
&lt;p&gt;$A,B&amp;gt;0$ 每个点 $3s$。&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;h4&gt;原理&lt;/h4&gt;
&lt;p&gt;用数组模拟高精度类型，如&lt;code&gt;1024&lt;/code&gt;可以表示成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;索引：
+---+---+---+---+---+
| 0 | 1 | 2 | 3 | 4 |
+---+---+---+---+---+

内容：
+---+---+---+---+---+
| 4 | 4 | 2 | 0 | 1 |
+---+---+---+---+---+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可知数组第 $0$ 位存的是该大整数的位数，然后从个位依次往后存储每一位数字。&lt;/p&gt;
&lt;h4&gt;声明&lt;/h4&gt;
&lt;p&gt;由此可声明大整数类&lt;code&gt;bigint&lt;/code&gt;如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class bigint
{
private:
    bool minus;
    int num[maxn];

public:
    bigint();
    bigint(const int &amp;amp;n);
    operator int() const;
    void read();
    void print() const;

    bool operator&amp;lt;(const bigint &amp;amp;x) const;
    bool operator&amp;lt;=(const bigint &amp;amp;x) const;
    bool operator!=(const bigint &amp;amp;x) const;
    bool operator==(const bigint &amp;amp;x) const;
    bool operator&amp;gt;(const bigint &amp;amp;x) const;
    bool operator&amp;gt;=(const bigint &amp;amp;x) const;

    bigint operator+(const bigint &amp;amp;x) const;
    bigint operator-() const;
    bigint operator-(const bigint &amp;amp;x) const;
    bigint operator*(const bigint &amp;amp;x) const;
    bigint operator/(const bigint &amp;amp;x) const;
    bigint operator%(const bigint &amp;amp;x) const;
    bigint operator=(const int &amp;amp;x);

    bigint abs() const;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;输入输出&lt;/h4&gt;
&lt;p&gt;先是&lt;code&gt;bigint&lt;/code&gt;类型的初始化和输入输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bigint::bigint()    //bigint初始化为正0
{
    minus = false;
    memset(num, 0, sizeof(num));
    num[0] = 1;
}

void bigint::read()
{
    memset(num, 0, sizeof(num));
    char s[maxn];
    scanf(&quot;%1s&quot;, s + 1);
    if (s[1] == &apos;-&apos;)    //读入时先判断是不是负数
    {
        minus = true;
        scanf(&quot;%s&quot;, s + 1);
    }
    else
    {
        scanf(&quot;%s&quot;, s + 2);
    }
    num[0] = strlen(s + 1);
    for (int i = 1; i &amp;lt;= num[0]; i++)
    {
        num[i] = s[num[0] - i + 1] - &apos;0&apos;;
    }
}

void bigint::print()
{
    if (minus)
        printf(&quot;-&quot;);
    for (int i = num[0]; i &amp;gt;= 1; i--)
    {
        printf(&quot;%d&quot;, num[i]);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;比较运算&lt;/h4&gt;
&lt;p&gt;由于高精度减法需要用到大整数的比较运算，不妨先写一下比较运算。比较运算看似有&lt;code&gt;&amp;lt;&lt;/code&gt;， &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;这六类，但实际上只需要写&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;==&lt;/code&gt;就可以了，原因如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;条件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;或&lt;code&gt;==&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;的反向&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;或&lt;code&gt;==&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;且&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因此只需要写好&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;==&lt;/code&gt;的重载，其他比较运算符只需要调用已有接口即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool bigint::operator&amp;lt;(const bigint &amp;amp;b) const
{
    if (minus != b.minus)
        return minus &amp;gt; b.minus;
    if (num[0] != b.num[0])
        return num[0] &amp;lt; b.num[0];
    for (int i = num[0]; i &amp;gt;= 1; i--)
    {
        if (num[i] != b.num[i])
            return num[i] &amp;lt;= b.num[i];
    }
    return false;
}

bool bigint::operator&amp;lt;=(const bigint &amp;amp;b) const
{
    if (*this &amp;lt; b || *this == b)
        return true;
    else
        return false;
}

bool bigint::operator!=(const bigint &amp;amp;b) const
{
    if (*this &amp;lt; b || b &amp;lt; *this)
        return true;
    else
        return false;
}

bool bigint::operator==(const bigint &amp;amp;b) const
{
    if (minus != b.minus)
        return false;
    if (num[0] != b.num[0])
        return false;
    for (int i = num[0]; i &amp;gt;= 1; i--)
    {
        if (num[i] != b.num[i])
            return false;
    }
    return true;
}

bool bigint::operator&amp;gt;=(const bigint &amp;amp;b) const
{
    if (b &amp;lt; *this || b == *this)
        return true;
    else
        return false;
}

bool bigint::operator&amp;gt;(const bigint &amp;amp;b) const
{
    if (b &amp;lt; *this)
        return true;
    else
        return false;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;取绝对值、取相反数与强制类型转换&lt;/h4&gt;
&lt;p&gt;再顺便写一下取相反数，绝对值和&lt;code&gt;int&lt;/code&gt;与&lt;code&gt;bigint&lt;/code&gt;的互相转化。这里重载了&lt;code&gt;int&lt;/code&gt;强制类型转换，同时对于&lt;code&gt;int&lt;/code&gt;向&lt;code&gt;bigint&lt;/code&gt;的转换，采取的 Modern C++所倡导的形如&lt;code&gt;bigint(x)&lt;/code&gt;样式的显式转换，而非&lt;code&gt;(bigint)x&lt;/code&gt;样式的传统 C 语言强制类型转换，以保证安全性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bigint::bigint(const int &amp;amp;n)
{
    int tmp = n;
    minus = tmp &amp;lt; 0;
    memset(num, 0, sizeof(num));
    while (tmp &amp;gt; 0)
    {
        num[++num[0]] = tmp % 10;
        tmp /= 10;
    }
    if (num[0] == 0)
        num[0] = 1;
}

bigint::operator int() const
{
    int n = 0;
    for (int i = num[0]; i &amp;gt;= 1; i--)
    {
        n *= 10;
        n += num[i];
    }
    return n;
}


bigint bigint::operator-() const
{
    bigint c = *this;
    c.minus ^= 1;
    return c;
}

bigint bigint::abs() const
{
    bigint c = *this;
    if (c &amp;lt; bigint(0))
        c = (-c);
    return c;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;四则运算&lt;/h4&gt;
&lt;p&gt;至此正式写高精前的准备工作就完成了。&lt;/p&gt;
&lt;p&gt;事实上高精度算法的本质是模拟人工列竖式计算的过程。如加法的做法是输入的两个数，按位相加，然后模拟进位即可。&lt;/p&gt;
&lt;p&gt;然而不论加减乘除，我们都希望把复杂的情况转化为几种基本情况，比如加法中我们总是希望两个正数相加，减法中总是两个正数相减，且结果为正。&lt;/p&gt;
&lt;h4&gt;加法&lt;/h4&gt;
&lt;p&gt;对于加法来说，有这些情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$a &amp;lt; 0, \ b &amp;gt; 0$ ，则 $a + b = b - (-a))$&lt;/li&gt;
&lt;li&gt;$a &amp;lt; 0, \ b &amp;lt; 0$ ，则 $a + b = - ( (-a) + (-b) )$&lt;/li&gt;
&lt;li&gt;$a &amp;gt; 0, \ b &amp;gt; 0$ ，则 $a + b = a + b$&lt;/li&gt;
&lt;li&gt;$a &amp;gt; 0, \ b &amp;lt; 0$ ，则 $a + b = a - (-b)$&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;bigint bigint::operator+(const bigint &amp;amp;x) const
{

    if ((*this) == bigint(0))
        return x;
    if (x == bigint(0))
        return *this;

    if (*this &amp;lt; bigint(0) &amp;amp;&amp;amp; x &amp;gt; bigint(0))
        return x - (*this).abs();
    if (*this &amp;lt; bigint(0) &amp;amp;&amp;amp; x &amp;lt; bigint(0))
        return -((*this).abs() + x.abs());
    if (*this &amp;gt; bigint(0) &amp;amp;&amp;amp; x &amp;lt; bigint(0))
        return (*this) - x.abs();

    bigint a = *this, b = x, c;
    c.num[0] = max(a.num[0], b.num[0]);
    for (int i = 1; i &amp;lt;= c.num[0]; i++)
    {
        c.num[i] += a.num[i] + b.num[i];
        c.num[i + 1] += c.num[i] / 10;
        c.num[i] %= 10;
    }
    if (c.num[c.num[0] + 1])
        c.num[0]++;
    return c;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;减法&lt;/h4&gt;
&lt;p&gt;减法稍微复杂一点，我们应该尽量将其转换成两个正数的加减法操作，可以分几种情况判断：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$a &amp;lt; 0, \ b &amp;gt; 0$ ，则 $a - b = - ((-a) + b)$&lt;/li&gt;
&lt;li&gt;$a &amp;lt; 0, \ b &amp;lt; 0$ ，则 $a - b = (-b) - (-a)$&lt;/li&gt;
&lt;li&gt;$a &amp;gt; 0, \ b &amp;gt; 0$ ，则 $a - b = a - b$&lt;/li&gt;
&lt;li&gt;$a &amp;gt; 0, \ b &amp;lt; 0$ ，则 $a - b = a + (-b)$&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;bigint bigint::operator-(const bigint &amp;amp;x) const
{
    bigint a = *this, b = x, c;
    if (a == bigint(0))
        return -b;
    if (b == bigint(0))
        return a;

    if (a &amp;lt; bigint(0) &amp;amp;&amp;amp; b &amp;gt; bigint(0))
        return -(-a + b);
    if (a &amp;lt; bigint(0) &amp;amp;&amp;amp; b &amp;lt; bigint(0))
        return (-b) - (-a);
    if (a &amp;gt; bigint(0) &amp;amp;&amp;amp; b &amp;lt; bigint(0))
        return a + (-b);

    if (a &amp;lt; b)
    {
        c.minus ^= 1;
        swap(a, b);
    }

    c.num[0] = a.num[0];
    for (int i = 1; i &amp;lt;= c.num[0]; i++)
    {
        c.num[i] = a.num[i] - b.num[i];
    }
    for (int i = 1; i &amp;lt;= c.num[0]; i++)
    {
        if (c.num[i] &amp;lt; 0)
        {
            c.num[i + 1] -= 1;
            c.num[i] += 10;
        }
    }
    while (!c.num[c.num[0]])
    {
        if (c.num[0] == 1)
            break;
        c.num[0]--;
    }

    return c;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;乘法&lt;/h4&gt;
&lt;p&gt;乘法需要注意的是，对于数 $a, \ b$ ， $a$ 的第 $i$ 位与 $b$ 的第 $j$ 之积对结果的第 $i + j - 1$ 位有贡献，计算过程中注意实时向第 $i + j$ 位进位。正负号方面， 符号不同为负，相同为正。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bigint bigint::operator*(const bigint &amp;amp;x) const
{
    bigint a = *this, b = x, c;
    if (a.abs() &amp;lt; b.abs())
        swap(a, b);
    c.minus = a.minus ^ b.minus;
    c.num[0] = a.num[0] + b.num[0];
    for (int j = 1; j &amp;lt;= b.num[0]; j++)
    {
        for (int i = 1; i &amp;lt;= a.num[0]; i++)
        {
            c.num[i + j - 1] += a.num[i] * b.num[j];
            c.num[i + j] += c.num[i + j - 1] / 10;
            c.num[i + j - 1] %= 10;
        }
    }
    while (!c.num[c.num[0]])
    {
        if (c.num[0] == 1)
        {
            c = bigint(0);
            break;
        }
        c.num[0]--;
    }
    return c;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;除法&lt;/h4&gt;
&lt;p&gt;除法同样是模拟竖式，不同的是，这里不纠结于商究竟是几位数字，而直接从最高位开始试除。高精度除法需要依赖高精度加、减、乘法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bigint bigint::operator/(const bigint &amp;amp;x) const
{
    bigint a = *this, b = x, c, tmp, cnt;
    bool flag = a.minus ^ b.minus;
    // c.minus = ;
    a = a.abs();
    b = b.abs();
    tmp.num[0] = a.num[0];
    tmp.num[tmp.num[0]] = 1;
    while (a &amp;gt; b)
    {
        cnt = bigint(0);
        while (b * tmp * (cnt + bigint(1)) &amp;lt;= a)
            cnt = cnt + bigint(1);
        c = c + tmp * cnt;
        a = a - b * tmp * cnt;
        tmp.num[tmp.num[0]] = 0;
        tmp.num[0]--;
        tmp.num[tmp.num[0]] = 1;
    }
    if (!(c.num[0] == 1 &amp;amp;&amp;amp; c.num[1] == 0))
        c.minus = flag;
    return c;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;取模&lt;/h4&gt;
&lt;p&gt;取模计算也很简单， $b$ 对 $a$ 取模的结果就是 $a - \lfloor a / b \rfloor * b$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bigint bigint::operator%(const bigint &amp;amp;x) const
{
    bigint a = *this, b = x;
    return a - a / b * b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;请参见&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://www.runoob.com/cplusplus/cpp-overloading.html&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://oi-wiki.org/math/bignum/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>蓝桥杯2021省赛游记 | C/C++ | 大学A组</title><link>https://blog.vonbrank.com/posts/lanqiao-cup-2021-province-experience/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/lanqiao-cup-2021-province-experience/</guid><description>蓝桥杯2021省赛游记</description><pubDate>Sat, 01 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;今天想起来还没有写这次比赛的游记，那就写一下吧。&lt;/p&gt;
&lt;p&gt;第一次参加蓝桥杯 &lt;s&gt;，因为 ACM 搞不动&lt;/s&gt; ，前几天出成绩了——黑龙江省一，还是稍微有点意外的，主要是因为今年蓝桥杯的省赛题简直一言难尽：说它水吧，感觉不比 NOIP 简单，更是比往年的赛题难不少；说它难吧，其实暴力打得好就会有省一。&lt;/p&gt;
&lt;h2&gt;赛前&lt;/h2&gt;
&lt;p&gt;其实本来不想参加这次比赛的，毕竟性价比比较低，因为身在哈工大，参加此类比赛，花费 300 大洋除了能在简历上加一行，在其他方面如保研等没有任何好处，不像其他大学参加蓝桥杯有各种加分。&lt;/p&gt;
&lt;p&gt;不过后来还是决定参加了，因为大一下要专业分流，几乎没有时间卷 ACM，所以还是考一下蓝桥杯保持一下手感吧。&lt;/p&gt;
&lt;h2&gt;比赛日&lt;/h2&gt;
&lt;p&gt;这次比赛我选择哈尔滨学院赛点，考前遇到了形如考试机里没有 DevCpp 只有 CodeBlocks 等鬼畜问题，根据规定是可以向组委会投诉的，好在[数据删除]，最终我还是成功用上了 DevCpp 来比赛。&lt;/p&gt;
&lt;h3&gt;题面&lt;/h3&gt;
&lt;p&gt;直接在&lt;a href=&quot;https://blog.csdn.net/ljw_study_in_CSDN/article/details/115836757&quot;&gt;这里&lt;/a&gt;看吧，就不搬运了。&lt;/p&gt;
&lt;h3&gt;A 题&lt;/h3&gt;
&lt;p&gt;第一题还是普及组水平的签到题。&lt;/p&gt;
&lt;p&gt;直接开一个 $0 \sim 9$ 的桶，每个桶存 $2021$ 张卡，从 $1$ 开始遍历自然数集，逐数字数位分离，每分离一个数，对应位置的桶减去 $1$ ，直到出现一个数 $n$ 的某一位减不动, $n-1$ 就是答案。&lt;/p&gt;
&lt;p&gt;好像几分钟就秒了这题。&lt;/p&gt;
&lt;h3&gt;B 题&lt;/h3&gt;
&lt;p&gt;这题我第一反应是类似 NOIP 2017 D2T3 的仪仗队暴力版，不过其实操作会稍微复杂一点， $dp[x1][y1][x2][y2]$ 表示 $(x1, y1), \ (x2, y2)$ 已经有线连接，遍历所有没有线连接的点元组，然后把属于该直线的所有点对全部标记即可。&lt;/p&gt;
&lt;p&gt;虽然做法很简单，但是因为码力衰弱，模拟的时候还出了几个 bug，这题写完时已经快 $9:30$ 了。&lt;/p&gt;
&lt;h3&gt;C 题&lt;/h3&gt;
&lt;p&gt;这题是傻逼题，不是指题目傻逼，而是我傻逼。&lt;/p&gt;
&lt;p&gt;想法很简单，对该数分解质因数，因为看见这个数据规模高达 $10^{16}$ ，决定采用线筛（事实证明线筛是没有必要的，最暴力的分解方法就可以，毕竟是离线的），最傻逼的事情出现了，我写个线筛写出了这种狗屎代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (int i = 1; i &amp;lt;= n; i++)
{
    if (!isprime[i])
    {
        prime[++cnt] = i;
        for (int j = 1; i * prime[j] &amp;lt;= n &amp;amp;&amp;amp; j &amp;lt;= cnt; j++)
        {
            isprime[i * prime[j]] = true;
            if (i % prime[j] == 0)
                break;
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;错哪就不必多说了，反正考场上我死活没发现哪里错了，手推线筛也推不出来，耗了 30 多 min 还是决定改回埃筛了，分解质因数结果如下：&lt;/p&gt;
&lt;p&gt;$$2021041820210418=2 \times 3 \times 3 \times 17 \times  131 \times 2857 \times 5882353$$&lt;/p&gt;
&lt;p&gt;其实接下来的事情就很容易做了，两层 DFS，然后去重完事，但是因为之前的线筛傻逼问题，整得心情很差，不想处理去重这类问题，所以最后没写。&lt;/p&gt;
&lt;p&gt;搞完这题时，时间已经来到了 $10:20$ ，我终究还是太菜。&lt;/p&gt;
&lt;h3&gt;D 题&lt;/h3&gt;
&lt;p&gt;建图，然后跑最短路完事，我用的还是 $Dijkstra$ ，尽管这么小的数据规模用 $Floyd$ 随便跑（我是傻逼）。主要问题在于我不好造数据来测试自己的最短路有没有写挂，要是写挂了，因为这是填空题，那就 gg 了。 &lt;s&gt;这么看来，洛谷的最短路模板题给的样例数据质量还是不错的。&lt;/s&gt;&lt;/p&gt;
&lt;h3&gt;E 题&lt;/h3&gt;
&lt;p&gt;哈密顿回路计数不记得怎么写了，就先跳了。&lt;/p&gt;
&lt;p&gt;最后半个小时回来写了个暴力，发现 $n=15$ 时已经要跑 $11s$ 才能跑出结果， $n$ 每增加 $1$ ，时间复杂度增加一个数量级这样，题目要求 $n=21$ 的结果，那还是算辽，跑不出来告辞。&lt;/p&gt;
&lt;h3&gt;F 题&lt;/h3&gt;
&lt;p&gt;第一道编程题。&lt;/p&gt;
&lt;p&gt;乍一看以为是 NOIP 2018 D1T2 的货币系统，可以用类似 $dp$ 的方式标记所有可能的重量，这题多了个减法的要求，所以需要稍微处理一下防止同一个砝码使用多次。&lt;/p&gt;
&lt;h3&gt;G 题&lt;/h3&gt;
&lt;p&gt;博弈论不会写。主要是因为我不知道什么样的策略算最优，又没有部分分，就不写了。&lt;/p&gt;
&lt;h3&gt;H 题&lt;/h3&gt;
&lt;p&gt;比较有意思的题，第一次听说所谓“左孩子右兄弟”的构造方法。一开始没看懂题，看了一下样例才懂。赛后我同&lt;a href=&quot;https://laybxc.github.io/&quot;&gt;laybxc&lt;/a&gt;解释样例的时候使用了如下例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/04/30/gEgw6O.md.jpg&quot; alt=&quot;gEgw6O.md.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;稍微思考一下就会发现，最优的构造策略是，对于每个节点，把深度贡献最大的子节点放到左子树的末端就可以了，这样每个节点的贡献就是：&lt;/p&gt;
&lt;p&gt;$$子节点数+贡献最大的子节点的贡献$$&lt;/p&gt;
&lt;p&gt;写法有点类似树链剖分，两次 DFS 可以统计出答案。&lt;/p&gt;
&lt;h3&gt;I 题&lt;/h3&gt;
&lt;p&gt;记得这种题见过不止一次，但是这次确实不会写了。思考了几种算法，大多是 $dp$ ，但是形如 &lt;code&gt;))))(((((((((&lt;/code&gt; 这样的样例依然没有想到一个很好的办法处理。&lt;/p&gt;
&lt;h3&gt;F 题&lt;/h3&gt;
&lt;p&gt;没时间了，题目也没看，虽然有部分分可以骗，\。&lt;/p&gt;
&lt;h2&gt;赛后&lt;/h2&gt;
&lt;p&gt;其实考试的时候我一直看的是机房电脑的时间，但是它比实际时间慢 10min，所以我以为是 $12:50$ 的时候就突然收卷了，虽然我已经写完了。&lt;/p&gt;
&lt;p&gt;期望得分 $55$ 吧，主要是今年蓝桥杯画风也挺鬼畜的，有 NOIP 2018 的感觉了，填空题还是挺刺激的，如果以后有机会，来打打也不是不行。&lt;/p&gt;
&lt;p&gt;回校的路上和&lt;a href=&quot;https://www.goldenpotato.cn/&quot;&gt;GoldenPotato&lt;/a&gt;对了一下答案，填空题我写了的部分都是一样的，感觉还行，不过赛后期望分数和赛前期望的分数相比差距还是不小的，毕竟低估了比赛难度。&lt;/p&gt;
&lt;p&gt;最终得了省一，还是相对满意的，不过似乎被其他学校暴打了，尽管这次比赛哈工大只来了 $3$ 人——我，&lt;a href=&quot;https://www.goldenpotato.cn/&quot;&gt;GoldenPotato&lt;/a&gt;，和另一位未知老哥。好在 $300$ 大洋没被浪费。&lt;/p&gt;
</content:encoded></item><item><title>HIT | 集合论与图论 | 课程笔记 | 2021春季</title><link>https://blog.vonbrank.com/posts/hit-note-cs31107/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/hit-note-cs31107/</guid><description>哈工大-离散数学引论-课程笔记</description><pubDate>Thu, 29 Apr 2021 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%9B%86%E5%90%88%E8%AE%BA&quot;&gt;集合论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E9%9B%86%E5%90%88%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97&quot;&gt;第一章 集合及其运算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%98%A0%E5%B0%84&quot;&gt;第二章 映射&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E8%88%AC%E6%A6%82%E5%BF%B5%E6%98%A0%E5%B0%84&quot;&gt;函数的一般概念——映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86&quot;&gt;抽屉原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%98%A0%E5%B0%84%E7%9A%84%E4%B8%80%E8%88%AC%E6%80%A7%E8%B4%A8&quot;&gt;映射的一般性质&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%98%A0%E5%B0%84%E7%9A%84%E5%90%88%E6%88%90&quot;&gt;映射的合成&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BE%8B1&quot;&gt;例1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%80%86%E6%98%A0%E5%B0%84&quot;&gt;逆映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%BD%AE%E6%8D%A2&quot;&gt;置换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8C%E5%85%83%E5%92%8Cn%E5%85%83%E8%BF%90%E7%AE%97&quot;&gt;二元和n元运算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0&quot;&gt;集合的特征函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%85%B3%E7%B3%BB&quot;&gt;第三章 关系&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%B3%E7%B3%BB%E7%9A%84%E6%A6%82%E5%BF%B5&quot;&gt;关系的概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%B3%E7%B3%BB%E7%9F%A9%E9%98%B5%E5%92%8C%E5%85%B3%E7%B3%BB%E5%9B%BE&quot;&gt;关系矩阵和关系图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%B3%E7%B3%BB%E7%9A%84%E5%90%88%E6%88%90%E8%BF%90%E7%AE%97&quot;&gt;关系的合成运算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%B3%E7%B3%BB%E7%9A%84%E6%80%A7%E8%B4%A8&quot;&gt;关系的性质&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%87%AA%E5%8F%8D%E6%80%A7%E5%8F%8D%E8%87%AA%E5%8F%8D%E6%80%A7%E9%9D%9E%E8%87%AA%E5%8F%8D%E4%B8%94%E9%9D%9E%E5%8F%8D%E8%87%AA%E5%8F%8D%E6%80%A7&quot;&gt;自反性、反自反性、非自反且非反自反性&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%9A%E4%B9%89&quot;&gt;定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%BE%E4%BE%8B&quot;&gt;举例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%B3%E7%B3%BB%E5%9B%BE%E8%A1%A8%E7%A4%BA&quot;&gt;关系图表示&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%B3%E7%B3%BB%E7%9A%84%E9%97%AD%E5%8C%85&quot;&gt;关系的闭包&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AF%B9%E7%A7%B0%E6%80%A7%E5%8F%8D%E5%AF%B9%E7%A7%B0%E6%80%A7&quot;&gt;对称性、反对称性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%97%A0%E7%A9%B7%E9%9B%86%E5%90%88%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%95%B0&quot;&gt;第四章 无穷集合及其基数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A8%A1%E7%B3%8A%E9%9B%86%E5%90%88%E8%AE%BA&quot;&gt;第五章 模糊集合论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9B%BE%E8%AE%BA&quot;&gt;图论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5&quot;&gt;第六章 图的基本概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%A0%91%E5%92%8C%E5%89%B2%E9%9B%86&quot;&gt;第七章 树和割集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%BF%9E%E9%80%9A%E5%BA%A6%E5%92%8C%E5%8C%B9%E9%85%8D&quot;&gt;第八章 连通度和匹配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%B9%B3%E9%9D%A2%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%9D%80%E8%89%B2&quot;&gt;第九章 平面图和图的着色&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%9C%89%E5%90%91%E5%9B%BE&quot;&gt;第十章 有向图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%AF%B7%E5%8F%82%E8%A7%81&quot;&gt;请参见&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;集合论&lt;/h1&gt;
&lt;h1&gt;第一章 集合及其运算&lt;/h1&gt;
&lt;h1&gt;第二章 映射&lt;/h1&gt;
&lt;h2&gt;函数的一般概念——映射&lt;/h2&gt;
&lt;h2&gt;抽屉原理&lt;/h2&gt;
&lt;h2&gt;映射的一般性质&lt;/h2&gt;
&lt;h2&gt;映射的合成&lt;/h2&gt;
&lt;h3&gt;例1&lt;/h3&gt;
&lt;p&gt;设 $M$ 是一个非空集合， $\varphi : M \rightarrow M ,\ N  \subseteq M$ 。令 $𝒜 = {  P \ | \ P \subseteq M$ 且 $N \subseteq P , \ \varphi(P) \subseteq P }$ ， $G= \displaystyle\bigcap_{P \in 𝒜} P$ 。 试证：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$G \in 𝒜$ ；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$N \bigcup \varphi (G) = G$ 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$\forall x \in G ， P \in 𝒜$ ，有 $x \in P$&lt;/p&gt;
&lt;p&gt;所以 $\forall x \in G ， x \in M$ ，即 $G \subseteq M$&lt;/p&gt;
&lt;p&gt;$\forall x \in N ，x \in P$ ，即 $x \in \displaystyle\bigcap_{P \in 𝒜} P = G$ ，所以 $N \subseteq G$&lt;/p&gt;
&lt;p&gt;$\forall x \in G$ ，有 $\varphi (x) \in P$ ，即 $\varphi (x) \in \displaystyle\bigcap_{P \in 𝒜} P = G$ ，所以 $\varphi (G) \subseteq G$&lt;/p&gt;
&lt;p&gt;综上 $G \in 𝒜$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先证 $N \bigcup \varphi (G) \subseteq G$ 。&lt;/p&gt;
&lt;p&gt;$\forall x \in N \bigcup \varphi (G)$ ， $x \in N \ 或 \ x \in \varphi (G)$&lt;/p&gt;
&lt;p&gt;若 $x \in N$ ，因为 $N \subseteq G$ ，所以 $x \in G$ 。&lt;/p&gt;
&lt;p&gt;若 $x \in \varphi (G)$ ，因为 $\varphi (G) \subseteq G$ ，所以 $x \in G$ 。&lt;/p&gt;
&lt;p&gt;所以 $N \bigcup \varphi (G) \subseteq G$ 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再证 $G \subseteq N \bigcup \varphi (G)$ ：&lt;/p&gt;
&lt;p&gt;$\forall x \in G$ ，&lt;/p&gt;
&lt;p&gt;由于 $N \subseteq G$ ，&lt;/p&gt;
&lt;p&gt;若 $x \in N$ , $x \in N \bigcup \varphi (G)$&lt;/p&gt;
&lt;p&gt;若 $x \notin N$ ,  则 $x \in G \backslash N$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;下证： $\forall x \in G \backslash N, \ \varphi (x) \notin N$ 。&lt;/p&gt;
&lt;p&gt;假设 $\varphi (x) \in N$ ，那么 $G \backslash x \in 𝒜$ ，与 $G= \displaystyle\bigcap_{P \in 𝒜} P$ 矛盾。&lt;/p&gt;
&lt;p&gt;故  $\forall x \in G \backslash N, \ \varphi (x) \notin N$&lt;/p&gt;
&lt;p&gt;即  $\forall x \in G \backslash N, \ \varphi (x) \in G \backslash N$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再下证： $\varphi : G \backslash N \rightarrow G \backslash N$ 是双射。&lt;/p&gt;
&lt;p&gt;假设 $\varphi : G \backslash N \rightarrow G \backslash N$ 不是满射，&lt;/p&gt;
&lt;p&gt;即 $\exist y \in G \backslash N , \ s.t. \ \varphi ^{-1} (y) = \empty$ ，&lt;/p&gt;
&lt;p&gt;那么 $G \backslash y \in 𝒜$ ，与 $G= \displaystyle\bigcap_{P \in 𝒜} P$ 矛盾。&lt;/p&gt;
&lt;p&gt;所以 $\varphi : G \backslash N \rightarrow G \backslash N$ 是满射，也是双射。&lt;/p&gt;
&lt;p&gt;即 $\varphi (G \backslash N) = G \backslash N$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以 $x \in G \backslash N = \varphi (G \backslash N) \subseteq \varphi (G)$ 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;逆映射&lt;/h2&gt;
&lt;h2&gt;置换&lt;/h2&gt;
&lt;h2&gt;二元和n元运算&lt;/h2&gt;
&lt;h2&gt;集合的特征函数&lt;/h2&gt;
&lt;h1&gt;第三章 关系&lt;/h1&gt;
&lt;h2&gt;关系的概念&lt;/h2&gt;
&lt;h2&gt;关系矩阵和关系图&lt;/h2&gt;
&lt;h2&gt;关系的合成运算&lt;/h2&gt;
&lt;h2&gt;关系的性质&lt;/h2&gt;
&lt;h3&gt;自反性、反自反性、非自反且非反自反性&lt;/h3&gt;
&lt;h4&gt;定义&lt;/h4&gt;
&lt;p&gt;设 $R \sube A \times A$ :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$\forall x \in A$ ， $&amp;lt;x, x&amp;gt; \in R$ ，则称 $R$ 在 $A$ 上是自反的（reflexive），或称 $R$ 具有自反性（reflexivity）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\forall x \in A$ ，$&amp;lt;x, x&amp;gt; \notin R$ ，则称 $R$ 在 $A$ 上是反自反的（antireflexive），或称 $R$ 具有反自反性（antireflexivity）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;举例&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;同姓关系、小于等于关系、包含关系、整除关系是&lt;strong&gt;自反&lt;/strong&gt;关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;父子关系，小于关系，真包含关系都是反自反关系。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;关系图表示&lt;/h4&gt;
&lt;p&gt;自反：全都有自环。&lt;/p&gt;
&lt;p&gt;反自反：没有自环。&lt;/p&gt;
&lt;p&gt;非自反且非反自反：有且仅有部分有自环。&lt;/p&gt;
&lt;h2&gt;关系的闭包&lt;/h2&gt;
&lt;h3&gt;对称性、反对称性&lt;/h3&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h1&gt;第四章 无穷集合及其基数&lt;/h1&gt;
&lt;h1&gt;第五章 模糊集合论&lt;/h1&gt;
&lt;h1&gt;图论&lt;/h1&gt;
&lt;h1&gt;第六章 图的基本概念&lt;/h1&gt;
&lt;h1&gt;第七章 树和割集&lt;/h1&gt;
&lt;h1&gt;第八章 连通度和匹配&lt;/h1&gt;
&lt;h1&gt;第九章 平面图和图的着色&lt;/h1&gt;
&lt;h1&gt;第十章 有向图&lt;/h1&gt;
&lt;h1&gt;请参见&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;https://zhuanlan.zhihu.com/p/57478122&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>HIT | 工科数学分析 | 课程笔记 | 2021春季</title><link>https://blog.vonbrank.com/posts/hit-note-ma21004/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/hit-note-ma21004/</guid><description>哈工大-微积分B-课程笔记</description><pubDate>Tue, 27 Apr 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;第八章 多元函数微分学&lt;/h1&gt;
&lt;h2&gt;二重极限&lt;/h2&gt;
&lt;h2&gt;偏导数&lt;/h2&gt;
&lt;h2&gt;全微分&lt;/h2&gt;
&lt;p&gt;$$z=f(x, y)$$&lt;/p&gt;
&lt;p&gt;$$dz =  \frac {\partial f} {\partial x} dx + \frac {\partial f} {\partial y} dy$$&lt;/p&gt;
&lt;h2&gt;复合函数的链式法则&lt;/h2&gt;
&lt;h2&gt;隐函数求导法&lt;/h2&gt;
&lt;h2&gt;多元微分学在几何中的应用&lt;/h2&gt;
&lt;h2&gt;二元函数的极值&lt;/h2&gt;
&lt;h2&gt;方向导数与梯度&lt;/h2&gt;
&lt;h2&gt;例题&lt;/h2&gt;
&lt;h1&gt;第九章 多元函数积分学&lt;/h1&gt;
&lt;h2&gt;黎曼积分&lt;/h2&gt;
&lt;h2&gt;二重积分&lt;/h2&gt;
&lt;h2&gt;三重积分&lt;/h2&gt;
&lt;h3&gt;球坐标系下三重积分举例&lt;/h3&gt;
&lt;h4&gt;例1&lt;/h4&gt;
&lt;p&gt;计算 $\displaystyle\iiint_{\Omega} \sqrt{x^2 + y^2 + z^2} d \Omega$，其中 $\Omega$ 是由球面 $x^2 + y^2 + z^2 = z$ 所围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;： 球面化为球坐标得，&lt;/p&gt;
&lt;p&gt;$$\rho^2 = \rho cos \phi$$&lt;/p&gt;
&lt;p&gt;积分域:&lt;/p&gt;
&lt;p&gt;$$\Omega\begin{cases} 0 \le \theta \le 2\pi \ 0 \le \phi \le \pi / 2 \ 0 \le \rho \le cos \phi
\end{cases}$$&lt;/p&gt;
&lt;p&gt;原式：&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;/p&gt;
&lt;p&gt;I&lt;/p&gt;
&lt;p&gt;&amp;amp; = \int _0 ^{2\pi} d \theta \int _0 ^{\pi / 2} d \phi \int _0 ^{\cos \phi} \rho ^3 \sin \phi d \rho \&lt;/p&gt;
&lt;p&gt;&amp;amp; = 2 \pi \int _0 ^{\pi / 2} \sin \phi  d \phi \int _0 ^{\cos \phi} \rho ^3 d \rho \&lt;/p&gt;
&lt;p&gt;&amp;amp; = \frac{2 \pi}{4}  \int _0 ^{\pi / 2} sin \phi \cos ^4 \phi \&lt;/p&gt;
&lt;p&gt;&amp;amp; = \frac{\pi}{10}&lt;/p&gt;
&lt;p&gt;\end{aligned}$$&lt;/p&gt;
&lt;h4&gt;例2&lt;/h4&gt;
&lt;h2&gt;第一型曲线积分&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;若 $C$ 是空间或平面一有限曲线段， $f(x, y, z)$ $\large($ $f(x, y)$ $\large)$ 是 $C$ 上的一个连续函数，则 $$ 是 $f$ 在 $C$ 上的第一型曲线积分。&lt;/p&gt;
&lt;h2&gt;第一型曲面积分&lt;/h2&gt;
&lt;h2&gt;黎曼积分的应用&lt;/h2&gt;
&lt;h2&gt;例题&lt;/h2&gt;
&lt;h1&gt;索引&lt;/h1&gt;
&lt;h2&gt;名词&lt;/h2&gt;
&lt;h2&gt;符号&lt;/h2&gt;
&lt;h3&gt;运算符&lt;/h3&gt;
&lt;h4&gt;大型运算符&lt;/h4&gt;
&lt;p&gt;$\sum ， \int ，\iint  ，\iiint  ，\oint  ，  ，  ，$&lt;/p&gt;
&lt;p&gt;$\int _{a} ^{b} x dx$&lt;/p&gt;
&lt;h3&gt;Style, Color, Size, and Font&lt;/h3&gt;
&lt;h4&gt;Style&lt;/h4&gt;
&lt;p&gt;$\displaystyle\sum_{i=1}^n，\textstyle\sum_{i=1}^n$&lt;/p&gt;
</content:encoded></item><item><title>【OI考古】数据结构 | 树状数组</title><link>https://blog.vonbrank.com/posts/oi-data-structure-binary-indexed-tree/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/oi-data-structure-binary-indexed-tree/</guid><pubDate>Tue, 27 Apr 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;树状数组或二元索引树（英语：Binary Indexed Tree，Fenwick Tree），是一种用于高效处理对一个存储数字的列表进行更新及求前缀和的数据结构。&lt;/p&gt;
&lt;p&gt;树状数组的元素所管理的序列结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/04/27/g9RY7V.md.png&quot; alt=&quot;g9RY7V.md.png&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;树状数组（单点修改）&lt;/h2&gt;
&lt;h3&gt;模板题：&lt;a href=&quot;https://www.luogu.com.cn/problem/P3374&quot;&gt;洛谷 P3374  | [模板] 树状数组 1&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;如题，已知一个数列，你需要进行下面两种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将某一个数加上 $x$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;求出某区间每一个数的和&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行包含两个正整数 $n,m$ ，分别表示该数列数字的个数和操作的总个数。&lt;/p&gt;
&lt;p&gt;第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。&lt;/p&gt;
&lt;p&gt;接下来 $m$ 行每行包含 $3$ 个整数，表示一个操作，具体如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;1 x k&lt;/code&gt; 含义：将第 $x$ 个数加上 $k$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;2 x y&lt;/code&gt; 含义：输出区间 $[x,y]$ 内每个数的和&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;5 5
1 5 4 2 3
1 1 3
2 2 5
1 3 -1
1 4 2
2 1 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;14
16
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;p&gt;【数据范围】&lt;/p&gt;
&lt;p&gt;对于 $30%$ 的数据， $1 \le n \le 8$ ， $1\le m \le 10$ ；&lt;/p&gt;
&lt;p&gt;对于 $70%$ 的数据， $1\le n,m \le 10^4$ ；&lt;/p&gt;
&lt;p&gt;对于 $100%$ 的数据， $1\le n,m \le 5\times 10^5$ 。&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
const int maxn = 500500;
int n, m;
long long c[maxn];
int lowbit(int x)
{
    return x &amp;amp; -x;
}
void add(int x, long long k)
{
    while (x &amp;lt;= n)
    {
        c[x] += k;
        x += lowbit(x);
    }
}
long long query(int x, int y)
{
    long long ans1 = 0, ans2 = 0;
    x--;
    while (x &amp;gt;= 1)
    {
        ans1 += c[x];
        x -= lowbit(x);
    }
    while (y &amp;gt;= 1)
    {
        ans2 += c[y];
        y -= lowbit(y);
    }
    return ans2 - ans1;
}
int main()
{
    scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;m);
    for (int i = 1; i &amp;lt;= n; i++)
    {
        long long x;
        scanf(&quot;%lld&quot;, &amp;amp;x);
        add(i, x);
    }
    for (int i = 1; i &amp;lt;= m; i++)
    {
        int op, x, k;
        scanf(&quot;%d %d %d&quot;, &amp;amp;op, &amp;amp;x, &amp;amp;k);
        if (op == 1)
        {
            add(x, (long long)k);
        }
        if (op == 2)
        {
            printf(&quot;%lld\n&quot;, query(x, k));
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;树状数组（区间操作）&lt;/h2&gt;
&lt;h2&gt;请参阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://oi-wiki.org/ds/fenwick/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>【OI考古】数论基础 | 扩展欧几里得算法</title><link>https://blog.vonbrank.com/posts/oi-number-theory-exgcd/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/oi-number-theory-exgcd/</guid><description>帮助你对扩欧形成直观而专业的理解</description><pubDate>Tue, 27 Apr 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;印象中之前每次复习扩展欧几里得算法时，Google到的大佬们对扩欧的解释常常晦涩难懂。因此，在这文章中，我将根据自己的理解，试图以一种优雅的方式解释扩展欧几里得算法，希望能够使读者对扩展欧几里得算法形成直观而专业的理解。&lt;/p&gt;
&lt;h2&gt;先决条件&lt;/h2&gt;
&lt;h3&gt;欧几里得算法&lt;/h3&gt;
&lt;p&gt;在了解扩展欧几里得算法前，当然要先知道欧几里得算法是什么。&lt;/p&gt;
&lt;p&gt;如果你还不会求GCD，请先到 {% post_link oi-number-theory-quickpow-gcd-eulersieve 这里 %} 复习一下欧几里得算法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int gcd(int a, int b)
{
    if (a % b)
        return gcd(b, a % b);
    else
        return b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;裴蜀定理&lt;/h3&gt;
&lt;p&gt;裴蜀定理的描述是这样的：&lt;/p&gt;
&lt;p&gt;$$∀a,b∈Z,∃(x,y)∈Z, \quad $$&lt;/p&gt;
&lt;p&gt;$$s.t. \quad ax+by=gcd(a,b)$$&lt;/p&gt;
&lt;p&gt;$ax+by=gcd(a,b)$ 被称为裴蜀等式。&lt;/p&gt;
&lt;p&gt;这里不多解释，知道有这个定理就行。&lt;/p&gt;
&lt;h2&gt;扩展欧几里得算法&lt;/h2&gt;
&lt;p&gt;正如裴蜀定理所介绍的那样，扩展欧几里得算法的产生源自于对裴蜀等式的求解问题：&lt;/p&gt;
&lt;p&gt;$$ax+by=gcd(a,b)$$&lt;/p&gt;
&lt;p&gt;这里所说的求解当然是指要求 $x, y$ 的整数解。&lt;/p&gt;
&lt;h3&gt;推导&lt;/h3&gt;
&lt;p&gt;可以看出，这是一个不定方程，整数解有无穷多个。可以证明，如果我们找到一组解 $x_0, y_0$ ，则该方程的通解为：&lt;/p&gt;
&lt;p&gt;$$\begin{cases} x = x_0 + bt \ y = y_0 - at \end{cases} \quad t∈Z$$&lt;/p&gt;
&lt;p&gt;在欧几里得算法中，我们用&lt;code&gt;gcd(a, b)&lt;/code&gt;这个函数来计算 $a, b$ 的最大公约数，计算过程中需要递归地返回&lt;code&gt;gcd(b, a % b)&lt;/code&gt;的值。&lt;/p&gt;
&lt;p&gt;类比地，我们试图用&lt;code&gt;exgcd(a, b, x, y)&lt;/code&gt;来求解裴蜀等式，此函数返回的仍然是 $a, b$ 的最大公约数，并利用C++的引用特性在计算过程中将我们所需的裴蜀等式的解 $x, y$ 带出。可以猜想，此过程中需要递归计算&lt;code&gt;exgcd(b, a % b, x, y)&lt;/code&gt;，也就是求解以下方程：&lt;/p&gt;
&lt;p&gt;$$bx + (a%b)y = gcd(b, a%b)$$&lt;/p&gt;
&lt;p&gt;而 $gcd(b, a%b)$ 其实就是 $gcd(a, b)$ 。&lt;/p&gt;
&lt;p&gt;这里的 $x, y$ 应该不是裴蜀等式所需要求的 $x, y$ ，但是二者之间应该具有某种联系。可以尝试将这个方程的左式化简一下：&lt;/p&gt;
&lt;p&gt;$$bx + (a%b)y = bx + (a - b \lfloor a/b\rfloor )y = ay + b(x - \lfloor a/b\rfloor y)$$&lt;/p&gt;
&lt;p&gt;然后我们就惊讶地发现下面这两个方程具有相同的结构：&lt;/p&gt;
&lt;p&gt;$$ax+by=gcd(a,b)$$&lt;/p&gt;
&lt;p&gt;$$ay + b(x - \lfloor a/b\rfloor y) = gcd(a, b)$$&lt;/p&gt;
&lt;p&gt;欲解第一个方程，须先解第二个方程。换句话说，如果我们想利用 &lt;code&gt;exgcd(a, b, x, y)&lt;/code&gt;这样的函数求解裴蜀等式，要先求&lt;code&gt;exgcd(b, a%b, x, y)&lt;/code&gt;，获得 $x, y$ 值之后，令：&lt;/p&gt;
&lt;p&gt;$$\begin{cases} x = y \ y = x - \lfloor a/b\rfloor y \end{cases}$$&lt;/p&gt;
&lt;p&gt;至此我们就完成了扩展欧几里得算法中，下层递归结果对上一层的转化。&lt;/p&gt;
&lt;p&gt;在欧几里得算法中，递归的临界条件是输入的 $b=0$ ，此时 $a$ 就是所求的最大公约数。同样的，在扩展欧几里得算法中，如果我们向下一直递归，最终输入的 $a, b$ 中 $b$ 将为 $0$ ,此时无论 $a$ 如何取值，都有 $x=1, y=0$ ，因为：&lt;/p&gt;
&lt;p&gt;$$a \times 1 + b \times 0=gcd(a, 0)$$&lt;/p&gt;
&lt;p&gt;然后在回溯的过程中，通过上述算法，层层计算 $x,y$ 的值，最终可以得到最初的裴蜀等式的一组特解。&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;int exgcd(int a, int b, int &amp;amp;x, int &amp;amp;y)
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    int d = exgcd(b, a % b, x, y);
    int k = x;
    x = y;
    y = k - a / b * y;
    return d;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;后续步骤&lt;/h2&gt;
&lt;p&gt;至此你恭喜你已经学会了扩展欧几里得算法（如果我的文章写的还行的话），现在你可以使用扩展欧几里得算法愉快地解决以下问题了。&lt;/p&gt;
&lt;h3&gt;线性同余方程&lt;/h3&gt;
&lt;p&gt;求形如 $ax ≡ c(\mod b)$ 的线性同余方程。&lt;/p&gt;
&lt;p&gt;这里 $gcd(a, b) | c$&lt;/p&gt;
&lt;h3&gt;乘法逆元&lt;/h3&gt;
&lt;p&gt;如果一个线性同余方程 $ax ≡ 1(\mod b)$ ，则 $x$ 称为 $a \mod b$ 的逆元，记作 $a^{-1}$ 。&lt;/p&gt;
&lt;h2&gt;请参见&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://www.cnblogs.com/fusiwei/p/11775503.html&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://oi-wiki.org/math/linear-equation/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://oi-wiki.org/math/inverse/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;{% post_link oi-number-theory-quickpow-gcd-eulersieve 【OI考古】数论基础 | 快速幂、最大公约数、线性筛素数 %}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>利用Sympy求解常系数微分方程</title><link>https://blog.vonbrank.com/posts/sympy-solve-differential-equation/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/sympy-solve-differential-equation/</guid><pubDate>Mon, 26 Apr 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;昨天接到一个需求，要求用Python实现求解常系数微分方程，虽然后来咕掉了，但是让我发现了Sympy这个科学计算库竟然有如此神奇的功能。本文将介绍如何用Sympy解决初值问题。&lt;/p&gt;
&lt;h2&gt;先决条件&lt;/h2&gt;
&lt;h3&gt;Anaconda先决条件&lt;/h3&gt;
&lt;p&gt;我们强烈建议您使用免费的&lt;a href=&quot;https://www.anaconda.com/download/&quot;&gt;Anaconda Python发行版&lt;/a&gt;，该&lt;a href=&quot;https://www.anaconda.com/download/&quot;&gt;发行版&lt;/a&gt;为您处理如Numpy, Sympy, Scipy等软件包依赖项提供了一种简便的方法。&lt;/p&gt;
&lt;p&gt;你可以参考 {% post_link deploy-anaconda-on-windows 这篇文章 %} 来部署Anaconda。&lt;/p&gt;
&lt;h3&gt;Sympy先决条件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;SymPy&lt;/strong&gt;是一个符号计算的&lt;a href=&quot;https://zh.wikipedia.org/wiki/Python&quot;&gt;Python&lt;/a&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BA%93_(%E8%AE%A1%E7%AE%97%E6%9C%BA)&quot;&gt;库&lt;/a&gt;。它的目标是成为一个全功能的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%A3%E6%95%B0%E7%B3%BB%E7%BB%9F&quot;&gt;计算机代数系统&lt;/a&gt;，同时保持代码简洁、易于理解和扩展。支持符号计算、&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97&quot;&gt;高精度计算&lt;/a&gt;、模式匹配、绘图、解方程、微积分、&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6&quot;&gt;组合数学&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6&quot;&gt;离散数学&lt;/a&gt;、几何学、概率与统计、物理学等方面的功能。&lt;/p&gt;
&lt;p&gt;在开始用Sympy求解微分方程之前，不妨先入门一下Sympy。&lt;/p&gt;
&lt;h2&gt;求微分方程通解&lt;/h2&gt;
&lt;p&gt;以初值问题：&lt;/p&gt;
&lt;p&gt;$$y&apos;&apos;+2y&apos;+2y=xe^{-x}, \quad y(0)=y&apos;(0)=0$$&lt;/p&gt;
&lt;p&gt;为例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;get-general-solution.py&lt;/code&gt;可以求出微分方程的通解：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import sympy as sy

f = sy.symbols(&apos;f&apos;, cls=sy.Function)
x = sy.symbols(&apos;x&apos;)

# 在这里输入你要求解的微分方程，逗号前输入左式，逗号后输入右式
# 若包含exp(), sin()等函数，请写成sy.exp(), sy.sin()等
differential_equation = sy.Eq(
    f(x).diff(x, 2) + 2 * f(x).diff(x, 1) + 2 * f(x), x * sy.exp(-x))

general_solution = sy.dsolve(differential_equation, f(x)).rhs

print(general_solution)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;[out]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(C1*sin(x) + C2*cos(x) + x)*exp(-x)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;解初值问题&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;get-particular-solution.py&lt;/code&gt;可以求出微分方程的特解：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import sympy as sy

x = sy.symbols(&apos;x&apos;)

C1 = sy.symbols(&apos;C1&apos;)
C2 = sy.symbols(&apos;C2&apos;)

# 在这里输入由get-general-solution.py获得的微分方程通解
# 如果出现C3, C4等参数，请在上方加入形如C3 = sy.symbols(&apos;C3&apos;)等语句
# 若包含exp(), sin()等函数，请写成sy.exp(), sy.sin()等
general_solution = (C1*sy.sin(x) + C2*sy.cos(x) + x)*sy.exp(-x)

# 求解C1, C2等的值，
# 如果初值条件右式不为零，请移项至左边，使得右式为0
# 如果含更多初值条件，请加入形如:
# f3 = general_solution.diff(x, 2).subs(x, 0)
# 等语句，diff(x, n)表示通解对x求n阶导
f1 = general_solution.subs(x, 0)
f2 = general_solution.diff(x, 1).subs(x, 0)
parameters = sy.solve([f1, f2], [C1, C2])

# 如果含有C3，请添加形如：
# particular_solution = particular_solution.subs(C3, parameters[C3])
# 等语句
particular_solution = general_solution
particular_solution = particular_solution.subs(C1, parameters[C1])
particular_solution = particular_solution.subs(C2, parameters[C2])

print(particular_solution)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;[out]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(x - sin(x))*exp(-x)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;绘制函数图像&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;get-function-graph.py&lt;/code&gt;可以绘制特解函数的图像：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import sympy as sy
import matplotlib.pyplot as plt
import numpy as np

# 在这里输入由get-particular-solution.py获得的微分方程特解
# 若包含exp(), sin()等函数，请写成sy.exp(), sy.sin()等
x = sy.symbols(&apos;x&apos;)
particular_solution = (x - sy.sin(x))*sy.exp(-x)

x_range = np.arange(-5, 5, 0.1)	//np.arange(a, b, step)表示绘制的区间和步长
y_range = [particular_solution.subs(x, x_val) for x_val in x_range]
plt.plot(x_range, y_range)
plt.axis([-6, 6, -10, 10])	//axis([x1, x2, y1, y2])表示在[x1, x2], [y1, y2]范围内绘图
plt.grid()
plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;[out]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/04/26/gScakQ.png&quot; alt=&quot;gScakQ.png&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;请参见&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://blog.csdn.net/cj151525/article/details/95756847&lt;/li&gt;
&lt;li&gt;https://www.jb51.net/article/185664.htm&lt;/li&gt;
&lt;li&gt;{% post_link deploy-anaconda-on-windows Anaconda部署与使用指南（Windows） %}&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>【Codeforces】 题解 - Round 709 (Div.2)</title><link>https://blog.vonbrank.com/posts/codeforces-solution-round-709-div-2/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/codeforces-solution-round-709-div-2/</guid><pubDate>Sat, 10 Apr 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;本文合作者：&lt;a href=&quot;https://laybxc.github.io/&quot;&gt;laybxc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题解持续补充...&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;赛事信息&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;出题人&lt;/th&gt;
&lt;th&gt;开始时间&lt;/th&gt;
&lt;th&gt;时长&lt;/th&gt;
&lt;th&gt;官方题解&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://codeforces.com/contest/1484&quot;&gt;Codeforces Round #709 (Div. 2, based on Technocup 2021 Final Round)&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://codeforces.com/profile/Aleks5d&quot;&gt;Aleks5d&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/AndreySergunin&quot;&gt;AndreySergunin&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/Diegogrc&quot;&gt;Diegogrc&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/Golovanov399&quot;&gt;Golovanov399&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/KAN&quot;&gt;KAN&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/amethyst0&quot;&gt;amethyst0&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://www.timeanddate.com/worldclock/fixedtime.html?day=13&amp;amp;month=3&amp;amp;year=2021&amp;amp;hour=13&amp;amp;min=20&amp;amp;sec=0&quot;&gt;Mar/21/2021&amp;lt;br/&amp;gt;21:20 (UTC+8)&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;02:15&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://codeforces.com/blog/entry/88963&quot;&gt;Codeforces Round #709 Editorial&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;A. Prison Break&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;给出 $a \times b$ 的网格，问最少去掉多少条边，可以使得所有格子和外界连通。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;一行一个整数 $t(1 \leq t \leq 100)$ ，表示数据组数。&lt;/p&gt;
&lt;p&gt;第二行两个整数，表示参数 $a，b(1 \leq a,b \leq 100)$ 。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;一个整数，表示答案&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;2
2 2
1 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;4
3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;p&gt;两组测试数据，可以用以下方案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://espresso.codeforces.com/185ae4a89996e2bddeda6d7f0766d44391359525.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://espresso.codeforces.com/473c1c9173da86ac35b5fd4aa744c40b9225a761.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;h4&gt;思路&lt;/h4&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;B. Restore Modulo&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;给出数组 $a$ ，问是否能按以下方法构造：&lt;/p&gt;
&lt;p&gt;存在 $n,m,c,s$ ； $n,m&amp;gt;0$ ； $0 \leq c&amp;lt;m$ ； $s \geq 0$ 。&lt;/p&gt;
&lt;p&gt;(1) $a1 = s % m$&lt;/p&gt;
&lt;p&gt;(2) $a_i = (a_{i-1} + c) %  m \quad (1 \leq i \leq n)$ ;&lt;/p&gt;
&lt;p&gt;如果存在，则找出最大的 $m$ ，以及任意符合要求的 $c$&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行一个整数 $t(1 \leq t \leq 10^5)$ 。&lt;/p&gt;
&lt;p&gt;每组数据第一行一个整数 $n(1 \leq n \leq 10^5)$ ，表示 $a$ 数组元素个数。&lt;/p&gt;
&lt;p&gt;第二行 $n$ 个整数 $a_1，a_2，\dots，a_n(1≤a_i≤10^9)$ ，表示数组 $a$ 的元素。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;如果不能，则输出 $-1$ 。&lt;/li&gt;
&lt;li&gt;如果 $m$ 可以任意大，则输出 $0$ 。&lt;/li&gt;
&lt;li&gt;如果是其他情况，则输出最大的 $m$ 和任何合法的 $c(0 \leq c &amp;lt; m)$ 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;6
6
1 9 17 6 14 3
3
4 2 2
3
7 3 4
3
2 2 4
5
0 1000000000 0 1000000000 0
2
1 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;19 8
-1
-1
-1
2000000000 1000000000
0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;h4&gt;思路&lt;/h4&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;C. Basic Diplomacy&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;有 $n$ 个朋友， $m$ 天，每天找一个朋友玩，且和每个朋友玩的天数不能超过 $⌈\frac m 2⌉$ 天。&lt;/p&gt;
&lt;p&gt;给出每一个朋友具体在哪些天有空。判断是否有方案满足要求，是则给出方案。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行一个整数 $t(1≤t≤10000)$ ，表示数据组数。&lt;/p&gt;
&lt;p&gt;接下来每组数据第一行有两个整数 $n，m (1≤n,m≤100000)$&lt;/p&gt;
&lt;p&gt;接下来 $m$ 行中的第 $i$ 行有一个整数 $k_i$ ，其后接着 $k_i$ 个整数 $f_{i1}，f_{i2}，\dots，f_{ik_i}(1 \leq f_{ij} \leq n)$ ，表示第 $i$ 个朋友在第 $f_{ij}$ 天有空。&lt;/p&gt;
&lt;p&gt;保证每组数据的 $k_i$ 之和不超过 $200000$ 。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;对于每组数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果没有合法方案，则输出&lt;code&gt;NO&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;否则，第一行输出&lt;code&gt;YES&lt;/code&gt;，第二行输出 $m$ 个整数 $c_1，c_2，\dots，c_m$ ， $c_i$ 表示第i天找的朋友的编号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有朋友编号出现的次数都必须小于 $⌈\frac m 2⌉$ 。如果有多种可能方案，输出任意一种即可。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;2
4 6
1 1
2 1 2
3 1 2 3
4 1 2 3 4
2 2 3
1 3
2 2
1 1
1 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;YES
1 2 1 1 2 3 
NO
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;h4&gt;思路&lt;/h4&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;D. Playlist&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;李华有编号 $1~n$ 的 $n$ 首歌循环播放，每首歌都有一个自己的类型 $a_i$ 。当现在这首歌和上一首歌的类型的 $gcd$ 等于 $1$ 时，他就会怒删当前这首歌，然后从后面那手歌重新开始听（也就是说不会删连续两首歌），求删除的歌的数量和删除的顺序。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行一个整数 $t(1≤t≤10000)$ ，表示数据组数。&lt;/p&gt;
&lt;p&gt;每组数据第一行一个整数 $n(1≤n≤10^5)$ 。&lt;/p&gt;
&lt;p&gt;接下来 $n$ 个整数 $a_1，a_2，\dots，a_n(1≤a_i≤10^9)$ 。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;对于每组数据，先输出一个整数 $k$ ，表示被删除的歌曲数，接着输出这 $k$ 首歌曲的编号&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;5
5
5 9 2 10 15
6
1 2 4 2 4 2
2
1 2
1
1
1
2
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;2 2 3 
2 2 1 
2 2 1 
1 1 
0 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;h4&gt;思路&lt;/h4&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;请参阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://blog.csdn.net/hhhenjoy/article/details/115097007&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://blog.csdn.net/Stevenwuxu/article/details/115190151&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>【OI考古】图论 | 最近公共祖先 LCA</title><link>https://blog.vonbrank.com/posts/oi-graph-theory-lowest-common-ancestor/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/oi-graph-theory-lowest-common-ancestor/</guid><pubDate>Mon, 05 Apr 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;最近公共祖先简称 LCA（Lowest Common Ancestor）。两个节点的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个。&lt;/p&gt;
&lt;p&gt;以人的肉眼看来，一棵树上任意两点的 LCA 位置是显然的，然而对于计算机来说，最朴素的算法便是遍历整棵树来寻找 LCA，当询问次数很多的时候，朴素算法的效率将非常低下。本文将介绍几种常见的快速求解 LCA 的算法。&lt;/p&gt;
&lt;h3&gt;模板题：&lt;a href=&quot;https://www.luogu.com.cn/problem/P3379&quot;&gt;洛谷 P3379 | [模板] 最近公共祖先（LCA）&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行包含三个正整数 $N,M,S$ ，分别表示树的结点个数、询问的个数和树根结点的序号。&lt;/p&gt;
&lt;p&gt;接下来 $N-1$ 行每行包含两个正整数 $x, y$ ，表示 $x$ 结点和 $y$ 结点之间有一条直接连接的边（数据保证可以构成树）。&lt;/p&gt;
&lt;p&gt;接下来 $M$ 行每行包含两个正整数 $a, b$ ，表示询问 $a$ 结点和 $b$ 结点的最近公共祖先。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出包含 $M$ 行，每行包含一个正整数，依次为每一个询问的结果。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;5 5 4
3 1
2 4
5 1
1 4
2 4
3 2
3 5
1 2
4 5
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;4
4
1
4
4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;p&gt;对于 $30%$ 的数据， $N\leq 10$ ， $M\leq 10$ 。&lt;/p&gt;
&lt;p&gt;对于 $70%$ 的数据， $N\leq 10000$ ， $M\leq 10000$ 。&lt;/p&gt;
&lt;p&gt;对于 $100%$ 的数据， $N\leq 500000$ ， $M\leq 500000$ 。&lt;/p&gt;
&lt;p&gt;样例中的树结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/04/05/cMdD39.png&quot; alt=&quot;cMdD39.png&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;树上倍增&lt;/h2&gt;
&lt;h3&gt;思路：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$DFS$ 计算每个节点的深度，保存在&lt;code&gt;depth[i]&lt;/code&gt;数组中。此过程时间复杂度 $O(n)$ 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算&lt;code&gt;fa[i][j]&lt;/code&gt;数组，其表示第 $i$ 个节点的第 $2^j$ 个父亲的编号，满足以下性质：&lt;/p&gt;
&lt;p&gt;$$fa[i][j] = fa[fa[i][j-1]][j-1]$$&lt;/p&gt;
&lt;p&gt;利用此性质可以在 $DFS$ 过程中初始化 $fa[i][0]$ 的值，然后逐一计算所有的 $fa[i][j]$ 。此过程时间复杂度 $O(n\log_{}{n})$ 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询 $a，b$ 的 $LCA$ 过程中，应首先用倍增法，让深度较深的节点跳至与另一节点同一高度，然后二者同事倍增，最后跳到 $LCA$ 的子节点，此时 $a$ 或 $b$ 的父节点就是 $LCA$ 。此过程时间复杂度 $O(n\log_{}{n})$ 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
const int maxn = 500500;
const int maxlog = 20;
int n, m, s, cnt;
int head[maxn], fa[maxn][25], depth[maxn];
struct Node
{
    int to, next;
} G[maxn * 2];
void addedge(int u, int v)	//链式前向星存图
{
    ++cnt;
    G[cnt].to = v;
    G[cnt].next = head[u];
    head[u] = cnt;
}
void dfs(int u)	//DFS计算出深度，初始化fa[u][0]
{
    depth[u] = depth[fa[u][0]] + 1;
    for (int i = head[u]; i; i = G[i].next)
    {
        int v = G[i].to;
        if (v == fa[u][0])
            continue;
        fa[v][0] = u;
        dfs(v);
    }
}
int lca(int x, int y)	//查询LCA
{
    if (depth[x] &amp;lt; depth[y])	//钦定x为深度较大的节点，若不然，则交换x, y的值
        swap(x, y);
    for (int i = maxlog; i &amp;gt;= 0; i--)
    {
        if (depth[fa[x][i]] &amp;gt;= depth[y])	//如果x往上跳时，深度比y高，说明可以跳
            x = fa[x][i];
    }
    if (x == y)	//如果同步深度之后正好在同一节点，说明这就是LCA
        return x;
    for (int i = maxlog; i &amp;gt;= 0; i--)
    {
        if (fa[x][i] == fa[y][i])	//如果是第2^i个父节点是同一个，说明跳过头了
            continue;
        x = fa[x][i];	//如果不是同一个，说明可以跳
        y = fa[y][i];
    }
    return fa[x][0];	//最后x的第1个父节点就是LCA
}
int main()
{
    scanf(&quot;%d %d %d&quot;, &amp;amp;n, &amp;amp;m, &amp;amp;s);
    for (int i = 1; i &amp;lt; n; i++)
    {
        int x, y;
        scanf(&quot;%d %d&quot;, &amp;amp;x, &amp;amp;y);
        addedge(x, y);
        addedge(y, x);
    }
    dfs(s);
    for (int j = 1; j &amp;lt;= maxlog; j++)	//应先固定j，找出所有i的第2^j个父节点，否则会出错
    {
        for (int i = 1; i &amp;lt;= n; i++)
        {
            fa[i][j] = fa[fa[i][j - 1]][j - 1];
        }
    }
    for (int i = 1; i &amp;lt;= m; i++)
    {
        int a, b;
        scanf(&quot;%d %d&quot;, &amp;amp;a, &amp;amp;b);
        printf(&quot;%d\n&quot;, lca(a, b));
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Tarjan 算法&lt;/h2&gt;
&lt;h3&gt;思路：&lt;/h3&gt;
&lt;p&gt;利用 Tarjan 算法求 LCA 需要结合并查集。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化并查集，对于每个节点 $u$ ，设 $fa[u]=u$ 。&lt;/li&gt;
&lt;li&gt;在 Tarjan 算法的执行过程中，如果当前 DFS 到点 $u$ ，先继续 DFS 其子节点 $v$ ，再将 $fa[v]$ 设为 $u$ 。&lt;/li&gt;
&lt;li&gt;对于以 $u$ 为根的子树，考察其下的一对 LCA 查询 $a，b$ 。若 $a$ 已经被 DFS 完成，则记录其完成状态，当 DFS 至 $b$ 时，发现 $a$ 已被访问，此时使用并查集查询 $a$ 所属并查集的根节点，由于此时以 $u$ 为根的子树还没有 DFS 完成，即 $fa[u]=u$ ，故查询结果为 $u$ 本身， $u$ 即为 $a，b$ 的最近公共祖先 LCA。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;vector&amp;gt;
using namespace std;
const int maxn = 500500;
int n, m, s, cnt;
int head[maxn], fa[maxn], ans[maxn];
bool vis[maxn];
vector&amp;lt;int&amp;gt; query_list[maxn], query_id[maxn];
struct Node
{
    int to, next;
} G[maxn * 2];
void addedge(int u, int v)
{
    ++cnt;
    G[cnt].to = v;
    G[cnt].next = head[u];
    head[u] = cnt;
}
int getfa(int x)	//查询并查集根节点
{
    return fa[x] == x ? x : fa[x] = getfa(fa[x]);
}
void tarjan(int u)
{
    vis[u] = true;
    for (int i = head[u]; i; i = G[i].next)
    {
        int v = G[i].to;
        if (vis[v])
            continue;
        tarjan(v);	//先DFS每个子节点，再将v划分为u的子节点
        fa[v] = u;
    }
    for (int i = 0; i &amp;lt; query_list[u].size(); i++)	//检查所有关于u的询问
    {
        int v = query_list[u][i];
        if (!vis[v] || ans[query_id[u][i]])	//如果询问对应的节点未访问，或者该询问已经被处理过，则跳过
            continue;						//重复处理询问将导致出错
        ans[query_id[u][i]] = getfa(v);	//该询问的答案为v的根节点
    }
}
int main()
{
    scanf(&quot;%d %d %d&quot;, &amp;amp;n, &amp;amp;m, &amp;amp;s);
    for (int i = 1; i &amp;lt; n; i++)
    {
        int x, y;
        scanf(&quot;%d %d&quot;, &amp;amp;x, &amp;amp;y);
        addedge(x, y);
        addedge(y, x);
    }
    for (int i = 1; i &amp;lt;= n; i++)
    {
        int a, b;
        scanf(&quot;%d %d&quot;, &amp;amp;a, &amp;amp;b);
        query_list[a].push_back(b);	//保存与每个节点有关的询问，和询问的编号
        query_list[b].push_back(a);
        query_id[a].push_back(i);
        query_id[b].push_back(i);
    }
    for (int i = 1; i &amp;lt;= n; i++)	//初始化并查集
        fa[i] = i;
    tarjan(s);
    for (int i = 1; i &amp;lt;= n; i++)
    {
        printf(&quot;%d\n&quot;, ans[i]);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;数链剖分&lt;/h2&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;先对给出的树进行树链剖分，划分出重轻链，可依托以下几个数组进行划分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;size[]&lt;/code&gt;： $size[u]$ 表示以 $u$ 为根的子树的重量，每个节点对子树的贡献为 $1$ 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;son[]&lt;/code&gt;： $son[u]$ 为 $u$ 的所有子节点中 $v_i$ ， $size[v_i]$ 值最大的 $v_i$ ， $u -&amp;gt; v_i$ 称为重链，一条树链由若干连续重链构成。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;top[]&lt;/code&gt;： $top[u]$ 表示 $u$ 所在树链的顶部节点编号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上数组可以用两次 DFS 求得。&lt;/p&gt;
&lt;p&gt;然后开始求 LCA，对于每对 LCA 的询问 $a，b$ ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 $a，b$ 在同一条树链身上，则 LCA 为深度较浅的节点。&lt;/li&gt;
&lt;li&gt;如果 $a，b$ 不在同一条树链身上，则每次让 $top$ 的深度较小者跳至其 $top$ 的父节点，直到两点到达同一条重链，再根据上一条求 LCA 即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
const int maxn = 500500;
int n, m, s, cnt;
int head[maxn], depth[maxn], size[maxn], son[maxn], top[maxn], fa[maxn];
struct Node
{
    int to, next;
} G[maxn * 2];
void addedge(int u, int v)
{
    ++cnt;
    G[cnt].to = v;
    G[cnt].next = head[u];
    head[u] = cnt;
}
void dfs1(int u)	//求depth[], size[], son[]
{
    size[u] = 1;
    depth[u] = depth[fa[u]] + 1;
    for (int i = head[u]; i; i = G[i].next)
    {
        int v = G[i].to;
        if (v == fa[u])
            continue;
        fa[v] = u;
        dfs1(v);
        size[u] += size[v];
        if (size[v] &amp;gt; size[son[u]])
            son[u] = v;
    }
}
void dfs2(int u)	//求top[]
{
    if (son[fa[u]] == u)
        top[u] = top[fa[u]];
    else
        top[u] = u;
    for (int i = head[u]; i; i = G[i].next)
    {
        int v = G[i].to;
        if (v == fa[u])
            continue;
        dfs2(v);
    }
}
int lca(int x, int y)
{
    while (top[x] != top[y])
    {
        if (depth[top[x]] &amp;lt; depth[top[y]])	//每次让top值深度较小者上跳至fa[top]，直到两者在同一条树链上
            swap(x, y);
        x = fa[top[x]];
    }
    return depth[x] &amp;lt; depth[y] ? x : y;	//同一条树链上的深度较小者为LCA
}
int main()
{
    scanf(&quot;%d %d %d&quot;, &amp;amp;n, &amp;amp;m, &amp;amp;s);
    for (int i = 1; i &amp;lt; n; i++)
    {
        int x, y;
        scanf(&quot;%d %d&quot;, &amp;amp;x, &amp;amp;y);
        addedge(x, y);
        addedge(y, x);
    }
    dfs1(s);
    dfs2(s);
    for (int i = 1; i &amp;lt;= m; i++)
    {
        int a, b;
        scanf(&quot;%d %d&quot;, &amp;amp;a, &amp;amp;b);
        printf(&quot;%d\n&quot;, lca(a, b));
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;请参阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://oi-wiki.org/graph/lca/&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>【Codeforces】 题解 - Round 707 (Div.2)</title><link>https://blog.vonbrank.com/posts/codeforces-solution-round-707-div-2/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/codeforces-solution-round-707-div-2/</guid><pubDate>Wed, 31 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;本文合作者：&lt;a href=&quot;https://laybxc.github.io/&quot;&gt;laybxc&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;赛事信息&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;出题人&lt;/th&gt;
&lt;th&gt;开始时间&lt;/th&gt;
&lt;th&gt;时长&lt;/th&gt;
&lt;th&gt;官方题解&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://codeforces.com/contest/1501&quot;&gt;Codeforces Round #707 (Div. 2, based on Moscow Open Olympiad in Informatics)&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://codeforces.com/profile/4qqqq&quot;&gt;4qqqq&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/Akulyat&quot;&gt;Akulyat&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/Aleks5d&quot;&gt;Aleks5d&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/DebNatkh&quot;&gt;DebNatkh&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/Endagorion&quot;&gt;Endagorion&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/GlebsHP&quot;&gt;GlebsHP&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/KiKoS&quot;&gt;KiKoS&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/Nebuchadnezzar&quot;&gt;Nebuchadnezzar&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/NiceClock&quot;&gt;NiceClock&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/Siberian&quot;&gt;Siberian&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/Zlobober&quot;&gt;Zlobober&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/alexX512&quot;&gt;alexX512&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/biection&quot;&gt;biection&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/cdkrot&quot;&gt;cdkrot&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/ch_egor&quot;&gt;ch_egor&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/grphil&quot;&gt;grphil&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/isaf27&quot;&gt;isaf27&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/ismagilov.code&quot;&gt;ismagilov.code&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/meshanya&quot;&gt;meshanya&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/vintage_Vlad_Makeev&quot;&gt;vintage_Vlad_Makeev&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/voidmax&quot;&gt;voidmax&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/wrg0ababd&quot;&gt;wrg0ababd&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://www.timeanddate.com/worldclock/fixedtime.html?day=13&amp;amp;month=3&amp;amp;year=2021&amp;amp;hour=9&amp;amp;min=05&amp;amp;sec=0&quot;&gt;Mar/13/2021&amp;lt;br/&amp;gt;17:05 (UTC+8)&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;02:30&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://codeforces.com/blog/entry/88591&quot;&gt;Codeforces Round #707 Editorial&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;A. Alexey and Train&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;从时间0开始出发，要依次经过在一条直线上的 $n$ 个站点，问到达站点n的时间。
每个站点 $i$ 都有对应的时间 $a_i,b_i,t_i$
从站点 $i-1$ 到站点i的路上需要花费时间 $a_i-b_{i-1}+t_i$
到达站点 $i$ 后，从站点 $i$ 出发到下个站点需要满足两个条件:
1.在站点 $i$ 至少需要等待 $⌈\frac {b_i-a_i} 2⌉$ 的时间
2.出发的时间不能在 $b_i$ 时间前&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行包括一个整数 $t(1≤t≤100)$ ，表示数据组数&lt;/p&gt;
&lt;p&gt;每组数据的第一行包括一个整数 $n$ ，表示站台的数量。&lt;/p&gt;
&lt;p&gt;接下来 $n$ 行包括两个整数：  $a_i , b_i(1≤ai&amp;lt;bi≤10^6)$ ，数据保证 $b_i&amp;lt;a_{i+1}$ 。&lt;/p&gt;
&lt;p&gt;接下来一行包括 $n$ 个整数 $t_1,t_2,...,t_n(0≤t_i≤10^6)$&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;对于每组数据，输出到达&lt;strong&gt;最后一个车站的时间&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;2
2
2 4
10 12
0 2
5
1 4
7 8
9 10
13 15
19 20
1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;12
32
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;h4&gt;思路：&lt;/h4&gt;
&lt;p&gt;本题难点在读题环节，把题目理解清楚之后，按照题意来直接模拟即可。&lt;/p&gt;
&lt;h4&gt;代码：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int N=150;
int n,T;
int a[N],b[N],t[N],x[N];
int main()
{
    ios::sync_with_stdio(0);
    cin&amp;gt;&amp;gt;T;
    while(T--)
    {
        cin&amp;gt;&amp;gt;n;
        int tim=0;
        memset(a,0,sizeof(a));
        memset(b,0,sizeof(b));
        memset(t,0,sizeof(t));
        for(int i=1;i&amp;lt;=n;i++)
        {
            cin&amp;gt;&amp;gt;a[i]&amp;gt;&amp;gt;b[i];
        }
        for(int i=1;i&amp;lt;=n;i++)
        {
            cin&amp;gt;&amp;gt;t[i];
        }
        for(int i=1;i&amp;lt;=n;i++)
        {
            x[i]=a[i]-b[i-1]+t[i];//发车时间
            tim+=x[i];
            int now=max(tim+(b[i]-a[i]+1)/2,b[i]);
            if(i!=n)tim+=now-tim;//只要不是最后一站就加上路上的时间
        }
        cout&amp;lt;&amp;lt;tim&amp;lt;&amp;lt;endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;B. Napoleon Cake&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;给你 $n$ 层蛋糕 ，第 $i$ 层上面有 $a_i$ 层奶油，奶油会向下渗透，多余的会浪费掉。问最后有每一层是否有奶油。&lt;/p&gt;
&lt;h4&gt;输入数据&lt;/h4&gt;
&lt;p&gt;第一行一个整数 $t$  ，表示测试数据组数。&lt;/p&gt;
&lt;p&gt;每组测试数据的第一行是一个整数 $n$ ，表示层数&lt;/p&gt;
&lt;p&gt;接下来一行是 $n$ 个整数 $a_i$ ，表示每层蛋糕上的奶油层数&lt;/p&gt;
&lt;h4&gt;输出数据&lt;/h4&gt;
&lt;p&gt;每组数据输出 $n$ 个整数，分别表示第 $i$ 层的奶油有无情况，用&lt;code&gt;0&lt;/code&gt;表示没有，&lt;code&gt;1&lt;/code&gt;表示有。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;3
6
0 3 0 0 1 3
10
0 0 0 1 0 5 0 0 0 2
3
0 0 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;1 1 0 1 1 1 
0 1 1 1 1 1 0 0 1 1 
0 0 0 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;h4&gt;思路&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;直接模拟，从后往前考虑涂奶油的区间即可。&lt;/li&gt;
&lt;li&gt;考虑区间处理，注意到 我们只关心奶油有没有，不关心有多少。根据题意考虑区间修改，并且题目背景是离线的，因此不需要使用线段树来维护，使用前缀和与差分的技巧即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;代码（差分做法）：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int N=2e5+20;
int n,t;
int a[N],b[N],ans[N],p[N];
int main()
{
    ios::sync_with_stdio(0);
    cin&amp;gt;&amp;gt;t;
    while(t--)
    {
        cin&amp;gt;&amp;gt;n;
        memset(b,0,sizeof(b));
        for(int i=1;i&amp;lt;=n;i++)
        {
            cin&amp;gt;&amp;gt;a[i];
            if(a[i])
            {
                b[max(1,i-a[i]+1)]+=1;
                b[i+1]-=1;
            }
        }
        ans[0]=0;
        for(int i=1;i&amp;lt;=n;i++)
        {
            ans[i]=ans[i-1]+b[i];
        }
        for(int i=1;i&amp;lt;=n;i++)
        {
            if(ans[i]&amp;gt;0)cout&amp;lt;&amp;lt;&quot;1 &quot;;
            else cout&amp;lt;&amp;lt;&quot;0 &quot;;
        }
        cout&amp;lt;&amp;lt;endl;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;代码（直接模拟）&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
using namespace std;
const int maxn = 200500;
int t, n;
int a[maxn];
bool vis[maxn];

int main()
{
    scanf(&quot;%d&quot;, &amp;amp;t);
    while (t--)
    {
        scanf(&quot;%d&quot;, &amp;amp;n);
        memset(vis, 0, sizeof(vis));
        for(int i=1; i&amp;lt;=n; i++)
        {
            scanf(&quot;%d&quot;, &amp;amp;a[i]);
        }
        for(int i=n; i&amp;gt;=1; i--)
        {
            int j = max(1, i - a[i] + 1);
            if(!vis[j])
            {
                while (j &amp;lt;= i)
                {
                    if(vis[j]) break;
                    vis[j] = true;
                    j++;
                }
            }
        }
        for(int i=1; i&amp;lt;=n; i++)
        {
            printf(&quot;%d &quot;, vis[i]);
        }
        puts(&quot;&quot;);
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;C. Going Home&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;给你一个整数序列，问你能不能找到下标不同的4个数使得 $a_x+a_y=a_z+a_w$&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行包括一个整数 $n$ ，表示整数序列的长度&lt;/p&gt;
&lt;p&gt;第二行包括 $n$ 个整数 $a_1,a_2,...,a_n$&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;如果能找到输出&lt;code&gt;YES&lt;/code&gt;，否则输出&lt;code&gt;NO&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果能找到，在第二行输出任意一组符合条件的 $x,y,z,w$ 。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;6
2 1 5 2 7 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;YES
2 3 1 6 
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输入 #2&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;5
1 3 1 9 20
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出 #2&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;NO
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;h4&gt;思路&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;最先想到的一定是去直接枚举 $x,y,z,w$ ，复杂度 $O(n^3)$ 显然没戏。&lt;/li&gt;
&lt;li&gt;一种简单的优化就是枚举序列中的 $( i , j )$ 然后判断之前有没有出现过这样的和 $su m=a_i+a_j$ ，这样做的做法是 $O(n^2)$ 的复杂度，原本觉得显然过不了&lt;/li&gt;
&lt;li&gt;但是实际上枚举的复杂度不是 $O(n^2)$ ，因为有： $1 ≤ a [i] ≤ 2.5e6$ ，于是有 $2 ≤ a [i] + a[j] ≤ 5e6 $ 。根据&lt;strong&gt;抽屉原理&lt;/strong&gt;，如果我们枚举了 $5e6+1$ 对两两不同的 $( i , j )$ ，那么一定存在两对不同的 $( i , j )$ 有相同的和。这样一来时间复杂度就是 $O(min(n^2,5e6))$ ，完全可以接受！&lt;/li&gt;
&lt;li&gt;实际上的复杂度会比 $5e6$ 稍高一点，上界大约是 存在四对数等于同一个 $sum$ 时出现，即 $2.5e6\times4 = 1e7$ ，仍然可以接受。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
typedef pair&amp;lt;int,int&amp;gt; pii;
const int N=2e5+20;
const int M=5e6+20;
pii b[M];
int sum,n;
int a[N];
int ans=0;
int main()
{
    ios::sync_with_stdio(0);
	cin&amp;gt;&amp;gt;n;
	for(int i=1;i&amp;lt;=n;i++)
    {
        cin&amp;gt;&amp;gt;a[i];
    }
	for(int i=1;i&amp;lt;=n;i++)
    {
        for(int j=i+1;j&amp;lt;=n;j++)
        {
            sum=a[i]+a[j];
            if(b[sum].first)
            {
                if(b[sum].first!=i and b[sum].second!=i and b[sum].first!=j and b[sum].second!=j)
                {
                    cout&amp;lt;&amp;lt;&quot;YES&quot;&amp;lt;&amp;lt;endl;
                    cout&amp;lt;&amp;lt;b[sum].first&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;b[sum].second&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;j;
                    ans=1;
                    break;
                }
            }
            else b[sum]=make_pair(i,j);
        }
        if(ans==1)break;
    }
	if(!ans)cout&amp;lt;&amp;lt;&quot;NO&quot;&amp;lt;&amp;lt;endl;
    return 0; 
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;D.Two chandeliers&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;给出两个数组 $a，b$ ，长度分别为 $n，m$ ，第 $i$ 时刻， $a$ 数组当前指向下标为 $( i − 1 ) % n + 1$ ， $b$ 数组指向下标为 $( i − 1 ) % m + 1$ 。&lt;/p&gt;
&lt;p&gt;若两个数不同，则计数，当计数到达 $k$ 时，求当前的时刻。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行三个整数 $n，m，k$ ，表示两个灯光序列的长度和参数 $k$ 。&lt;/p&gt;
&lt;p&gt;第二行 $n$ 个整数，表示第一个灯光序列。&lt;/p&gt;
&lt;p&gt;第三行 $m$ 个整数，表示第二个灯光序列。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一个整数，当计数到达 $k$ 时的时刻。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;4 2 4
4 2 3 1
2 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;5
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输入 #2&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;3 8 41
1 3 2
1 6 4 3 5 7 2 8
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出 #2&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;47
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输入 #3&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;1 2 31
1
1 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出 #3&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;62
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;p&gt;扩展中国剩余定理不会，之后再补...&lt;/p&gt;
&lt;h2&gt;请参阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://blog.csdn.net/WedsonLin/article/details/114786591&lt;/li&gt;
&lt;li&gt;https://blog.csdn.net/weixin_45755679/article/details/114952203&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>【OI考古】数据结构 | 线段树</title><link>https://blog.vonbrank.com/posts/oi-data-structure-segment-tree/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/oi-data-structure-segment-tree/</guid><pubDate>Wed, 31 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;线段树是算法竞赛中常用的用来维护 &lt;strong&gt;区间信息&lt;/strong&gt; 的数据结构。&lt;/p&gt;
&lt;p&gt;线段树可以在 $n\log_{}{n}$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。&lt;/p&gt;
&lt;p&gt;线段树维护的信息，需要满足可加性，即能以可以接受的速度合并信息和修改信息，包括在使用懒惰标记时，标记也要满足可加性（例如取模就不满足可加性，对 $3$ 取模然后对 $4$ 取模，两个操作就不能合并在一起做）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/03/31/ckUHD1.png&quot; alt=&quot;ckUHD1.png&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;加法线段树&lt;/h2&gt;
&lt;h3&gt;模板题：&lt;a href=&quot;https://www.luogu.com.cn/problem/P3372&quot;&gt;洛谷 P3372  | [模板] 线段树 1&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;如题，已知一个数列，你需要进行下面两种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将某区间每一个数加上 $k$ 。&lt;/li&gt;
&lt;li&gt;求出某区间每一个数的和。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行包含两个整数 $n, m$ 分别表示该数列数字的个数和操作的总个数。&lt;/p&gt;
&lt;p&gt;第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。&lt;/p&gt;
&lt;p&gt;接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;1 x y k&lt;/code&gt;：将区间 $[x, y]$ 内每个数加上 $k$ 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 x y&lt;/code&gt;：输出区间 $[x, y]$ 内每个数的和。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出包含若干行整数，即为所有操作 &lt;code&gt;2&lt;/code&gt; 的结果。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;5 5
1 5 4 2 3
2 2 4
1 2 3 2
2 3 4
1 1 5 1
2 1 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;11
8
20
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;p&gt;对于 $30%$ 的数据： $n \le 8，m \le 10$ 。
对于 $70%$ 的数据： $n \le {10}^3，m \le {10}^4$ 。
对于 $100%$ 的数据： $1 \le n, m \le {10}^5$ 。&lt;/p&gt;
&lt;p&gt;保证任意时刻数列中任意元素的和在 $[-2^{63}, 2^{63})$ 内。&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
const int maxn = 100500;
int n, m;
long long a[maxn], tree[maxn &amp;lt;&amp;lt; 2], lazy[maxn &amp;lt;&amp;lt; 2];	//开四倍空间

void pushup(int rt)
{
    tree[rt] = tree[rt &amp;lt;&amp;lt; 1] + tree[rt &amp;lt;&amp;lt; 1 | 1];
}

void pushdown(int rt, int ln, int rn)
{
    if (lazy[rt])	//下传lazy标签
    {
        lazy[rt &amp;lt;&amp;lt; 1] += lazy[rt];
        lazy[rt &amp;lt;&amp;lt; 1 | 1] += lazy[rt];
        tree[rt &amp;lt;&amp;lt; 1] += ln * lazy[rt];
        tree[rt &amp;lt;&amp;lt; 1 | 1] += rn * lazy[rt];
        lazy[rt] = 0;
    }
}

void build(int l, int r, int rt)
{
    if (l == r)
    {
        tree[rt] = a[l];
        return;
    }
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    build(l, mid, rt &amp;lt;&amp;lt; 1);
    build(mid + 1, r, rt &amp;lt;&amp;lt; 1 | 1);
    pushup(rt);
}

void add(int L, int R, int l, int r, int rt, int k)
{
    if (L &amp;lt;= l &amp;amp;&amp;amp; R &amp;gt;= r)
    {
        tree[rt] += (r - l + 1) * k;
        lazy[rt] += k;
        return;
    }
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    pushdown(rt, mid - l + 1, r - mid);
    if (L &amp;lt;= mid)
        add(L, R, l, mid, rt &amp;lt;&amp;lt; 1, k);
    if (R &amp;gt; mid)
        add(L, R, mid + 1, r, rt &amp;lt;&amp;lt; 1 | 1, k);
    pushup(rt);	//每次更新都记得pushup一下
}

long long query(int L, int R, int l, int r, int rt)
{
    if (L &amp;lt;= l &amp;amp;&amp;amp; R &amp;gt;= r)
    {
        return tree[rt];
    }
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    pushdown(rt, mid - l + 1, r - mid);
    long long ans = 0;
    if (L &amp;lt;= mid)
        ans += query(L, R, l, mid, rt &amp;lt;&amp;lt; 1);
    if (R &amp;gt; mid)
        ans += query(L, R, mid + 1, r, rt &amp;lt;&amp;lt; 1 | 1);
    return ans;
}

int main()
{
    scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;m);
    for (int i = 1; i &amp;lt;= n; i++)
    {
        scanf(&quot;%d&quot;, &amp;amp;a[i]);
    }
    build(1, n, 1);
    for (int i = 1; i &amp;lt;= m; i++)
    {
        int op, x, y, k;
        scanf(&quot;%d&quot;, &amp;amp;op);
        if (op == 1)
        {
            scanf(&quot;%d %d %d&quot;, &amp;amp;x, &amp;amp;y, &amp;amp;k);
            add(x, y, 1, n, 1, k);
        }
        if (op == 2)
        {
            scanf(&quot;%d %d&quot;, &amp;amp;x, &amp;amp;y);
            printf(&quot;%lld\n&quot;, query(x, y, 1, n, 1));
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;乘法线段树&lt;/h2&gt;
&lt;h2&gt;请参阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://oi-wiki.org/ds/seg/&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>在Windows下编写C++对拍程序（真随机数）</title><link>https://blog.vonbrank.com/posts/std-checker/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/std-checker/</guid><pubDate>Sun, 28 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;对拍，即将相同的数据输入两个不同程序，比对其输出结果。可以用于在ACM/OI等比赛中用暴力算法检测标算的正确性，寻找使程序出错的样例数据。&lt;/p&gt;
&lt;h2&gt;随机数生成器&lt;/h2&gt;
&lt;p&gt;要编写好用的对拍程序，首要的是要编写一个随机数生成器，便于产生多样化的数据。&lt;/p&gt;
&lt;h3&gt;朴素随机数生成器&lt;/h3&gt;
&lt;p&gt;相信很多人都见过下面这种写法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//DataGenerator_naive.cpp
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;ctime&amp;gt;
using namespace std;

int main(int argc, char *argv[])
{
    int seed = time(NULL);
    srand(seed);

    //以下代码可以生成10个随机整数
    int n = 10;
    for (int i = 1; i &amp;lt;= n; i++)
    {
		printf(&quot;%d &quot;, rand());
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是这样的写法有个问题，在Windows下&lt;code&gt;time(NULL)&lt;/code&gt;获取的是自 $1970$ 年 $1$ 月 $1$ 日至今经过的秒数，也就是说同一秒内获得的随机数种子是一样的，即我们每秒只能获得一组有效的随机样例，这样的效率太低，不是我们可以接受的。&lt;/p&gt;
&lt;h3&gt;利用命令行随机数种子&lt;/h3&gt;
&lt;p&gt;事实上，Windows命令行自带了一个随机数生成器&lt;code&gt;%random%&lt;/code&gt;，每次调用都可以获得一个不同的整数，能够作为随机数种子，可以将上面的程序改写一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//DataGenerator_cmd.cpp
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;ctime&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
stringstream ss;

int main(int argc, char *argv[])
{
    int seed = time(NULL);
    if (argc &amp;gt; 1) //如果有参数
    {
        ss.clear();
        ss &amp;lt;&amp;lt; argv[1];
        ss &amp;gt;&amp;gt; seed; //把参数转换成整数赋值给seed
    }
    srand(seed);

    //以下代码可以生成10个随机整数
    int n = 10;
    for (int i = 1; i &amp;lt;= n; i++)
    {
		printf(&quot;%d &quot;, rand());
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们利用了&lt;code&gt;main&lt;/code&gt;函数的传入参数，&lt;code&gt;argc&lt;/code&gt;表示参数个数，&lt;code&gt;argv[]&lt;/code&gt;表示每个参数的值，以字符串形势表示。&lt;/p&gt;
&lt;p&gt;以下命令可以通过调用&lt;code&gt;%random%&lt;/code&gt;，并传入&lt;code&gt;DataGenerator_cmd.exe&lt;/code&gt;，使得每次运行都能获得不同的种子，并将生成的随机数写入&lt;code&gt;in.txt&lt;/code&gt;，以供目标程序读取数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DataGenerator_cmd.exe %random% &amp;gt; in.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;利用系统的加密秘钥生成器生成随机数&lt;/h3&gt;
&lt;p&gt;下面这个 &lt;code&gt;WinRandom&lt;/code&gt; 类调用了系统的加密秘钥生成器，这个生成器调用内核生成秘钥，所以是硬件的真随机数，可将其写成头文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//WinRandom.h
#include &amp;lt;windows.h&amp;gt;
#include &amp;lt;wincrypt.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
class WinRandom
{
    HCRYPTPROV handle;

public:
    WinRandom()
    {
        handle = NULL;
        CryptAcquireContext(
            (HCRYPTPROV *)&amp;amp;handle, NULL, NULL,
            PROV_RSA_FULL, 0);
    }
    ~WinRandom()
    {
        if (handle != NULL)
            CryptReleaseContext(handle, 0);
    }
    bool randBuf(void *dest, int len)
    {
        if (handle == NULL)
            return false;
        return CryptGenRandom(handle, len, (BYTE *)dest);
    }
#define _(func, typ)                                \
    typ func()                                      \
    {                                               \
        typ ret = 0;                                \
        assert(randBuf((void *)&amp;amp;ret, sizeof(ret))); \
        return ret;                                 \
    }
    _(randInt, int)
    _(randLong, long long)
    _(randUnsigned, unsigned)
    _(randUnsignedLong, unsigned long long)
    _(randShort, short)
    _(randUnsignedShort, unsigned short)
    _(randChar, char)
    _(randUnsignedChar, unsigned char)
    _(randSignedChar, signed char)
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将上面的程序再改写以下，调用&lt;code&gt;WinRandom&lt;/code&gt;类，就可以实现真随机数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//DataGenerator_WR.cpp
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &quot;WinRandom.h&quot;
using namespace std;

int main()
{
    WinRandom R;
    //用 R.randInt() 来返回一个随机的int型变量

    //以下代码可以生成10个随机整数
    int n = 10;
    for (int i = 1; i &amp;lt;= n; i++)
    {
		printf(&quot;%d &quot;, R.randInt());
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;对拍程序&lt;/h2&gt;
&lt;p&gt;这里的对拍程序通过 &lt;code&gt;system()&lt;/code&gt;函数在C++程序内执行命令行指令，你可以自定义目标程序位置和随机数生成器位置等：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//checker.cpp
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;windows.h&amp;gt;
using namespace std;

int main()
{
    int type;	//选择生成器类型
    printf(&quot;input random generator type:\n&quot;);
    printf(&quot;1: naive\n&quot;);
    printf(&quot;2: cmdRandom\n&quot;);
    printf(&quot;3: WinRandom\n&quot;);
    scanf(&quot;%d&quot;, &amp;amp;type);

    int t = 100000;
    string Std = R&quot;(&quot;{标算位置}.exe&quot;)&quot;;
    string Mtd = R&quot;(&quot;{你的程序位置}.exe&quot;)&quot;;
    string DataGenerator;
    if (type == 3)
        DataGenerator = R&quot;(&quot;{WR生成器位置}\DataGenerator_WR.exe&quot;)&quot;;
    else
        DataGenerator = R&quot;(&quot;{cmd生成器位置}\DataGenerator_cmd.exe&quot;)&quot;;
    string in_txt = &quot;in.txt&quot;;
    string mtd_out_txt = &quot;mtd-out.txt&quot;;
    string std_out_txt = &quot;std-out.txt&quot;;
    while (t--)
    {
        if (type == 2)
            system((DataGenerator + &quot; %random%&quot; + &quot; &amp;gt; &quot; + in_txt).data());
        else
            system((DataGenerator + &quot; &amp;gt; &quot; + in_txt).data());
        // printf(&quot;%s\n&quot;, (in_txt + &quot; &amp;lt; &quot; + Mtd + &quot; &amp;gt; &quot; + mtd_out_txt).data());
        system((Mtd + &quot; &amp;lt; &quot; + in_txt + &quot; &amp;gt; &quot; + mtd_out_txt).data());
        system((Std + &quot; &amp;lt; &quot; + in_txt + &quot; &amp;gt; &quot; + std_out_txt).data());
        if (system((&quot;fc &quot; + mtd_out_txt + &quot; &quot; + std_out_txt).data()))
            system(&quot;pause&quot;);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;请参阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://blog.csdn.net/wlx65003/article/details/51149196&lt;/li&gt;
&lt;li&gt;https://blog.csdn.net/weixin_30519071/article/details/97889166&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>【Codeforces】 题解 - Round 706 (Div.2)</title><link>https://blog.vonbrank.com/posts/codeforces-solution-round-706-div-2/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/codeforces-solution-round-706-div-2/</guid><pubDate>Sat, 27 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;本文合作者：&lt;a href=&quot;https://laybxc.github.io/&quot;&gt;laybxc&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;赛事信息&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;出题人&lt;/th&gt;
&lt;th&gt;开始时间&lt;/th&gt;
&lt;th&gt;时长&lt;/th&gt;
&lt;th&gt;官方题解&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://codeforces.com/contest/1496&quot;&gt;Codeforces Round #706 (Div. 2)&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://codeforces.com/profile/Daniel_yuan&quot;&gt;Daniel_yuan&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/Imakf&quot;&gt;Imakf&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/smg23333&quot;&gt;smg23333&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/waaitg&quot;&gt;waaitg&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://www.timeanddate.com/worldclock/fixedtime.html?day=10&amp;amp;month=3&amp;amp;year=2021&amp;amp;hour=12&amp;amp;min=05&amp;amp;sec=0&quot;&gt;Mar/10/2021&amp;lt;br/&amp;gt;20:05 (UTC+8)&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;02:00&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://codeforces.com/blog/entry/88533&quot;&gt;Tutorial (en)&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;A. Split it!&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;给出一个长度为 $n$ 的字符串 $s$ 和一个整数 $k$ ，问其能否划分为如下形式：&lt;/p&gt;
&lt;p&gt;$s=a_1+a_2+\dots+a_k+a_{k+1}+R(a_k)+R(a_{k-1})+\dots+R(a_1)$&lt;/p&gt;
&lt;p&gt;其中， $R(x)$ 表示将 $x$ 反转得到的字符串。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行是一个整数 $t(1≤t≤100)$ ，表示数据组数。&lt;/p&gt;
&lt;p&gt;每组数据第一行有两个整数 $n,k(1≤n≤100,0≤k≤⌊\frac n 2⌋)$ ，表示字符串长度和参数 $k$ 。&lt;/p&gt;
&lt;p&gt;每组数据第二行是一个长度为 $n$ 字符串的 $s$ ，由小写字母组成。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;如果可以合法划分，则输出&lt;code&gt;YES&lt;/code&gt;，否则输出&lt;code&gt;NO&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;输出大写或小写都可以。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;7
5 1
qwqwq
2 1
ab
3 1
ioi
4 2
icpc
22 0
dokidokiliteratureclub
19 8
imteamshanghaialice
6 3
aaaaaa
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;YES
NO
YES
NO
YES
NO
NO
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;p&gt;对于第一组数据，一种可能的划分结果为： $a_1 = qw， a_2 = q$&lt;/p&gt;
&lt;p&gt;对于第二组数据，一种可能的划分结果为： $a_1 = i， a_2 = o$&lt;/p&gt;
&lt;p&gt;对于第三组数据，一种可能的划分结果为： $a_1 = dokidokiliteratureclub$&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;h4&gt;思路&lt;/h4&gt;
&lt;p&gt;注意到 $a_1+a_2+\dots+a_k$ 和 $R(a_k)+R(a_{k-1})+\dots+R(a_1)$ 互为反转串。&lt;/p&gt;
&lt;p&gt;因此，对于一个字符串 $s$ ，只要其存在一对长度大于等于 $k$ 的，互为反转串的前后缀 ，同时中间的非回文串不为空，即满足题意。&lt;/p&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
const int maxn = 1050;
int t, n, k;
char s[maxn];
bool check()
{
    int i = 1, j = n;
    while(s[i] == s[j] &amp;amp;&amp;amp; i &amp;lt; j)	//找出最长的互为反转串的前后缀
    {
        i++;
        j--;
    }
    if(i &amp;lt;= j)
    {
        if(i - 1 &amp;gt;= k) return true;	//保证存在合法长度的互为反转串的前后缀的前提下，中间的非回文串不为空
        else return false;
    }
    if(i &amp;gt; j)
    {
        if(i - 2 &amp;gt;= k) return true;	//保证存在合法长度的互为反转串的前后缀的前提下，中间的非回文串不为空
        else return false;
    }
}

int main()
{
    scanf(&quot;%d&quot;, &amp;amp;t);
    while(t)
    {
        scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;k);
        scanf(&quot;%s&quot;, s + 1);
        if(check())
            printf(&quot;YES\n&quot;);
        else
            printf(&quot;NO\n&quot;);
        
        t--;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;B. Max and Mex&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;定义 $max(S)$ 为集合 $S$ 的最大值， $mex(S)$ 为集合 $S$ 的最大非负整数值。&lt;/p&gt;
&lt;p&gt;给定一个整数集 $S$ ，然后将 「把 $⌈\frac {max(S) + mex(S)} {2} ⌉$ 插入 $S$ 中」的操作执行 $k$ 次，求最终 $S$ 中最后有多少个互不相同的数。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行一个整数 $t$ ，表示数据组数。&lt;/p&gt;
&lt;p&gt;每组数据第一行包含两个整数 $n,k$，表示集合 $S$ 的元素个数，以及操作次数。&lt;/p&gt;
&lt;p&gt;每组数据第二行包含这 $n$ 个整数 $a_1, a_2, \dots, a_n$ 构成的集合 $S$ 。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出 $k$ 次操作之后的集合 $S$ 中的元素个数。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;5
4 1
0 1 3 4
3 1
0 1 4
3 0
0 1 4
3 2
0 1 2
3 2
1 2 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;4
4
3
5
3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;p&gt;对于第一组数据，插入 $3$ ，最终的集合 $S$ 为 ${0,1,3,3,4}$ ，答案为 $4$ 。&lt;/p&gt;
&lt;p&gt;对于第二组数据，插入 $3$ ，最终的集合 $S$ 为 ${0,1,3,4}$ ，答案为 $4$ 。&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;h4&gt;思路&lt;/h4&gt;
&lt;p&gt;设 $S$ 中互不相同的元素个数为 $cnt$ 。&lt;/p&gt;
&lt;p&gt;先计算第一次操作获得的 $⌈\frac {max(S) + mex(S)} {2} ⌉$ ，记为 $mid$ 可分几种情况讨论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$mid &amp;lt; max$ ，且 $mid$ 在 $S$ 中存在：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;则不论操作多少次， $mid$ 都不会改变，也不会增加互不相同元素的个数，最终为 $cnt$ 。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$mid &amp;lt; max$ ，且 $mid$ 在 $S$ 中 &lt;strong&gt;不&lt;/strong&gt; 存在：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;则不论操作多少次， $mid$ 都不会改变， $S$ 中互不相同的元素个数最终为 $cnt+1$。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$mid ≥ max$ ：&lt;/p&gt;
&lt;p&gt;易见，每次操作中， $mid=mex = max + 1$ ，最终的 $S$ 中互不相同的元素个数为 $cnt+k$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
const int maxn = 100500;
int t, n, k;
int MAX, MEX, MID, cnt;
int a[maxn];

int main()
{
    scanf(&quot;%d&quot;, &amp;amp;t);
    a[0] = -1;
    while(t)
    {
        scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;k);

        for(int i=1; i&amp;lt;=n; i++)
        {
            scanf(&quot;%d&quot;, &amp;amp;a[i]);
        }
        sort(a+1, a+1+n);	//对a[]排序
        cnt = 0;
        for(int i=1; i&amp;lt;=n; i++)
        {
            if(a[i] != a[i-1]) cnt++;	//计算S中不同元素的个数cnt
        }

        if(k == 0)
        {
            t--;
            printf(&quot;%d\n&quot;, cnt);
            continue;
        }

        MAX = a[n];	//获得max
        bool flag = true;
        for(int i=0; i&amp;lt;=n-1; i++)
        {
            if(a[i+1] - a[i] &amp;gt;= 2)
            {
                MEX = a[i] + 1;
                flag = false;
                break;
            }
        }
        if(flag) MEX = a[n] + 1;	//计算mex

        if(MEX &amp;lt; MAX)
        {
            if((MEX + MAX) % 2 == 1) MID = (MEX + MAX + 1) / 2;
            else MID = (MEX + MAX) / 2;
            flag = false;
            for(int i=1; i&amp;lt;=n; i++)
            {
                if(a[i] == MID)
                {
                    flag = true;
                    break;
                }
            }
            if(flag) printf(&quot;%d\n&quot;, cnt);	//如果mex&amp;lt;max，且在S中存在，则输出cnt
            else printf(&quot;%d\n&quot;, cnt + 1);	//如果mex&amp;lt;max，且在S中不存在，在输出cnt+1
        }
        else
        {
            printf(&quot;%d\n&quot;, cnt + k);	//如果mex&amp;gt;max，则输出cnt+k
        }

        t--;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;C. Diamond Miner&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;$x$ 轴上有 $n$ 个点， $y$ 轴上有 $n$ 个点，将 $x$ 轴与 $y$ 轴上的点一一对应地连起来，最小化所有连线的距离。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行一个整数 $t(1≤t≤10)$ ，表示数据组数。&lt;/p&gt;
&lt;p&gt;每组数据第一行包含一个整数 $n(1≤n≤10^5)$，表示 $x$ 和 $y$ 轴上的点数。&lt;/p&gt;
&lt;p&gt;接下来 $2n$ 行每行两个整数 $x(-10^8≤x≤10^8), y(-10^8≤y≤10^8)$ 表示 $x$ 和 $y$ 轴上 $2n$ 个点的坐标。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;对于每组数据，输出一个实数表示答案。&lt;/p&gt;
&lt;p&gt;一般地，设你的答案为 $a$ ，标准答案为 $b$ ，满足以下条件的答案都可被判定正确：&lt;/p&gt;
&lt;p&gt;$$\frac {|a-b|} {max(1, |b|)} ≤ 10^{-9}$$&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;3
2
0 1
1 0
0 -1
-2 0
4
1 0
3 0
-5 0
6 0
0 3
0 1
0 2
0 4
5
3 0
0 4
0 -3
4 0
2 0
1 0
-3 0
0 -10
0 -2
0 -10
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;3.650281539872885
18.061819283610362
32.052255376143336
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;p&gt;对于第一组数据，方案如下，结果为 $\sqrt{2} + \sqrt{5}$ 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/03/27/6xVBB4.md.png&quot; alt=&quot;6xVBB4.md.png&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;h4&gt;思路&lt;/h4&gt;
&lt;p&gt;贪心做法，每次连接 $x$ 轴上离原点最近的点和离 $y$ 轴最近的点即可，时间复杂度 $O(n\log_{}{n})$ 。&lt;/p&gt;
&lt;h4&gt;证明&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;MAGIC&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;cmath&amp;gt;
using namespace std;
const int maxn = 100500;
class Point	//定义点类
{
public:
    long long x, y, dis;
    Point(long long x_, long long y_)
    {
        x = x_;
        y = y_;
        dis = sqrt(x * x + y * y);
    }
    bool operator&amp;lt;(const Point &amp;amp;b) const	//重载运算符，使得离原点越近的点在优先队列中越靠前
    {
        return dis &amp;gt; b.dis;
    }
};
int t, n;
double ans;
priority_queue&amp;lt;Point&amp;gt; X, Y;	//开两个优先队列，一个用于存在X轴上的点，另一个用于存在Y轴上的点
double P_dis(Point a, Point b)	//距离函数，返回两个点之间的欧式距离
{
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}
int main()
{
    scanf(&quot;%d&quot;, &amp;amp;t);
    while (t--)
    {
        ans = 0;
        while (!X.empty())
            X.pop();
        while (!Y.empty())
            Y.pop();
        scanf(&quot;%d&quot;, &amp;amp;n);
        for (int i = 1; i &amp;lt;= n * 2; i++)
        {
            long long x, y;
            scanf(&quot;%lld %lld&quot;, &amp;amp;x, &amp;amp;y);
            Point tmp(x, y);
            if (y == 0)	//纵坐标为0，说明在X轴上
            {
                X.push(tmp);
            }
            if (x == 0)	//横坐标为0，说明在Y轴上
            {
                Y.push(tmp);
            }
        }
        while (X.size() &amp;gt; n)	//弹出重复的(0, 0)点
        {
            X.pop();
        }
        while (Y.size() &amp;gt; n)
        {
            Y.pop();
        }

        while (!X.empty())	//每次选择队首的两个点取欧式距离，加入答案中
        {
            ans += P_dis(X.top(), Y.top());
            X.pop();
            Y.pop();
        }
        printf(&quot;%.15lf\n&quot;, ans);	//根据样例，保留15位小数
    }
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;D. Let&apos;s Go Hiking&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;有 $n$ 个格子个格子排成一排，每个格子有一个高度，高度各不相同，即这是一个 $1 \sim n$ 的排列。&lt;/p&gt;
&lt;p&gt;$Qingshan$ 首先选择一个起点，然后 $Daniel$ 再选择一个起点。然后 $Qingshan$ 和 $Daniel$ 两人轮流移动，每次可以往左或往右移动一格。两个人不能同时站在同一格。&lt;/p&gt;
&lt;p&gt;$Qingshan$ 只能往比当前位置低的格子移动， $Daniel$ 只能往比当前位置高的格子移动。&lt;/p&gt;
&lt;p&gt;$Qingshan$ 的位置记为 $x$ ，表示在排列中的位置， $Daniel$ 的位置记为 $y$ ，意义依此类推。&lt;/p&gt;
&lt;p&gt;轮到某人时如果他不能移动，则对方获胜。&lt;/p&gt;
&lt;p&gt;若两人都采取最优策略，问 $Qingshan$ 要获胜的话有多少种起点选择方案。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行一个整数，表示参数 $n(2≤n≤10^5)$ 。&lt;/p&gt;
&lt;p&gt;第二行 $n$ 个整数 $p_1, p_2, \dots, p_n$ ，表示 $1 \sim n$ 的一个排列。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出能使 $Qingshan$ 获胜的起点选择方案数。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;5
1 2 5 4 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输入 #2&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;7
1 2 4 6 5 3 7
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出 #2&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;p&gt;对于第一组数据， $Qingshan$ 只能选择从位置 $x=3$ 处开始移动，故输出&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于第二组数据，如果 $Qingshan$ 选择位置 $x=4$ ， $Daniel$ 可选择 $y=1$ ，第一轮中 $Qingshan$ 移动到 $x=3$ ，第二轮 $Daniel$ 移动到 $y=2$ ，第三轮中 $Qingshan$ 只能移动到 $x=2$ ，但是被 $Daniel$ 堵住了， $Qingshan$ 卒，故输出&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;h4&gt;思路&lt;/h4&gt;
&lt;p&gt;$Qingshan$ 必须选择一个山顶作为起点，否则如果 $Daniel$ 选择了和 $Qingshan$ 起点相邻的比 $Qingshan$ 低的点作为起点， $Qingshan$ 就会被堵住而无路可退。&lt;/p&gt;
&lt;p&gt;$Qingshan$ 需要选择下山路径最长的山顶作为起点，因为如果不是最长， $Daniel$ 就可以找到一条和 $Qingshan$ 无关的比 $Qingshan$ 下山路径长的上山路径。&lt;/p&gt;
&lt;p&gt;当 $Qingshan$ 选择了一个起点， $Daniel$ 必须选择 $Qingshan$ 最长下山路径上的一个点为起点，保证 $Qingshan$ 被胁迫着往另一个方向下山，而且和 $Qingshan$ 的距离不能为偶数，否则会被堵住。如果找不到这样的点，则 $Qingshan$ 有必胜策略，否则 $Daniel$ 有必胜策略。&lt;/p&gt;
&lt;p&gt;至此，程序的编写就不难了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先为 $Qingshan$ 找到下山路径最长的山顶作为起点。&lt;/li&gt;
&lt;li&gt;然后为 $Daniel$ 找一个最优的起点。&lt;/li&gt;
&lt;li&gt;此时判断 $Daniel$ 是否有必胜策略，如果有则输出&lt;code&gt;0&lt;/code&gt;，表明 $Qingshan$ 必输，否则输出&lt;code&gt;1&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;没错，你会发现只有&lt;code&gt;0&lt;/code&gt;或&lt;code&gt;1&lt;/code&gt;两种答案，如果这是OI赛制的题，随机输出就能得 $50$ 分。&lt;/p&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
const int maxn = 100500;
int n, ls, qingshan_spawn, direction, daniel_spawn;
int a[maxn], left_path_length[maxn], right_path_length[maxn];
int dfs(int loc, int pace)
{
    int *p = pace == -1 ? &amp;amp;left_path_length[loc] : &amp;amp;right_path_length[loc];
    if (loc + pace == 0 || loc + pace == n + 1)
        return *p = 0;
    if (a[loc] &amp;lt; a[loc + pace])
        return *p = 0;
    return *p = dfs(loc + pace, pace) + 1;
}
int main()
{
    scanf(&quot;%d&quot;, &amp;amp;n);
    for (int i = 1; i &amp;lt;= n; i++)
    {
        scanf(&quot;%d&quot;, &amp;amp;a[i]);
    }
    for (int i = 1; i &amp;lt;= n; i++)	//递归找出对于每个点，向左向右的下山路径
    {
        if (i == 1 &amp;amp;&amp;amp; a[i] &amp;gt; a[i + 1])
            dfs(i, 1);
        else if (i == n &amp;amp;&amp;amp; a[i - 1] &amp;lt; a[i])
            dfs(i, -1);
        else if (a[i] &amp;gt; a[i - 1] &amp;amp;&amp;amp; a[i] &amp;gt; a[i + 1])
        {
            dfs(i, -1);
            dfs(i, 1);
        }
    }

    bool flag = true;
    for (int i = 1; i &amp;lt;= n; i++)	//找出最长的下山路径，并标记为qingshan的起点
    {
        if (left_path_length[i] == 0 || right_path_length[i] == 0)
            continue;
        if (left_path_length[i] &amp;gt; ls)
        {
            ls = left_path_length[i];
            qingshan_spawn = i;
            direction = -1;
        }
        if (right_path_length[i] &amp;gt; ls)
        {
            ls = right_path_length[i];
            qingshan_spawn = i;
            direction = 1;
        }
        flag = false;
    }
    if (flag)	//如果没有山顶，即序列单调，则qingshan没有必胜策略
    {
        printf(&quot;0&quot;);
        return 0;
    }

    for (int i = 1; i &amp;lt;= n; i++)	//如果下山路径最长的路径有起点不同的两条，则qingshan没有必胜策略
    {
        if (i == qingshan_spawn)
            continue;
        if (left_path_length[i] == left_path_length[qingshan_spawn] || right_path_length[i] == left_path_length[qingshan_spawn])
        {
            printf(&quot;0&quot;);
            return 0;
        }
        if (left_path_length[i] == right_path_length[qingshan_spawn] || right_path_length[i] == right_path_length[qingshan_spawn])
        {
            printf(&quot;0&quot;);
            return 0;
        }
    }
    
    if (direction == -1)	//找出daniel的起点
    {
        daniel_spawn = left_path_length[qingshan_spawn] % 2 == 0 ? qingshan_spawn - left_path_length[qingshan_spawn] + 1 : qingshan_spawn - left_path_length[qingshan_spawn];
        direction = 1;
    }
    else
    {
        daniel_spawn = right_path_length[qingshan_spawn] % 2 == 0 ? qingshan_spawn + right_path_length[qingshan_spawn] - 1 : qingshan_spawn + right_path_length[qingshan_spawn];
        direction = -1;
    }


    if (direction == -1)	//比较qingshan和daniel的路径长度，算出结果
    {
        printf(&quot;%d&quot;, left_path_length[qingshan_spawn] &amp;gt; daniel_spawn - qingshan_spawn);
    }
    else
    {
        printf(&quot;%d&quot;, right_path_length[qingshan_spawn] &amp;gt; qingshan_spawn - daniel_spawn);
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;请参阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://codeforces.com/contest/1496&lt;/li&gt;
&lt;li&gt;https://www.bilibili.com/read/cv10220928/&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>【Codeforces】 题解 - Round 705 (Div.2)</title><link>https://blog.vonbrank.com/posts/codeforces-solution-round-705-div-2/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/codeforces-solution-round-705-div-2/</guid><pubDate>Fri, 26 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;本文合作者：&lt;a href=&quot;https://laybxc.github.io/&quot;&gt;laybxc&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;赛事信息&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;出题人&lt;/th&gt;
&lt;th&gt;开始时间&lt;/th&gt;
&lt;th&gt;时长&lt;/th&gt;
&lt;th&gt;官方题解&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://codeforces.com/contest/1493&quot;&gt;Codeforces Round #705 (Div. 2)&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://codeforces.com/profile/74TrAkToR&quot;&gt;74TrAkToR&lt;/a&gt;&amp;lt;br/&amp;gt;&lt;a href=&quot;https://codeforces.com/profile/AlFlen&quot;&gt;AlFlen&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://www.timeanddate.com/worldclock/fixedtime.html?day=6&amp;amp;month=3&amp;amp;year=2021&amp;amp;hour=14&amp;amp;min=05&amp;amp;sec=0&quot;&gt;Mar/06/2021&amp;lt;br/&amp;gt;22:05 (UTC+8)&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;02:15&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://codeforces.com/blog/entry/88422&quot;&gt;Tutorial&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;A. Anti-knapsack&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;给定 $n,k$ ，请选择 $1-n$ 的若干个整数，使得这些整数的和的子集都不等于 $k$ ，问最多能选出几个整数且分别是多少。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行是一个整数 $t(1≤t≤100)$ ，表示数据组数。&lt;/p&gt;
&lt;p&gt;每组数据有两个整数 $n,k(1≤k≤n≤1000)$&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;对于每组数据&lt;/p&gt;
&lt;p&gt;第一行输出一个整数 $m$ ，表示最多能选出的整数数量。&lt;/p&gt;
&lt;p&gt;第二行输出这些选出的整数，顺序任意。&lt;/p&gt;
&lt;h3&gt;解决方案：&lt;/h3&gt;
&lt;h4&gt;思路：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;显然对 $i ∈[1,n]$ ， $i&amp;gt;k$ 时 $i$ 这个数肯定可以直接选&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$i=k$ 显然不行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑 $i&amp;lt;k$ 的情况：我们发现 选 $k-1$ 不选 $1$ ，选 $k-2$ 不选 $2$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如何证明其正确性？&lt;/p&gt;
&lt;p&gt;如果选了大于 $k/2$ 的数，一定会有两个加起来等于 $k$ ，所以最多选 $k/2$ 个，那只需要选大的就可以了&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
using namespace std;
const int N = 1010;
int t, k, n;
int a[N], ans[N];
int cnt;
int main()
{
    ios::sync_with_stdio(0);
    cin &amp;gt;&amp;gt; t;
    while (t--)
    {
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
        cnt = 0;
        memset(a, 0, sizeof(a));
        memset(ans, 0, sizeof(ans)); //初始化
        if (n &amp;gt; k)
        {
            for (int i = k + 1; i &amp;lt;= n; i++)
            {
                ans[++cnt] = i;
            }
        }
        for (int i = k - 1; i &amp;gt;= 1; i--)
        {
            if (!a[i])
            {
                ans[++cnt] = i;
                a[k - i] = 1;
            }
        }
        cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl;
        for (int i = 1; i &amp;lt;= cnt; i++)
        {
            cout &amp;lt;&amp;lt; ans[i] &amp;lt;&amp;lt; &quot; &quot;;
        }
        cout &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;B. Planet Lapituletti&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;某行星上的时间一天有 $h$ 小时，一小时有 $m$ 分钟，它的时钟也是&lt;code&gt;HH:MM&lt;/code&gt;的形式存在。&lt;/p&gt;
&lt;p&gt;当某个点在镜子中显现的时间也是合法的时候，我们认为这个点是合法的。&lt;/p&gt;
&lt;p&gt;给定一个时间点，求最近的合法点（如果它本来就是一个合法的时间点，那么就输出这个时间点）&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行是一个整数 $t(1≤t≤100)$ ，表示数据组数。&lt;/p&gt;
&lt;p&gt;每组数据有两行：&lt;/p&gt;
&lt;p&gt;第一行输入$h,m$&lt;/p&gt;
&lt;p&gt;第二行输入给定的那个时间点 $hh:mm$&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;对于每组数据&lt;/p&gt;
&lt;p&gt;第一行输出一个整数 $m$ ，表示最多能选出的整数数量。&lt;/p&gt;
&lt;p&gt;以 $hh:mm$ 的形式输出最近的合法时间点&lt;/p&gt;
&lt;h3&gt;解决方案：&lt;/h3&gt;
&lt;h4&gt;思路&lt;/h4&gt;
&lt;p&gt;显然，合法的 &lt;strong&gt;必要不充分条件&lt;/strong&gt; 是 数字在屏幕上显示是正确的。即：&lt;code&gt;1 2 5 8 0&lt;/code&gt;可以出现，&lt;code&gt;3 4 6 7 9&lt;/code&gt;不能出现。&lt;/p&gt;
&lt;p&gt;其次，必须满足对应的 分钟 和 小时 在该行星上时间范围内的条件。&lt;/p&gt;
&lt;p&gt;那么就很容易判断一个时间是否合法，问题来到如何找到下一个合法的时间？&lt;/p&gt;
&lt;p&gt;枚举即可！&lt;/p&gt;
&lt;p&gt;注意前导零？——改用字符串来处理即可&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;（比赛的时候写的太冗长了，这是一个需要改进的地方）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
using namespace std;
const int N = 1010;
int t, h, m;
int hh, mm;
char H[2], M[2];
char ansh[2], ansm[2];
int nh, nm;
int no[] = {3, 4, 6, 7, 9};
int solve(int x)
{
    int res = 0;
    char op[2];
    if (x == 1)
        op[0] = H[0], op[1] = H[1];
    else
        op[0] = M[0], op[1] = M[1];
    for (int j = 1; j &amp;gt;= 0; j--)
    {
        int num = op[j] - &apos;0&apos;;
        res *= 10;
        if (num == 0)
            res += 0;
        else if (num == 1)
            res += 1;
        else if (num == 2)
            res += 5;
        else if (num == 5)
            res += 2;
        else if (num == 8)
            res += 8;
    }
    return res;
}
int check()
{
    for (int j = 0; j &amp;lt;= 1; j++)
    {
        int x = H[j] - &apos;0&apos;;
        for (int i = 0; i &amp;lt; 5; i++)
            if (x == no[i])
                return 0;
    }
    for (int j = 0; j &amp;lt;= 1; j++)
    {
        int x = M[j] - &apos;0&apos;;
        for (int i = 0; i &amp;lt; 5; i++)
            if (x == no[i])
                return 0;
    }
    nh = solve(0), nm = solve(1);

    if (nh &amp;lt; h and nm &amp;lt; m)
    {
        //cout&amp;lt;&amp;lt;hh&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;mm&amp;lt;&amp;lt;endl;
        ansh[0] = hh / 10 + &apos;0&apos;, ansh[1] = hh % 10 + &apos;0&apos;;
        ansm[0] = mm / 10 + &apos;0&apos;, ansm[1] = mm % 10 + &apos;0&apos;;
        return 1;
    }
    return 0;
}
int main()
{
    cin &amp;gt;&amp;gt; t;
    while (t--)
    {
        cin &amp;gt;&amp;gt; h &amp;gt;&amp;gt; m;
        scanf(&quot;%d:%d&quot;, &amp;amp;hh, &amp;amp;mm);
        H[0] = hh / 10 + &apos;0&apos;, H[1] = hh % 10 + &apos;0&apos;;
        M[0] = mm / 10 + &apos;0&apos;, M[1] = mm % 10 + &apos;0&apos;;
        while (!check())
        {
            mm = (M[0] - &apos;0&apos;) * 10 + M[1] - &apos;0&apos;;
            hh = (H[0] - &apos;0&apos;) * 10 + H[1] - &apos;0&apos;;
            mm++;
            if (mm &amp;gt;= m)
            {
                mm = 0, hh++;
            }
            if (hh &amp;gt;= h)
                hh = 0;
            H[0] = hh / 10 + &apos;0&apos;, H[1] = hh % 10 + &apos;0&apos;;
            M[0] = mm / 10 + &apos;0&apos;, M[1] = mm % 10 + &apos;0&apos;;
        }
        cout &amp;lt;&amp;lt; ansh[0] &amp;lt;&amp;lt; ansh[1] &amp;lt;&amp;lt; &quot;:&quot; &amp;lt;&amp;lt; ansm[0] &amp;lt;&amp;lt; ansm[1] &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;C. K-beautiful Strings&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;一个字符串是 $k$ 美的定义：字符串中不同字符出现的总次数能整除 $k$&lt;/p&gt;
&lt;p&gt;现在给你一个 $n,k$ ,和一个字符串，$n$ 为字符串的长度，让你求一个字符串满足 $k$ 美的定义并且这个字符串的字典序要尽可能的小（前提是大于等于原字符串）&lt;/p&gt;
&lt;p&gt;并且长度和原串长度相同，如果答案字符串不存在，输出&lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行是一个整数 $t(1≤t≤10000)$ ，表示数据组数。&lt;/p&gt;
&lt;p&gt;每组数据有两行：&lt;/p&gt;
&lt;p&gt;第一行输入两个整数 $n,k(1≤k≤n≤10^5)$ ，分别为字符串 $s$ 的长度和给定的数字 $k$&lt;/p&gt;
&lt;p&gt;第二行输入只含小写字母的字符串 $s$&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;对于每一组测试数据，输出第一个字典序大于等于 $s$ 且满足 $k$ 美定义的字符串&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;思路：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;因为要求的字符串要尽可能的小，还必须大于等于原串，那么我们可能的最优解就是原串本身满足k美，直接输出原串。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个串满足 $k$ 美，那么说明串的长度是由一组 $k$ 的倍数组成的，所以如果 $n$ 不能整除 $k$ ，那么找不到满足 $k$ 美的字符串，所以我们直接输出 $-1$ 。&lt;/p&gt;
&lt;p&gt;注意是 $k$ 的倍数，而不是每个出现次数都是 $k$ ，因此类似 $8=2+4+2=6+2(k=2)$ 这样的数据都是合法的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何寻找满足 $k$ 美的最小字符串？我们可以这样 &lt;strong&gt;贪心&lt;/strong&gt; 的想，构造一个最小的大于等于原串的k美字符串，那么我们应该对原串从后往前构造，因为越往前，构造出来的字符串就越大，所以尽可能在最后就构造好，这样满足字典序最小的性质。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们首先统计每个字符出现的次数，用一个&lt;code&gt;cnt&lt;/code&gt;数组存储，然后统计将所有字符都变成k的倍数时所需增加的字符总数&lt;code&gt;tot&lt;/code&gt;：即字符 $i$ 变成 $k$ 的倍数时需要增加的字符数为 $(k-cnt[i]%k)%k$  ;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从后往前遍历，遍历到位置 $i$ 时，就判断一下从位置i开始之前的子串是否是一个不用修改的最长前缀子串（因为前面的串不改最优）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后得到位置 $i$ 上的字符 $c$ ，并逐个判断要放哪个字符&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;代码：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
using namespace std;
int cnt[30];
int n, t, k;
char s[100020];
void solve()
{
    memset(cnt, 0, sizeof(cnt));
    for (int i = 1; i &amp;lt;= n; i++)
    {
        cnt[s[i] - &apos;a&apos;]++; //对原串中出现的字母进行统计
    }
    int tot = 0;
    for (int i = 0; i &amp;lt;= 25; i++)
    {
        tot += (k - cnt[i] % k) % k; //表示将字符i变成 k的倍数 时所需要增加的字母数量
    }
    if (tot == 0)
    {
        for (int i = 1; i &amp;lt;= n; i++)
            cout &amp;lt;&amp;lt; s[i];
        cout &amp;lt;&amp;lt; endl;
    }
    else if (n % k != 0)
        cout &amp;lt;&amp;lt; &quot;-1&quot; &amp;lt;&amp;lt; endl;
    else
    {
        int ans = 0;
        for (int i = n; i &amp;gt;= 1 and ans == 0; i--) //从后往前遍历
        {
            tot -= (k - cnt[s[i] - &apos;a&apos;] % k) % k;
            cnt[s[i] - &apos;a&apos;]--;
            tot += (k - cnt[s[i] - &apos;a&apos;] % k) % k; //统计i位置之前的tot

            for (int j = s[i] - &apos;a&apos; + 1; j &amp;lt;= 25; j++) //修改i
            {
                int last = tot;
                tot -= (k - cnt[j] % k) % k;
                cnt[j]++;
                tot += (k - cnt[j] % k) % k;
                if (i + tot &amp;lt;= n) //如果需要增加（修改）的字符数不超过i及其后面这一段的长度，那么就说明我们找到了最长的不用修改的前缀子串
                {
                    for (int x = 1; x &amp;lt; i; x++)
                    {
                        cout &amp;lt;&amp;lt; s[x];
                    }
                    cout &amp;lt;&amp;lt; char(j + &apos;a&apos;); //输出i位置的字符
                    //因为i位被改大了，所以到现在，字典序已经变大了，后续的直接放最小的即可
                    for (int x = 1; x &amp;lt;= n - i - tot; x++)
                    {
                        cout &amp;lt;&amp;lt; &apos;a&apos;; //补a，因为i之前的字符经过补位后的修改后一定是k倍，所以剩下的位数一定是k倍，那么直接都补上a即可
                    }
                    for (int x = 0; x &amp;lt;= 25; x++) //从前往后，补充缺少的字符（补位）
                    {
                        int num = (k - cnt[x] % k) % k;
                        while (num &amp;gt; 0)
                        {
                            tot--, num--;
                            cout &amp;lt;&amp;lt; char(x + &apos;a&apos;);
                        }
                    }
                    cout &amp;lt;&amp;lt; endl;
                    ans = 1;
                    break;
                }

                tot = last;
                cnt[j]--;
            }
        }
    }
}
int main()
{
    cin &amp;gt;&amp;gt; t;
    while (t--)
    {
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
        cin &amp;gt;&amp;gt; (s + 1);
        solve();
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;D. GCD of an Array&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;一个长度为 $n$ 的数组 $a$ 。处理以下格式的 $q$ 个查询：给定整数 $i$ 和 $x$ ，将 $a_i$ 乘以 $x$。&lt;/p&gt;
&lt;p&gt;在处理每个查询之后，您需要输出数组 $a$ 的所有元素的最大公约数（GCD）。&lt;/p&gt;
&lt;p&gt;因为答案可能太大，所以要求以 $10^9+7$ 的模输出它。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行是两个整数 $n,q(1≤n,q≤2⋅10^5)$&lt;/p&gt;
&lt;p&gt;第二行包括 $n$ 个整数 $a_1,a_2,\dots,a_n(1≤ai≤2⋅10^5)$&lt;/p&gt;
&lt;p&gt;接下来 $q$ 行包括 $q$ 个查询，每行包括两个数字 $i，x (1≤i≤n, 1≤x≤2⋅10^5)$&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出 $q$ 行，每行为现在数组的 GCD 对 $1e9+7$ 的模数。&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;p&gt;数论+数据结构题先不写（&lt;/p&gt;
&lt;h2&gt;请参阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://blog.csdn.net/weixin_45786972/article/details/1145276383&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>【OI考古】动态规划 | 动态规划基础</title><link>https://blog.vonbrank.com/posts/oi-dp-basic-dp-algorithm/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/oi-dp-basic-dp-algorithm/</guid><pubDate>Wed, 24 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;动态规划（Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。&lt;/p&gt;
&lt;p&gt;动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。&lt;/p&gt;
&lt;h2&gt;最长上升子序列（LIS）&lt;/h2&gt;
&lt;p&gt;给出一个序列 $a_1, a_2, ...,a_{n-1}, a_n$ ，求其最长不下降（或上升）子序列。&lt;/p&gt;
&lt;p&gt;求最长上升子序列（LIS）的算法是&lt;a href=&quot;https://yukkohzq.github.io/&quot;&gt;Yukko&lt;/a&gt;介绍给我的第一个算法。&lt;/p&gt;
&lt;h3&gt;解决方案（ $O(n^2)$ ）&lt;/h3&gt;
&lt;h4&gt;状态设计：&lt;/h4&gt;
&lt;p&gt;$dp[i]$ 表示以第  $i$ 个数结尾的最长上升子序列的最长长度。&lt;/p&gt;
&lt;h4&gt;状态转移方程：&lt;/h4&gt;
&lt;p&gt;$dp[i]= max(dp[j])+1 \quad (1≤j＜i， 且a[i]&amp;gt;a[j])$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
const int maxn = 100500;
int n, ans;
int a[maxn], dp[maxn];
int main()
{
	scanf(&quot;%d&quot;, &amp;amp;n);
    for(int i=1; i&amp;lt;=n; i++)
    {
        scanf(&quot;%d&quot;, &amp;amp;a[i]);
        dp[i] = 1;	
    }
    for (int i = 1; i &amp;lt;= n; i++)
    {
        for (int j = 1; j &amp;lt; i; j++)
        {
            if (a[i] &amp;gt; a[j] &amp;amp;&amp;amp; dp[i] &amp;lt; dp[j] + 1)	//如果a[i] &amp;gt; a[j]，则a[i]可以接在以a[j]结尾的上升子序列后面
                dp[i] = dp[j] + 1;	//如果dp[i] &amp;lt; dp[j] + 1，则可以用dp[j] + 1来更新dp[i]
        }
        ans = max(ans, dp[i]);	//取dp[i]的最大值来作为ans
    }
    printf(&quot;%d&quot;, ans);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;解决方案（ $O(n\log_{}{n})$ ）&lt;/h3&gt;
&lt;h3&gt;例题&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1020&quot;&gt;洛谷 P1020 | [NOIP1999 普及组] 导弹拦截&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1091&quot;&gt;洛谷 P1091 | [NOIP2004 提高组] 合唱队形&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;最长公共子序列（LCS）&lt;/h2&gt;
&lt;h3&gt;模板题：&lt;a href=&quot;https://www.luogu.com.cn/problem/P1439&quot;&gt;洛谷 P1439 | [模板]最长公共子序列&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;给出 $1,2,\ldots,n$ 的两个排列 $P_1$  和 $P_2$ ，求它们的最长公共子序列。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行是一个数 $n$ 。&lt;/p&gt;
&lt;p&gt;接下来两行，每行为 $n$ 个数，为自然数 $1,2,\ldots,n$ 的一个排列。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;一个数，即最长公共子序列的长度。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;5 
3 2 1 4 5
1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;3
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;数据规模与约定&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;对于 $50%$ 的数据， $n \le 10^3$ ；&lt;/li&gt;
&lt;li&gt;对于 $100%$ 的数据， $n \le 10^5$ 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;h4&gt;状态设计：&lt;/h4&gt;
&lt;p&gt;$dp[i][j]$ 表示 $P_1$ 前 $i$ 位， $P_2$ 前 $j$ 位的最长公共子序列长度。&lt;/p&gt;
&lt;h4&gt;状态转移方程：&lt;/h4&gt;
&lt;p&gt;$$dp[i][j]=\begin{cases}max(dp[i][j], dp[i-1][j-1] + 1) &amp;amp;\text{if } P_1[i]=P_2[j] \ max(dp[i-1][j], dp[i][j-1])  &amp;amp;\text{if } P_1[i]\not =P_2[j] \end{cases}$$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;请参阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>【OI考古】图论 | 最短路算法</title><link>https://blog.vonbrank.com/posts/oi-graph-theory-shortest-paths/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/oi-graph-theory-shortest-paths/</guid><pubDate>Tue, 23 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;解决单源最短路径问题的几种算法，是&lt;a href=&quot;https://yukkohzq.github.io/&quot;&gt;Yukko&lt;/a&gt;最早给我介绍的几类算法之一。&lt;/p&gt;
&lt;p&gt;最短路算法的基本功能，是求解带边权的有向或无向图中任意两点之间最短或最长的路径及其距离。&lt;/p&gt;
&lt;h3&gt;模板题：&lt;a href=&quot;https://www.luogu.com.cn/problem/P4779&quot;&gt;洛谷 P4779 | [模板]单源最短路径（标准版）&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;给定一个 $n$ 个点， $m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。&lt;/p&gt;
&lt;p&gt;数据保证你能从 $s$ 出发到任意点。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行为三个正整数 $n, m, s$ 。 第二行起 $m$ 行，每行三个非负整数 $u_i, v_i, w_i$ ，表示从 $u_i$ 到 $v_i$ 有一条权值为 $w_i$ 的有向边。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一行 $n$ 个空格分隔的非负整数，表示 $s$ 到每个点的距离。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;4 6 1
1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;0 2 4 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;p&gt;$1≤n≤10^5$ ；
$1 \leq m \leq 2\times 10^5$ ;
$s = 1$ ；
$1 \leq u_i, v_i\leq n$ ；
$0 \leq w_i \leq 10 ^ 9$ ,
$0 \leq \sum w_i \leq 10 ^ 9$ 。&lt;/p&gt;
&lt;h2&gt;Floyd 算法&lt;/h2&gt;
&lt;p&gt;Floyd 算法的时间复杂度为 $O(n^3)$ ，比较高，但是常数小，容易实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/03/31/ckaPbt.md.png&quot; alt=&quot;ckaPbt.md.png&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
using namespace std;
const int maxn = 1050;
int n, m, s;
int G[maxn][maxn];
int main()
{
    memset(G, 63, sizeof(G));	//初始化为一个大整数
    scanf(&quot;%d %d %d&quot;, &amp;amp;n, &amp;amp;m, &amp;amp;s);
    for (int i = 1; i &amp;lt;= n; i++)
        G[i][i] = 0;
    for (int i = 1; i &amp;lt;= m; i++)
    {
        int u, v, w;
        scanf(&quot;%d %d %d&quot;, &amp;amp;u, &amp;amp;v, &amp;amp;w);
        G[u][v] = min(G[u][v], w);	//考虑重边的情况
    }
    for (int k = 1; k &amp;lt;= n; k++)
    {
        for (int i = 1; i &amp;lt;= n; i++)
        {
            for (int j = 1; j &amp;lt;= n; j++)
            {
                if (G[i][k] + G[k][j] &amp;lt; G[i][j])	//松弛操作
                    G[i][j] = G[i][k] + G[k][j];
            }
        }
    }
    for (int i = 1; i &amp;lt;= n; i++)
    {
        printf(&quot;%d &quot;, G[s][i]);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Dijkstra 算法&lt;/h2&gt;
&lt;p&gt;适用于非负权图，但是时间复杂度非常优秀，naive 实现的时间复杂度为 $O(n^2)$ ，堆优化能实现 $O(n\log_{}{n})$ 的时间复杂度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/03/31/ckwk9S.gif&quot; alt=&quot;ckwk9S.gif&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;解决方案（naive）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;//dijkstra_naive.cpp
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
using namespace std;
const int maxn = 100500;
const int INF = 2147483647;
int n, m, s, cnt;
int head[maxn];
long long dis[maxn];
bool vis[maxn];
struct Edge
{
    int to, next, w;
} G[maxn * 5];
void addedge(int u, int v, int w)
{
    ++cnt;
    G[cnt].to = v;
    G[cnt].w = w;
    G[cnt].next = head[u];
    head[u] = cnt;
}
void dijkstra_naive(int s)
{
    for (int i = 1; i &amp;lt;= n; i++)
        dis[i] = INF;
    dis[s] = 0;
    for (int i = 1; i &amp;lt;= n; i++)
    {
        int k;
        long long mn = INF;
        for (int j = 1; j &amp;lt;= n; j++)
        {
            if (!vis[j] &amp;amp;&amp;amp; dis[j] &amp;lt; mn)
            {
                mn = dis[j];
                k = j;
            }
        }
        vis[k] = true;
        for (int j = head[k]; j; j = G[j].next)
        {
            int v = G[j].to;
            int w = G[j].w;
            if (vis[v])
                continue;
            if (dis[v] &amp;gt; dis[k] + w)
                dis[v] = dis[k] + w;
        }
    }
}
int main()
{
    scanf(&quot;%d %d %d&quot;, &amp;amp;n, &amp;amp;m, &amp;amp;s);
    for (int i = 1; i &amp;lt;= m; i++)
    {
        int u, v, w;
        scanf(&quot;%d %d %d&quot;, &amp;amp;u, &amp;amp;v, &amp;amp;w);
        addedge(u, v, w);
    }
    dijkstra_naive(s);
    for (int i = 1; i &amp;lt;= n; i++)
    {
        printf(&quot;%lld &quot;, dis[i]);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;解决方案（堆优化）&lt;/h3&gt;
&lt;p&gt;解决方案（naive）是不足以通过洛谷的单元最短路径 &lt;s&gt;（毒瘤版）&lt;/s&gt; 的，我们需要使用优先队列在 $O(\log_{}{n})$ 时间内找到每次未更新的点集中离已更新点集距离最近的点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//dijkstra_heap.cpp
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;
const int maxn = 100500;
const int INF = 2147483647;
int n, m, s, cnt;
int head[maxn];
long long dis[maxn];
bool vis[maxn];
struct Edge
{
    int to, next, w;
} G[maxn * 5];
struct Dis
{
    long long dis;
    int p;

    bool operator&amp;lt;(const Dis &amp;amp;b) const	//重载结构体运算符
    {
        return dis &amp;gt; b.dis;
    }
};

void addedge(int u, int v, int w)
{
    ++cnt;
    G[cnt].to = v;
    G[cnt].w = w;
    G[cnt].next = head[u];
    head[u] = cnt;
}
void dijkstra_heap(int s)
{
    for (int i = 1; i &amp;lt;= n; i++)
        dis[i] = INF;
    dis[s] = 0;
    priority_queue&amp;lt;Dis&amp;gt; MinDis;
    Dis tmp;
    tmp.dis = 0;
    tmp.p = s;
    MinDis.push(tmp);
    for (int i = 1; i &amp;lt;= n; i++)
    {
        int k;
        long long mn = INF;

        tmp = MinDis.top();
        while (vis[tmp.p])
        {
            MinDis.pop();
            tmp = MinDis.top();
        }
        mn = tmp.dis;
        k = tmp.p;

        vis[k] = true;
        for (int j = head[k]; j; j = G[j].next)
        {
            int v = G[j].to;
            int w = G[j].w;
            if (vis[v])
                continue;
            if (dis[v] &amp;gt; dis[k] + w)
            {
                dis[v] = dis[k] + w;
                tmp.p = v;
                tmp.dis = dis[v];
                MinDis.push(tmp);
            }
        }
    }
}
int main()
{
    scanf(&quot;%d %d %d&quot;, &amp;amp;n, &amp;amp;m, &amp;amp;s);
    for (int i = 1; i &amp;lt;= m; i++)
    {
        int u, v, w;
        scanf(&quot;%d %d %d&quot;, &amp;amp;u, &amp;amp;v, &amp;amp;w);
        addedge(u, v, w);
    }
    dijkstra_heap(s);
    for (int i = 1; i &amp;lt;= n; i++)
    {
        printf(&quot;%lld &quot;, dis[i]);
    }
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;SPFA&lt;/h2&gt;
&lt;p&gt;&lt;s&gt;玄学算法不写（&lt;/s&gt;&lt;/p&gt;
&lt;h2&gt;请参阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://oi-wiki.org/graph/shortest-path/&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>CS231n | 课程作业 Assignment1 | K近邻算法 KNN</title><link>https://blog.vonbrank.com/posts/cs231n-assignment1-knn/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/cs231n-assignment1-knn/</guid><pubDate>Mon, 22 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;$K$ 近邻算法（k-Nearest Neighbor）是CS231n课程介绍的第一个算法，此算法和神经网络没有任何关系，实际中也极少使用，但学习使用KNN算法可以获得对图像分类方法的基本认知。&lt;/p&gt;
&lt;h2&gt;先决条件&lt;/h2&gt;
&lt;p&gt;在开始写作业前，你需要做一些准备工作。&lt;/p&gt;
&lt;h3&gt;Jupyter Notebook先决条件&lt;/h3&gt;
&lt;p&gt;你可以在&lt;a href=&quot;https://cs231n.github.io/assignments/2021/assignment1_colab.zip&quot;&gt;这里&lt;/a&gt;下载官方提供的CS231n Assignment1的 Jupyter笔记本。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Anaconda Prompt Powershell&lt;/code&gt;中输入&lt;code&gt;conda activate cs231&lt;/code&gt;，接着&lt;code&gt;cd&lt;/code&gt;到&lt;code&gt;assignment1&lt;/code&gt;目录下，输入&lt;code&gt;jupyter notebook&lt;/code&gt;开启Ipython笔记本，打开&lt;code&gt;knn.ipynb&lt;/code&gt;即可开始本次作业。&lt;/p&gt;
&lt;p&gt;在开始之前，需要注意，由于&lt;code&gt;Jupyter Notebook&lt;/code&gt;的某种bug，CIFAR-10的路径变量&lt;code&gt;cifar10_dir&lt;/code&gt;需要赋值为绝对路径，同时在路径前加上&lt;code&gt;r&lt;/code&gt;来忽略转义，像下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Load the raw CIFAR-10 data.
cifar10_dir = r&apos;D:\Users\VonBrank\Documents\GitHub\code-learning\algorithm\deep-learning\computer-visualization\cs231n\datasets\cifar-10-batches-py&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到此为止，写代码前的准备工作就完成了。&lt;/p&gt;
&lt;h3&gt;Numpy先决条件&lt;/h3&gt;
&lt;p&gt;Numpy是CS231n课程中所需的科学计算库，其优秀的矩阵运算性能对图像处理有巨大帮助，在此介绍KNN算法中需使用的Numpy函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基于元素的运算&lt;/p&gt;
&lt;p&gt;Numpy的所有计算都是基于元素的。设&lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;是两个矩阵，则&lt;code&gt;A + B&lt;/code&gt;表示两个矩阵的对应位相乘，&lt;code&gt;A × B&lt;/code&gt;同理；而若要作矩阵乘法，让&lt;code&gt;B&lt;/code&gt;右乘&lt;code&gt;A&lt;/code&gt;，则可以写成&lt;code&gt;A.dot(B)&lt;/code&gt;或&lt;code&gt;A @ B&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Numpy数组切片&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Numpy幂运算&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;np.sum()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;np.sqrt()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;np.argsort()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;np.argmax()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;np.bincount()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;KNN算法&lt;/h2&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;KNN算法遵循以下步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;取CIFAR-10数据集中的一张图片 $（32\times32\times3）$ ，将其拉伸为一个3072维的向量，训练集中的每个向量都可以视作 $3072$ 维欧氏空间中的一个点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对测试集中的每一张图片作相同的操作，计算其与训练集中每一张图的欧式距离。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对测试集中的任意一张图片，考察其在训练集中的前 $K$ 近的点（用 $L2$ 距离计算），分类数最大的分类即预测为此图像的所属分类。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了便于理解，我们将 $3072$ 维的空间简化为 $2$ 维空间，在理解了二维空间的KNN算法后，扩展至 $3072$ 维甚至更多维数的KNN将变得更易于理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/03/23/6Tl73F.md.png&quot; alt=&quot;6Tl73F.md.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，若将图像映射为二维平面上的一个点，可以看出，若使用KNN算法遍历空间中的所有点，可将二维空间划分为若干区域，每个区域表示一个分类。&lt;/p&gt;
&lt;p&gt;对于 $k=1$ 的情况，即NN（Nearest Neighbor）算法，可看出，对于空间中任意一点，将离其最近的训练集中的点所属分类判定为该点所属的分类。&lt;/p&gt;
&lt;p&gt;对于 $k≥1$ 的情况，即KNN算法的一般情况。举例来说，假设对于一个点，离该点前 $K$ 近的训练集中的点中，属于 &lt;strong&gt;红色&lt;/strong&gt; 分类的点是最多的，即可将该点所属的分类判定为 &lt;strong&gt;红色&lt;/strong&gt; 分类。&lt;/p&gt;
&lt;p&gt;需要说明的是，定义两个点，即两个图像之间的距离，通常使用 $L2$ 距离，即欧几里得距离，计算方法如下：&lt;/p&gt;
&lt;p&gt;$$d_2(I_1, I_2) = \sqrt{\displaystyle\sum_{p}(I_1^p - I_2^p)^2}$$&lt;/p&gt;
&lt;p&gt;为了实现这个算法，&lt;code&gt;knn.ipynb&lt;/code&gt;将指示我们从两重循环到一重循环，再到以纯向量化代码实现 $L2$ 距离的计算，并体验其优化过程。&lt;/p&gt;
&lt;h3&gt;实现&lt;/h3&gt;
&lt;p&gt;由于之后每个task的流程都差不多，文本将展示一个完整的流程，之后的记录不再赘述。虽然CS231n官方在笔记本里提供的大量轮子，只要求我们编写核心代码，但仍推荐阅读这些轮子的实现。&lt;/p&gt;
&lt;h4&gt;初始化&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;In[1]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Run some setup code for this notebook.

import random
import numpy as np
from cs231n.data_utils import load_CIFAR10
import matplotlib.pyplot as plt

# This is a bit of magic to make matplotlib figures appear inline in the notebook
# rather than in a new window.
%matplotlib inline
plt.rcParams[&apos;figure.figsize&apos;] = (10.0, 8.0) # set default size of plots
plt.rcParams[&apos;image.interpolation&apos;] = &apos;nearest&apos;
plt.rcParams[&apos;image.cmap&apos;] = &apos;gray&apos;

# Some more magic so that the notebook will reload external python modules;
# see http://stackoverflow.com/questions/1907993/autoreload-of-modules-in-ipython
%load_ext autoreload
%autoreload 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;加载数据&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;In[2]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Load the raw CIFAR-10 data.
cifar10_dir = r&apos;D:\Users\VonBrank\Documents\GitHub\code-learning\algorithm\deep-learning\computer-visualization\cs231n\datasets\cifar-10-batches-py&apos;

# Cleaning up variables to prevent loading data multiple times (which may cause memory issue)
try:
   del X_train, y_train
   del X_test, y_test
   print(&apos;Clear previously loaded data.&apos;)
except:
   pass

X_train, y_train, X_test, y_test = load_CIFAR10(cifar10_dir)

# As a sanity check, we print out the size of the training and test data.
print(&apos;Training data shape: &apos;, X_train.shape)
print(&apos;Training labels shape: &apos;, y_train.shape)
print(&apos;Test data shape: &apos;, X_test.shape)
print(&apos;Test labels shape: &apos;, y_test.shape)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Out[2]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Training data shape:  (50000, 32, 32, 3)
Training labels shape:  (50000,)
Test data shape:  (10000, 32, 32, 3)
Test labels shape:  (10000,)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;预处理数据&lt;/h4&gt;
&lt;p&gt;随机选取一些图像并输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Visualize some examples from the dataset.
# We show a few examples of training images from each class.
classes = [&apos;plane&apos;, &apos;car&apos;, &apos;bird&apos;, &apos;cat&apos;, &apos;deer&apos;, &apos;dog&apos;, &apos;frog&apos;, &apos;horse&apos;, &apos;ship&apos;, &apos;truck&apos;]
num_classes = len(classes)
samples_per_class = 7
for y, cls in enumerate(classes):
    idxs = np.flatnonzero(y_train == y)
    idxs = np.random.choice(idxs, samples_per_class, replace=False)
    for i, idx in enumerate(idxs):
        plt_idx = i * num_classes + y + 1
        plt.subplot(samples_per_class, num_classes, plt_idx)
        plt.imshow(X_train[idx].astype(&apos;uint8&apos;))
        plt.axis(&apos;off&apos;)
        if i == 0:
            plt.title(cls)
plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/03/25/6XRpRA.png&quot; alt=&quot;6XRpRA.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;选取CIFAR-10的一个子集进行训练与测试&lt;/p&gt;
&lt;p&gt;&lt;code&gt;In[3]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Subsample the data for more efficient code execution in this exercise
num_training = 5000
mask = list(range(num_training))
X_train = X_train[mask]
y_train = y_train[mask]

num_test = 500
mask = list(range(num_test))
X_test = X_test[mask]
y_test = y_test[mask]

# Reshape the image data into rows
X_train = np.reshape(X_train, (X_train.shape[0], -1))
X_test = np.reshape(X_test, (X_test.shape[0], -1))
print(X_train.shape, X_test.shape)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Out[3]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(5000, 3072) (500, 3072)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;调用KNN算法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;from cs231n.classifiers import KNearestNeighbor

# Create a kNN classifier instance. 
# Remember that training a kNN classifier is a noop: 
# the Classifier simply remembers the data and does no further processing 
classifier = KNearestNeighbor()
classifier.train(X_train, y_train)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;两重循环计算  $L2$ 距离&lt;/h4&gt;
&lt;p&gt;完成&lt;code&gt;cs231n/classifiers/k_nearest_neighbor.py&lt;/code&gt;中的&lt;code&gt;compute_distances_two_loops&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def compute_distances_two_loops(self, X):
    &quot;&quot;&quot;
    Compute the distance between each test point in X and each training point
    in self.X_train using a nested loop over both the training data and the
    test data.

    Inputs:
    - X: A numpy array of shape (num_test, D) containing test data.

    Returns:
    - dists: A numpy array of shape (num_test, num_train) where dists[i, j]
      is the Euclidean distance between the ith test point and the jth training
      point.
    &quot;&quot;&quot;
    num_test = X.shape[0]
    num_train = self.X_train.shape[0]
    dists = np.zeros((num_test, num_train))
    for i in range(num_test):
        for j in range(num_train):
            #####################################################################
            # TODO:                                                             #
            # Compute the l2 distance between the ith test point and the jth    #
            # training point, and store the result in dists[i, j]. You should   #
            # not use a loop over dimension, nor use np.linalg.norm().          #
            #####################################################################
            # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****
            dists[i][j] = np.sqrt(np.sum((X[i, :] - self.X_train[j, :]) ** 2))
            pass

            # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****
     return dists
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;验证计算是否正确：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;In[4]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Open cs231n/classifiers/k_nearest_neighbor.py and implement
# compute_distances_two_loops.

# Test your implementation:
dists = classifier.compute_distances_two_loops(X_test)
print(dists.shape)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Out[4]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(500, 5000)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可视化结果：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;In[5]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# We can visualize the distance matrix: each row is a single test example and
# its distances to training examples
plt.imshow(dists, interpolation=&apos;none&apos;)
plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Out[6]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/03/25/6XRzwT.png&quot; alt=&quot;6XRzwT.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中，白线意味着对应位置的训练集和测试集相似度非常低。&lt;/p&gt;
&lt;p&gt;测试一下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;In[6]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Now implement the function predict_labels and run the code below:
# We use k = 1 (which is Nearest Neighbor).
y_test_pred = classifier.predict_labels(dists, k=1)

# Compute and print the fraction of correctly predicted examples
num_correct = np.sum(y_test_pred == y_test)
accuracy = float(num_correct) / num_test
print(&apos;Got %d / %d correct =&amp;gt; accuracy: %f&apos; % (num_correct, num_test, accuracy))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Out[6]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Got 137 / 500 correct =&amp;gt; accuracy: 0.274000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出， $k=1$ 时，准确率为 $27.4%$ 。&lt;/p&gt;
&lt;p&gt;接着测试 $k=5$ 的情况：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;In[7]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;y_test_pred = classifier.predict_labels(dists, k=5)
num_correct = np.sum(y_test_pred == y_test)
accuracy = float(num_correct) / num_test
print(&apos;Got %d / %d correct =&amp;gt; accuracy: %f&apos; % (num_correct, num_test, accuracy))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Out[7]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Got 139 / 500 correct =&amp;gt; accuracy: 0.278000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到， $k=5$ 与 $k=1$ 的结果相差不大。&lt;/p&gt;
&lt;h4&gt;一重循环计算  $L2$ 距离&lt;/h4&gt;
&lt;p&gt;完成&lt;code&gt;compute_distances_two_loops&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def compute_distances_one_loop(self, X):
    &quot;&quot;&quot;
    Compute the distance between each test point in X and each training point
    in self.X_train using a single loop over the test data.

    Input / Output: Same as compute_distances_two_loops
    &quot;&quot;&quot;
    num_test = X.shape[0]
    num_train = self.X_train.shape[0]
    dists = np.zeros((num_test, num_train))
    for i in range(num_test):
        #######################################################################
        # TODO:                                                               #
        # Compute the l2 distance between the ith test point and all training #
        # points, and store the result in dists[i, :].                        #
        # Do not use np.linalg.norm().                                        #
        #######################################################################
        # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****
        dists[i, :] = np.sqrt(np.sum(((X[i] - self.X_train) ** 2), axis=1))
        # pass

        # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****
    return dists
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试一下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;In[8]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Now lets speed up distance matrix computation by using partial vectorization
# with one loop. Implement the function compute_distances_one_loop and run the
# code below:
dists_one = classifier.compute_distances_one_loop(X_test)

# To ensure that our vectorized implementation is correct, we make sure that it
# agrees with the naive implementation. There are many ways to decide whether
# two matrices are similar; one of the simplest is the Frobenius norm. In case
# you haven&apos;t seen it before, the Frobenius norm of two matrices is the square
# root of the squared sum of differences of all elements; in other words, reshape
# the matrices into vectors and compute the Euclidean distance between them.
difference = np.linalg.norm(dists - dists_one, ord=&apos;fro&apos;)
print(&apos;One loop difference was: %f&apos; % (difference, ))
if difference &amp;lt; 0.001:
    print(&apos;Good! The distance matrices are the same&apos;)
else:
    print(&apos;Uh-oh! The distance matrices are different&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Out[8]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;One loop difference was: 0.000000
Good! The distance matrices are the same
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果出现上述结果，则证明实现正确。&lt;/p&gt;
&lt;h4&gt;纯向量化计算  $L2$ 距离&lt;/h4&gt;
&lt;p&gt;完成&lt;code&gt;compute_distances_no_loops&lt;/code&gt;函数：&lt;/p&gt;
&lt;p&gt;这里需要将 $L2$ 距离公式展开为多项式，再进行向量化计算。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def compute_distances_no_loops(self, X):
    &quot;&quot;&quot;
    Compute the distance between each test point in X and each training point
    in self.X_train using no explicit loops.

    Input / Output: Same as compute_distances_two_loops
    &quot;&quot;&quot;
    num_test = X.shape[0]
    num_train = self.X_train.shape[0]
    dists = np.zeros((num_test, num_train))
    #########################################################################
    # TODO:                                                                 #
    # Compute the l2 distance between all test points and all training      #
    # points without using any explicit loops, and store the result in      #
    # dists.                                                                #
    #                                                                       #
    # You should implement this function using only basic array operations; #
    # in particular you should not use functions from scipy,                #
    # nor use np.linalg.norm().                                             #
    #                                                                       #
    # HINT: Try to formulate the l2 distance using matrix multiplication    #
    #       and two broadcast sums.                                         #
    #########################################################################
    # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****

    # 将L2距离展开为多项式，用reshape触发numpy的广播功能
    dists += np.sum(X ** 2, axis=1).reshape(num_test, 1)
    dists += np.sum(self.X_train ** 2, axis=1).reshape(1, num_train)
    dists -= 2 * (X @ self.X_train.T)
    dists = np.sqrt(dists)
    pass

    # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****
    return dists
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试一下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;In[9]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Now implement the fully vectorized version inside compute_distances_no_loops
# and run the code
dists_two = classifier.compute_distances_no_loops(X_test)

# check that the distance matrix agrees with the one we computed before:
difference = np.linalg.norm(dists - dists_two, ord=&apos;fro&apos;)
print(&apos;No loop difference was: %f&apos; % (difference, ))
if difference &amp;lt; 0.001:
    print(&apos;Good! The distance matrices are the same&apos;)
else:
    print(&apos;Uh-oh! The distance matrices are different&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Out[9]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;No loop difference was: 0.000000
Good! The distance matrices are the same
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果得出以上结果，则证明实现正确。&lt;/p&gt;
&lt;h4&gt;比对三种实现方式的速度&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;In[10]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Let&apos;s compare how fast the implementations are
def time_function(f, *args):
    &quot;&quot;&quot;
    Call a function f with args and return the time (in seconds) that it took to execute.
    &quot;&quot;&quot;
    import time
    tic = time.time()
    f(*args)
    toc = time.time()
    return toc - tic

two_loop_time = time_function(classifier.compute_distances_two_loops, X_test)
print(&apos;Two loop version took %f seconds&apos; % two_loop_time)

one_loop_time = time_function(classifier.compute_distances_one_loop, X_test)
print(&apos;One loop version took %f seconds&apos; % one_loop_time)

no_loop_time = time_function(classifier.compute_distances_no_loops, X_test)
print(&apos;No loop version took %f seconds&apos; % no_loop_time)

# You should see significantly faster performance with the fully vectorized implementation!

# NOTE: depending on what machine you&apos;re using, 
# you might not see a speedup when you go from two loops to one loop, 
# and might even see a slow-down.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Out[10]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Two loop version took 24.983689 seconds
One loop version took 38.931001 seconds
No loop version took 0.206878 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不知为什么，我这里的测试结果中，&lt;code&gt;Two loop&lt;/code&gt;总是慢于&lt;code&gt;One loop&lt;/code&gt;，不过问题不大。&lt;/p&gt;
&lt;p&gt;重点在于纯向量化的代码运行速度远大于循环，其实本人曾经手写过KNN， 跑一次预测需要超过 $30min$ ，可见向量化计算的重要性。&lt;/p&gt;
&lt;h3&gt;交叉验证与测试&lt;/h3&gt;
&lt;p&gt;测试 $k$ 不同的取值时的精确度：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;In[11]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;num_folds = 5
k_choices = [1, 3, 5, 8, 10, 12, 15, 20, 50, 100]

X_train_folds = []
y_train_folds = []
################################################################################
# TODO:                                                                        #
# Split up the training data into folds. After splitting, X_train_folds and    #
# y_train_folds should each be lists of length num_folds, where                #
# y_train_folds[i] is the label vector for the points in X_train_folds[i].     #
# Hint: Look up the numpy array_split function.                                #
################################################################################
# *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****
X_train_folds = np.split(X_train, num_folds)
y_train_folds = np.split(y_train, num_folds)
# print(X_train_folds[1].shape)
# print(y_train_folds[1].shape)
pass

# *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****

# A dictionary holding the accuracies for different values of k that we find
# when running cross-validation. After running cross-validation,
# k_to_accuracies[k] should be a list of length num_folds giving the different
# accuracy values that we found when using that value of k.
k_to_accuracies = {}


################################################################################
# TODO:                                                                        #
# Perform k-fold cross validation to find the best value of k. For each        #
# possible value of k, run the k-nearest-neighbor algorithm num_folds times,   #
# where in each case you use all but one of the folds as training data and the #
# last fold as a validation set. Store the accuracies for all fold and all     #
# values of k in the k_to_accuracies dictionary.                               #
################################################################################
# *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****
for k in k_choices:
    k_to_accuracies[k] = np.zeros(num_folds)
    acc = []
    for i in range(0, num_folds):
        X_tr = X_train_folds[: i] + X_train_folds[i+1 :]
        y_tr = y_train_folds[: i] + y_train_folds[i+1 :]
        X_tr = np.concatenate(X_tr, axis=0)
        y_tr = np.concatenate(y_tr, axis=0)
        classifier = KNearestNeighbor()
        classifier.train(X_tr, y_tr)
        X_cv = X_train_folds[i]
        y_cv = y_train_folds[i]
        y_cv_pred = classifier.predict(X_cv, k=k, num_loops=0)
        num_correst = np.mean(y_cv_pred == y_cv)
        acc.append(num_correst)
    k_to_accuracies[k] = acc
# pass

# *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****

# Print out the computed accuracies
for k in sorted(k_to_accuracies):
    for accuracy in k_to_accuracies[k]:
        print(&apos;k = %d, accuracy = %f&apos; % (k, accuracy))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Out[11]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;k = 1, accuracy = 0.263000
k = 1, accuracy = 0.257000
k = 1, accuracy = 0.264000
k = 1, accuracy = 0.278000
k = 1, accuracy = 0.266000
k = 3, accuracy = 0.239000
k = 3, accuracy = 0.249000
k = 3, accuracy = 0.240000
k = 3, accuracy = 0.266000
k = 3, accuracy = 0.254000
k = 5, accuracy = 0.248000
k = 5, accuracy = 0.266000
k = 5, accuracy = 0.280000
k = 5, accuracy = 0.292000
k = 5, accuracy = 0.280000
k = 8, accuracy = 0.262000
k = 8, accuracy = 0.282000
k = 8, accuracy = 0.273000
k = 8, accuracy = 0.290000
k = 8, accuracy = 0.273000
k = 10, accuracy = 0.265000
k = 10, accuracy = 0.296000
k = 10, accuracy = 0.276000
k = 10, accuracy = 0.284000
k = 10, accuracy = 0.280000
k = 12, accuracy = 0.260000
k = 12, accuracy = 0.295000
k = 12, accuracy = 0.279000
k = 12, accuracy = 0.283000
k = 12, accuracy = 0.280000
k = 15, accuracy = 0.252000
k = 15, accuracy = 0.289000
k = 15, accuracy = 0.278000
k = 15, accuracy = 0.282000
k = 15, accuracy = 0.274000
k = 20, accuracy = 0.270000
k = 20, accuracy = 0.279000
k = 20, accuracy = 0.279000
k = 20, accuracy = 0.282000
k = 20, accuracy = 0.285000
k = 50, accuracy = 0.271000
k = 50, accuracy = 0.288000
k = 50, accuracy = 0.278000
k = 50, accuracy = 0.269000
k = 50, accuracy = 0.266000
k = 100, accuracy = 0.256000
k = 100, accuracy = 0.270000
k = 100, accuracy = 0.263000
k = 100, accuracy = 0.256000
k = 100, accuracy = 0.263000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可视化结果：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;In[12]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# plot the raw observations
for k in k_choices:
    accuracies = k_to_accuracies[k]
    plt.scatter([k] * len(accuracies), accuracies)

# plot the trend line with error bars that correspond to standard deviation
accuracies_mean = np.array([np.mean(v) for k,v in sorted(k_to_accuracies.items())])
accuracies_std = np.array([np.std(v) for k,v in sorted(k_to_accuracies.items())])
plt.errorbar(k_choices, accuracies_mean, yerr=accuracies_std)
plt.title(&apos;Cross-validation on k&apos;)
plt.xlabel(&apos;k&apos;)
plt.ylabel(&apos;Cross-validation accuracy&apos;)
plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Out[12]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/03/25/6Xf4IS.png&quot; alt=&quot;6Xf4IS.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以发现在此数据集下， $k=10$ 时效果最好。&lt;/p&gt;
&lt;p&gt;现在可以跑一跑测试集了：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;In[13]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Based on the cross-validation results above, choose the best value for k,   
# retrain the classifier using all the training data, and test it on the test
# data. You should be able to get above 28% accuracy on the test data.
best_k = 10

classifier = KNearestNeighbor()
classifier.train(X_train, y_train)
y_test_pred = classifier.predict(X_test, k=best_k)

# Compute and display the accuracy
num_correct = np.sum(y_test_pred == y_test)
accuracy = float(num_correct) / num_test
print(&apos;Got %d / %d correct =&amp;gt; accuracy: %f&apos; % (num_correct, num_test, accuracy))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Out[13]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Got 141 / 500 correct =&amp;gt; accuracy: 0.282000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终我们获得了 $28.2%$ 的准确率。&lt;/p&gt;
&lt;h2&gt;请参阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://zhuanlan.zhihu.com/p/20894041&lt;/li&gt;
&lt;li&gt;https://zhuanlan.zhihu.com/p/20900216&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>【OI考古】数论基础 | 快速幂、最大公约数、线性筛素数</title><link>https://blog.vonbrank.com/posts/oi-number-theory-quickpow-gcd-eulersieve/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/oi-number-theory-quickpow-gcd-eulersieve/</guid><description>介绍几种入门级的数论算法</description><pubDate>Mon, 22 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;快速幂&lt;/h2&gt;
&lt;p&gt;以 $a = 2, n = 10$ 的情况为例，注意到 $10 = 2^1 + 2^3$ ，则 $2^{10}$ 可表示为 $2^{2^1}\times2^{2^3}$ ，利用二进制拆分，可以实现在 $O(\log_{}{n})$ 时间范围内计算出 $a^n$ 的值。&lt;/p&gt;
&lt;h3&gt;模板题：&lt;a href=&quot;https://www.luogu.com.cn/problem/P1226&quot;&gt;洛谷 P1226 | [模板]快速幂||取余运算&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;给你三个整数 $b,p,k$ ，求 $b^p mod k$ 。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;输入只有一行三个整数，分别代表 $b,p,k$&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出一行一个字符串 &lt;code&gt;b^p mod k=s&lt;/code&gt;，其中 $b, p, k$ 分别为题目给定的值， $s$ 为运算结果。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;2 10 9
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;2^10 mod 9=7
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;h5&gt;样例输入输出 1 解释&lt;/h5&gt;
&lt;p&gt;$2^{10} = 1024， 1024\ mod\ 9 = 7$ 。&lt;/p&gt;
&lt;h5&gt;数据规模与约定&lt;/h5&gt;
&lt;p&gt;对于 $100%$ 的数据，保证 $0\le b,p &amp;lt; 2^{31}，1 \leq k \lt 2^{31}$ 。&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
long long b, p, k;
long long quick_pow(long long base, long long exp, long long mod)
{
    if (mod == 1)	//任何数模1都等于0
        return 0;
    if (exp == 0)	//任何非零常数的0次方都等于1
        return 1;
    long long ans = 1;
    while (exp)
    {
        if (exp &amp;amp; 1)	//如果末尾为1，则需要乘上该位的指数
        {
            ans *= base;
            ans %= mod;	//每步必模
        }
        base = base * base;
        base %= mod;
        exp &amp;gt;&amp;gt;= 1;
    }
    return ans;
}
int main()
{
    scanf(&quot;%lld %lld %lld&quot;, &amp;amp;b, &amp;amp;p, &amp;amp;k);
    printf(&quot;%lld^%lld mod %lld=%lld&quot;, b, p, k, quick_pow(b, p, k));
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;最大公约数（GCD）&lt;/h2&gt;
&lt;p&gt;要求 $a, b$ 的最大公约数，可使用欧几里得辗转相除法。时间复杂度为 $O(\log_{}{n})$&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
long long gcd(long long a, long long b)
{
    if (a % b)
        return gcd(b, a % b);
    else
        return b;
}
int main()
{
    long long a, b;
    scanf(&quot;%lld %lld&quot;, &amp;amp;a, &amp;amp;b);
    printf(&quot;%lld&quot;, gcd(a, b));
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;线性筛素数&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/03/22/6oPlEn.png&quot; alt=&quot;6oPlEn.png&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;模板题： &lt;a href=&quot;https://www.luogu.com.cn/problem/P3383&quot;&gt;洛谷 P3383 | [模板]线性筛素数&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;给定一个范围 $n$ ，有 $q$  个询问，每次输出第 $k$  小的素数。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第一行包含两个正整数 $n,q$，分别表示查询的范围和查询的个数。 接下来 $q$  行每行一个正整数 $k$ ，表示查询第 $k$ 小的素数。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;输出 $q$ 行，每行一个正整数表示答案。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;100 5
1
2
3
4
5
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;2
3
5
7
11
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;h5&gt;样例输入输出 1 解释&lt;/h5&gt;
&lt;p&gt;$2^{10} = 1024， 1024\ mod\ 9 = 7$ 。&lt;/p&gt;
&lt;h5&gt;数据规模与约定&lt;/h5&gt;
&lt;p&gt;对于 $100%$ 的数据， $n = 10^8$ ， $1 \le q \le 10^6$ ，保证查询的素数不大于 $n$ 。&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
const int maxn = 100000500;
int n, p, k, cnt;
int prime[maxn / 10];
bool isprime[maxn];
int main()
{
    isprime[0] = isprime[1] = true;
    scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;p);
    for (int i = 1; i &amp;lt;= n; i++)
    {
        if (!isprime[i])
        {
            prime[++cnt] = i;
        }
        for (int j = 1; i * prime[j] &amp;lt;= n &amp;amp;&amp;amp; j &amp;lt;= cnt; j++)
        {
            isprime[i * prime[j]] = true;	//i与小于i的所有素数之积都是合数
            if (i % prime[j] == 0)	//若i可以整除一个比它小的素数，则停止遍历，保证每个合数只需要标记一次
                break;
        }
    }
    for (int i = 1; i &amp;lt;= p; i++)
    {
        scanf(&quot;%d&quot;, &amp;amp;k);
        printf(&quot;%d\n&quot;, prime[k]);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>CS231n | 先决条件 Preparation</title><link>https://blog.vonbrank.com/posts/cs231n-preparation/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/cs231n-preparation/</guid><pubDate>Sun, 21 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;近期在和朋友做计算机视觉相关的年度项目，根据导师的建议，我们选择了Stanford的CS231n课程作为计算机视觉的入门课程。然而由于某些原因， &lt;s&gt;初期的学习线路出了一些偏差，&lt;/s&gt; 临近中期才发现CS231n官方提供了非常完善的笔记和作业文档，免去了大面积重复造轮子的工作，只需要编写部分核心代码。因此我决定重修CS231n课程，写下这一系列文章记录学习过程。&lt;/p&gt;
&lt;p&gt;本文提供开始学习前CS231n的准备步骤，主要翻译自官方提供的&lt;a href=&quot;https://cs231n.github.io/setup-instructions/&quot;&gt;Software Setup&lt;/a&gt;文档，供日后查询。&lt;/p&gt;
&lt;h2&gt;使用Google Colaboratory工作&lt;/h2&gt;
&lt;h2&gt;在本地设备上工作&lt;/h2&gt;
&lt;h3&gt;配置Anaconda虚拟环境&lt;/h3&gt;
&lt;p&gt;CS231n官方推荐使用Anaconda搭建Python编程环境并管理Numpy等包及其依赖项。这样做的好处之一在于，其自带&lt;a href=&quot;https://docs.anaconda.com/mkl-optimizations/&quot;&gt;MKL优化&lt;/a&gt;，这可以加速&lt;code&gt;numpy&lt;/code&gt;与&lt;code&gt;scipy&lt;/code&gt;代码的执行。&lt;/p&gt;
&lt;p&gt;Anaconda虚拟环境的搭建在其他文章中已做介绍，在此不再赘述。&lt;/p&gt;
&lt;p&gt;安装完Anaconda后，需创建名为&lt;code&gt;cs231n&lt;/code&gt;的虚拟环境，可以在终端中运行以下指令创建：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 这将在&apos;path/to/anaconda3/envs/&apos;下创建
# 名为cs231n的Anaconda虚拟环境
conda create -n cs231n python=3.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要激活并进入所创建的环境，请运行&lt;code&gt;conda activate cs231n&lt;/code&gt;；要禁用并退出环境，请运行&lt;code&gt;conda deactivate cs231n&lt;/code&gt;或关闭终端。需要注意的是，每次写作业前都需要重新运行&lt;code&gt;conda activate cs231n&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;安装包集合&lt;/h3&gt;
&lt;p&gt;激活虚拟环境后，你需要安装课程所需的Numpy，Matplotlib等库。为安装所有依赖项，你可以下先下载Assignment#1的Jupyter notebook&lt;a href=&quot;https://cs231n.github.io/assignments/2020/assignment1_jupyter.zip&quot;&gt;笔记文件&lt;/a&gt;，通过以下指令进入Assignment#1的文件目录，并通过&lt;code&gt;conda&lt;/code&gt;或&lt;code&gt;pip&lt;/code&gt;安装&lt;code&gt;requirements.txt&lt;/code&gt;所列出的依赖项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 再次提醒, 在运行以下指令之前
# 请确保虚拟环境已被激活
cd assignment1  # 进入assignment的目录

# 安装assignment的依赖项。
# 虚拟环境激活后，pip将自动安装
# requirements.txt中列出的所有依赖项
# 并与Python进行连接
pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;下载CIFAR-10数据集&lt;/h3&gt;
&lt;p&gt;CS231n课程围绕CIFAR-10数据集的处理进行，要获得CIFAR-10，你可以进入&lt;code&gt;assignment1&lt;/code&gt;的主目录，在终端中执行以下指令下载;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd cs231n/datasets
./get_datasets.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而由于&lt;a href=&quot;https://baike.baidu.com/item/%E9%98%B2%E7%81%AB%E5%A2%99%E9%95%BF%E5%9F%8E/13015775&quot;&gt;众所周知的原因&lt;/a&gt;，这种方式通常会失败。因此，你可以到&lt;a href=&quot;https://www.cs.toronto.edu/~kriz/cifar.html&quot;&gt;CIFAR-10的官网&lt;/a&gt;手动下载&lt;a href=&quot;https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz&quot;&gt;数据集&lt;/a&gt;，并解压到&lt;code&gt;cs231n/datasets&lt;/code&gt;目录，其效果与运行上述命令一致。&lt;/p&gt;
&lt;h3&gt;启用IPython&lt;/h3&gt;
&lt;p&gt;CS231n官方提供的Assignment文件提供了丰富的辅助理解内容。你可以在激活&lt;code&gt;cs231n&lt;/code&gt;环境后&lt;code&gt;cd&lt;/code&gt;到&lt;code&gt;assignment1&lt;/code&gt;主目录，运行&lt;code&gt;jupyter notebook&lt;/code&gt;，此时会打开一个网页，接着转跳至IPython的文件管理页面，到此为止，我们就可以愉快地开始写CS231n课程作业了。&lt;/p&gt;
</content:encoded></item><item><title>【OI考古】基础算法 | 搜索</title><link>https://blog.vonbrank.com/posts/oi-basic-algorithm-search/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/oi-basic-algorithm-search/</guid><pubDate>Sat, 20 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;搜索，是&lt;a href=&quot;https://yukkohzq.github.io/&quot;&gt;Yukko&lt;/a&gt;首先给我介绍的几类算法之一，其对状态空间进行枚举，通过穷尽所有的可能来找到最优解，或者统计合法解的个数。&lt;/p&gt;
&lt;p&gt;搜索有很多优化方式，如减小状态空间，更改搜索顺序，剪枝等。&lt;/p&gt;
&lt;p&gt;搜索是一些高级算法的基础。在 OI 中，纯粹的搜索往往也是得到部分分的手段，但可以通过纯粹的搜索拿到满分的题目非常少。&lt;/p&gt;
&lt;h2&gt;DFS（深度优先搜索）&lt;/h2&gt;
&lt;p&gt;DFS 本是图论概念，在搜索算法中，该词常常指利用递归函数方便地实现暴力枚举的算法，与图论中的 DFS 算法有一定相似之处，但并不完全相同。&lt;/p&gt;
&lt;h3&gt;DFS 框架&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
using namespace std;
const int maxn = 100;
int n;
bool vst[];
bool CheckEdge(...) // 边界条件和约束条件的判断
{
    if (...) // 满足条件
        return 1;
    else // 与约束条件冲突
        return 0;
}

void dfs(int depth)
{
    if (depth &amp;gt; n) // 出现目标态G
    {
        ...... // 做相应处理
        return;
    }
    for (int i = 1; i &amp;lt; n; i++) // 按照规则生成下一个节点
    {
        if (!CheckEdge(...)) continue; //如果不满足条件则跳过
        vst[] = 1;      // 标记该节点被访问过
        dfs(depth + 1);
        vst[] = 0;      // 回溯
    }
}
int main()
{
    ......
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;例题&lt;/h3&gt;
&lt;h4&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1706&quot;&gt;洛谷 P1706 | 全排列问题&lt;/a&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1219&quot;&gt;洛谷 P1219 | [USACO1.5]八皇后 Checker Challenge&lt;/a&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1092&quot;&gt;洛谷 P1092 | [NOIP2004 提高组] 虫食算&lt;/a&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1120&quot;&gt;洛谷 P1120 | 小木棍 [数据加强版] &lt;/a&gt;&lt;/h4&gt;
&lt;h3&gt;洛谷 P1706 | 全排列问题&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;输出自然数 $1$ 到 $n$ 所有不重复的排列，即 $n$ 的全排列，要求所产生的任一数字序列中不允许出现重复的数字。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;一个整数 $n$ 。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;由 $1∼n$ 组成的所有不重复的数字序列，每行一个序列。&lt;/p&gt;
&lt;p&gt;每个数字保留 $5$ 个场宽。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;3
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;    1    2    3
    1    3    2
    2    1    3
    2    3    1
    3    1    2
    3    2    1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;p&gt;$1≤n≤9$&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
const int maxn = 20;
int n;
int now[maxn];
bool vis[maxn];
void dfs(int depth)
{
    if(depth &amp;gt; n)
    {
        for(int i=1; i&amp;lt;=n; i++)
        {
            printf(&quot;%5d&quot;, now[i]);
        }
        puts(&quot;&quot;);
        return;
    }
    for(int i=1; i&amp;lt;=n; i++)
    {
        if(vis[i]) continue;
        vis[i] = true;
        now[depth] = i;
        dfs(depth + 1);
        vis[i] = false;
    }
}
int main()
{
    scanf(&quot;%d&quot;, &amp;amp;n);
    dfs(1);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;BFS（广度优先搜索）&lt;/h2&gt;
&lt;p&gt;BFS 是图论中的一种遍历算法，在搜索中也很常用，将每个状态对应为图中的一个点，将状态存入队列即可。&lt;/p&gt;
&lt;h3&gt;BFS 框架&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
const int maxn = 100;
bool vst[maxn][maxn];                       // 访问标记
int dir[4][2] = {0, 1, 0, -1, 1, 0, -1, 0}; // 方向向量

struct State // BFS 队列中的状态数据结构
{
    int x, y;         // 坐标位置
    int Step_Counter; // 搜索步数统计器
};

State a[maxn];

bool CheckState(State s) // 约束条件检验
{
    if (!vst[s.x][s.y] &amp;amp;&amp;amp; ...) // 满足条件
        return 1;
    else // 约束条件冲突
        return 0;
}

void bfs(State st)
{
    queue&amp;lt;State&amp;gt; q;      // BFS 队列
    State now, next;     // 定义2 个状态，当前和下一个
    st.Step_Counter = 0; // 计数器清零
    q.push(st);          // 入队
    vst[st.x][st.y] = 1; // 访问标记
    while (!q.empty())
    {
        now = q.front(); // 取队首元素进行扩展
        if (now == G)    // 出现目标态，此时为Step_Counter 的最小值，可以退出即可
        {
            ...... // 做相关处理
                return;
        }
        for (int i = 0; i &amp;lt; 4; i++)
        {
            next.x = now.x + dir[i][0]; // 按照规则生成下一个状态
            next.y = now.y + dir[i][1];
            next.Step_Counter = now.Step_Counter + 1; // 计数器加1
            if (CheckState(next))                     // 如果状态满足约束条件则入队
            {
                q.push(next);
                vst[next.x][next.y] = 1; //访问标记
            }
        }
        q.pop(); // 队首元素出队
    }
    return;
}

int main()
{
    ......
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;例题&lt;/h3&gt;
&lt;h4&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1141&quot;&gt;洛谷 P1141 | 01 迷宫&lt;/a&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1126&quot;&gt;洛谷 P1126 | 机器人搬重物&lt;/a&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1312&quot;&gt;洛谷 P1312 | [NOIP2011 提高组] Mayan 游戏&lt;/a&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1514&quot;&gt;洛谷 P1514 | [NOIP2010 提高组] 引水入城&lt;/a&gt;&lt;/h4&gt;
&lt;h3&gt;P1141 01 迷宫&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;有一个仅由数字 $0$ 与 $1$ 组成的 $n \times n$ 格迷宫。若你位于一格 $0$ 上，那么你可以移动到相邻 44 格中的某一格 $1$ 上，同样若你位于一格 $1$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $0$ 上。&lt;/p&gt;
&lt;p&gt;你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第 $1$ 行为两个正整数 $n, m$ 。&lt;/p&gt;
&lt;p&gt;下面 $n$ 行，每行 $n$ 个字符，字符只可能是 $0$ 或者 $1$ ，字符之间没有空格。&lt;/p&gt;
&lt;p&gt;接下来 $m$ 行，每行 $2$ 个用空格分隔的正整数 $i, j$ ，对应了迷宫中第 $i$ 行第 $j$ 列的一个格子，询问从这一格开始能移动到多少格。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;$m$ 行，对于每个询问输出相应答案。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;2 2
01
10
1 1
2 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;4
4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;p&gt;所有格子互相可达。&lt;/p&gt;
&lt;p&gt;对于 $20%$ 的数据， $n≤10$ ；&lt;/p&gt;
&lt;p&gt;对于 $40%$ 的数据， $n≤50$ ；&lt;/p&gt;
&lt;p&gt;对于 $50%$ 的数据， $m≤5$ ；&lt;/p&gt;
&lt;p&gt;对于 $60%$ 的数据， $n≤100,m≤100$ ；&lt;/p&gt;
&lt;p&gt;对于 $100%$ 的数据， $n≤1000,m≤100000$ 。&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;
using namespace std;
const int maxn = 1050;
class Tuple	//坐标类
{
public:
    int _x_, _y_;
    Tuple()
    {
        _x_ = _y_ = 0;
    }
    void val(int x_, int y_)
    {
        _x_ = x_;
        _y_ = y_;
    }
    Tuple operator+(const Tuple &amp;amp;b_)
    {
        Tuple c_;
        c_._x_ = this-&amp;gt;_x_ + b_._x_;
        c_._y_ = this-&amp;gt;_y_ + b_._y_;
        return c_;
    }
};
int n, m;
int mp[maxn][maxn], ans[maxn][maxn];
struct Node	//节点
{
    Tuple c;
    int d;
};
bool check(Tuple p, Tuple q)	//检查节点是否合法
{
    int x = p._x_, y = p._y_;
    int a = q._x_, b = q._y_;
    if (ans[x][y])
        return false;
    if (x == 0 || y == 0)
        return false;
    if (x == n + 1 || y == n + 1)
        return false;
    if (mp[x][y] ^ mp[a][b])
        return true;
    return false;
}
int bfs(int x, int y)
{
    if (ans[x][y])
        return ans[x][y];

    Tuple mv[4];
    mv[0].val(0, 1);
    mv[1].val(0, -1);
    mv[2].val(1, 0);
    mv[3].val(-1, 0);

    Node tmp;
    tmp.c.val(x, y);
    tmp.d = 1;

    queue&amp;lt;Node&amp;gt; tree;
    tree.push(tmp);

    vector&amp;lt;Tuple&amp;gt; zone;

    int ansn = 0;
    ans[x][y] = 1;

    while (!tree.empty())
    {
        tmp = tree.front();
        tree.pop();
        zone.push_back(tmp.c);
        ansn++;
        for (int i = 0; i &amp;lt; 4; i++)
        {
            Node now;
            now.c = tmp.c + mv[i];
            now.d = tmp.d + 1;
            if (!check(now.c, tmp.c))
                continue;
            tree.push(now);
            ans[now.c._x_][now.c._y_] = ansn;
        }
    }
    for (int i = 0; i &amp;lt; zone.size(); i++)
    {
        int x_ = zone[i]._x_;
        int y_ = zone[i]._y_;
        ans[x_][y_] = ansn;
    }
    return ansn;
}
int main()
{
    scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;m);
    for (int i = 1; i &amp;lt;= n; i++)
    {
        for (int j = 1; j &amp;lt;= n; j++)
        {
            char l[5];
            scanf(&quot;%1s&quot;, l);
            mp[i][j] = l[0] - &apos;0&apos;;
        }
    }
    for (int i = 1; i &amp;lt;= m; i++)
    {
        int x, y;
        scanf(&quot;%d %d&quot;, &amp;amp;x, &amp;amp;y);
        printf(&quot;%d\n&quot;, bfs(x, y));
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;请参阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://blog.csdn.net/kkkkde/article/details/82986992&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://oi-wiki.org/search/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>【OI考古】基础算法 | 排序</title><link>https://blog.vonbrank.com/posts/oi-basic-algorithm-sort/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/oi-basic-algorithm-sort/</guid><pubDate>Sat, 20 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;排序算法&lt;/strong&gt;（Sorting algorithm）是一种将一组特定的数据按某种顺序进行排列的算法。排序算法多种多样，性质也大多不同。&lt;/p&gt;
&lt;p&gt;几种排序算法的比较：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/03/20/6hhmgH.gif&quot; alt=&quot;6hhmgH.gif&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;模板题：&lt;a href=&quot;https://www.luogu.com.cn/problem/P1177&quot;&gt;洛谷 P1177 | [模板]快速排序&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;题目描述&lt;/h4&gt;
&lt;p&gt;利用快速排序算法将读入的 $N$ 个数从小到大排序后输出。&lt;/p&gt;
&lt;h4&gt;输入格式&lt;/h4&gt;
&lt;p&gt;第 $1$ 行为一个正整数 $N$，第 $2$ 行包含 $N$ 个空格隔开的正整数 $a_i$ ，为你需要进行排序的数，数据保证了 $a_i$ 不超过 $10^9$ 。&lt;/p&gt;
&lt;h4&gt;输出格式&lt;/h4&gt;
&lt;p&gt;将给定的 $N$ 个数从小到大输出，数之间空格隔开，行末换行且无空格。&lt;/p&gt;
&lt;h4&gt;输入输出样例&lt;/h4&gt;
&lt;h5&gt;输入 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;5
4 2 4 5 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;输出 #1&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;1 2 4 4 5
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;说明/提示&lt;/h4&gt;
&lt;p&gt;对于 $20%$ 的数据，有 $N\leq 10^3$ ；&lt;/p&gt;
&lt;p&gt;对于 $100%$ 的数据，有 $N\leq 10^5$ 。&lt;/p&gt;
&lt;h2&gt;快速排序&lt;/h2&gt;
&lt;p&gt;快速排序（Quicksort），又称分区交换排序（partition-exchange sort），简称快排，是一种被广泛运用的排序算法。&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
const int maxn = 100500;
int n;
int a[maxn];
void quick_sort(int a_[], int l, int r)
{
    int mid = a_[(l + r) &amp;gt;&amp;gt; 1]; //取区间中点的数，也可以随机化取数
    int i = l;
    int j = r;
    do
    {
        while (a_[i] &amp;lt; mid) //如果合法，就继续遍历
            i++;
        while (a_[j] &amp;gt; mid)
            j--;
        if (i &amp;lt;= j) //找到一对不合法的数，将其交换
        {
            swap(a_[i], a_[j]);
            i++;
            j--;
        }
    } while (i &amp;lt;= j); //最终的效果是[l, j]内的数都≤mid，[i, r]内的数都≥mid，与初始mid的位置无关
    if (l &amp;lt; j)        //如果[l, j]是一个合法区间，则继续排序
        quick_sort(a_, l, j);
    if (r &amp;gt; i) //如果[i, r]是一个合法区间，则继续排序
        quick_sort(a_, i, r);
}
int main()
{
    scanf(&quot;%d&quot;, &amp;amp;n);
    for (int i = 1; i &amp;lt;= n; i++)
    {
        scanf(&quot;%d&quot;, &amp;amp;a[i]);
    }
    quick_sort(a, 1, n);
    for (int i = 1; i &amp;lt;= n; i++)
    {
        printf(&quot;%d &quot;, a[i]);
    }
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;归并排序&lt;/h2&gt;
&lt;p&gt;归并排序（merge sort）是一种采用了 &lt;a href=&quot;https://oi-wiki.org/basic/divide-and-conquer/&quot;&gt;分治&lt;/a&gt; 思想的排序算法。&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
const int maxn = 100500;
int n;
int a[maxn];
void merge_sort(int a_[], int l, int r)
{
    int mid = (l + r) &amp;gt;&amp;gt; 1; //取区间中点，左右子区间分别排序
    int len = r - l + 1;
    if (l &amp;lt; mid)
        merge_sort(a_, l, mid);
    if (r &amp;gt; mid + 1)
        merge_sort(a_, mid + 1, r);
    int tmp[len];
    int i = l, j = mid + 1, k = 0;
    while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= r) //将两个有序数组合并，保存在临时数组tmp中
        tmp[k++] = a_[i] &amp;lt; a_[j] ? a_[i++] : a_[j++];
    while (i &amp;lt;= mid)
        tmp[k++] = a_[i++];
    while (j &amp;lt;= r)
        tmp[k++] = a_[j++];
    for (i = 0; i &amp;lt; len; i++) //将tmp数组中的临时有序序列传回a_数组
    {
        a_[l + i] = tmp[i];
    }
}

int main()
{
    scanf(&quot;%d&quot;, &amp;amp;n);
    for (int i = 1; i &amp;lt;= n; i++)
    {
        scanf(&quot;%d&quot;, &amp;amp;a[i]);
    }
    merge_sort(a, 1, n);
    for (int i = 1; i &amp;lt;= n; i++)
    {
        printf(&quot;%d &quot;, a[i]);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;例题&lt;/h3&gt;
&lt;h4&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1309&quot;&gt;洛谷 P1309 | [NOIP2011 普及组] 瑞士轮&lt;/a&gt;&lt;/h4&gt;
&lt;h2&gt;请参阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://oi-wiki.org/basic/sort-intro/&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>Anaconda部署与使用指南（Windows）</title><link>https://blog.vonbrank.com/posts/deploy-anaconda-on-windows/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/deploy-anaconda-on-windows/</guid><pubDate>Sat, 13 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;这几天在计划在重修 &lt;s&gt;(bushi)&lt;/s&gt; Stanford University的计算机视觉基础课&lt;a href=&quot;http://cs231n.stanford.edu/&quot;&gt;CS231n&lt;/a&gt;，在其课程作业（Assignments）中推荐使用Anaconda为课程创建虚拟环境以完成作业。本文将简要介绍Anaconda在Windows下的使用方法。&lt;/p&gt;
&lt;h2&gt;先决条件&lt;/h2&gt;
&lt;p&gt;对于许多Python初学者（比如我）来说，也许难以理解为什么需要需要像Anaconda这样的虚拟环境工具，因此会对项目中涉及此类工具的环节和操作感到一头雾水。因此在了解Anaconda的使用方法前，应先理解其存在的目的。&lt;/p&gt;
&lt;h3&gt;Python解释器&lt;/h3&gt;
&lt;p&gt;初学Python的人大都有过这样的经历：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;依照教程到Python官网下载某个特定的安装包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装时记得勾选将Python设为环境变量的选项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后打开控制台，输入&lt;code&gt;python&lt;/code&gt;，出现以下信息即表明Python安装成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/13/6dvr8I.md.png&quot; alt=&quot;6dvr8I.md.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接着就可以在各类ide或文本编辑器愉快地写代码了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;过了不久，我们会知道，某些代码运行在Python 2.x上，与Python 3.x不兼容，需要再安装一个Python 2.x的解释器，这时需要想办法使两款解释器共存。问题不难解决，只是在切换环境变量比较麻烦而已。&lt;/p&gt;
&lt;h3&gt;Python中的包&lt;/h3&gt;
&lt;p&gt;Python中的包可以认为是一些模块的集合，所有包又组成一个包集合。我们会接触一些常见的包，如科学计算库Numpy，绘图库Matplotlib。每个Python程序都需要依赖特定的Python版本和Python包。在同一个环境中编写基于不同Python解释器的程序时的环境切换问题尚且能够解决，但不同程序所依赖的包往往不同，意味着所有程序的包都需要安装到同一个系统环境下，导致环境混乱，此外，在不同终端开发同一程序又面临包集合的迁移问题，非常麻烦。&lt;/p&gt;
&lt;h3&gt;Anaconda&lt;/h3&gt;
&lt;p&gt;Anaconda正是为了解决上述问题而产生，其通过创建虚拟环境，将每个Python程序所需的独有开发环境，即对应的解释器，所需的包集合打包出来，需要开发某一程序时只需要切换到对应的环境即可，非常优雅。&lt;/p&gt;
&lt;h2&gt;Anaconda 安装&lt;/h2&gt;
&lt;p&gt;推荐在&lt;a href=&quot;https://www.anaconda.com/products/individual&quot;&gt;官网&lt;/a&gt;下载Anaconda，首页底部的Python 3.8版本的Anaconda就不错。&lt;/p&gt;
&lt;p&gt;安装过程中，除了这一步需要看个人需求选择是否将Anaconda添加至环境变量外（我是全勾上了），其他都为默认值即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/13/6wKxBD.png&quot; alt=&quot;6wKxBD.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;安装完成之后，在「开始」菜单中可以看见多了不少项，你可以直接在PowerShell、Windows Terminal等系统自带终端中使用Anaconda，但推荐使用Anaconda PowerShell Prompt，打开之后也是类似终端的操作，事实上你可以在Windows Terminal的配置文件中添加一下项来在Windows Terminal中使用Anaconda：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    // Make changes here to the cmd.exe profile.
    &quot;guid&quot;: &quot;{0A9CC558-3024-89F3-5313-2C72A1789FEA}&quot;,
    &quot;name&quot;: &quot;Anaconda Prompt Powershell&quot;,
    &quot;commandline&quot;: &quot;%windir%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -ExecutionPolicy ByPass -NoExit -Command {你的Anaconda安装路径}\\shell\\condabin\\conda-hook.ps1; conda activate;&quot;,
    &quot;icon&quot;: &quot;{你的Anaconda安装路径}\\Menu\\anaconda-navigator.ico&quot;,
    &quot;hidden&quot;: false
},
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Anaconda 使用&lt;/h2&gt;
&lt;p&gt;打开Anaconda PowerShell Prompt，输入 &lt;code&gt;conda activate&lt;/code&gt;，可以看见路径前面多了一个&lt;code&gt;(base)&lt;/code&gt;，表明我们现在正处于Anaconda的默认环境中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/13/6w1LIe.md.png&quot; alt=&quot;6w1LIe.md.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在开始之前，可以先修改一下镜像源，这里我们使用清华源：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --set show_channel_urls yes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后更新一下所有工具包来避免可能发生的错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda upgrade --all
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;创建与管理虚拟环境和包&lt;/h3&gt;
&lt;p&gt;base环境是Anaconda为我们准备的默认配置，你也可以创建属于自己的环境，输入以下命令创建一个名为&lt;code&gt;test&lt;/code&gt;的环境：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda create -n test python=3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;python=3&lt;/code&gt;表示指定本环境所用的Python版本为Python 3.x的最新版本。若需进一步指定版本，如指定Python3.6，则可输入&lt;code&gt;python=3.7&lt;/code&gt;；若需使用Python 2.x，只需改为&lt;code&gt;python=2&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;接着通过下面的指令切换到我们想要的环境，如切换到&lt;code&gt;test&lt;/code&gt;环境：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda activate test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/13/6w3rJH.md.png&quot; alt=&quot;6w3rJH.md.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;有了环境我们就可以在里面安装所需的包了，如安装Numpy：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda install numpy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以注意到，在这里conda和pip 的使用方法是完全相同的。&lt;/p&gt;
&lt;h3&gt;常用命令&lt;/h3&gt;
&lt;p&gt;到此为止Anaconda的基本用法已经描述完毕，你可以在下面的列表中找到更多常用命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda activate // 切换到base环境

conda activate test // 切换到test环境

conda create -n test python=3 // 创建一个名为test的环境并指定python版本为3的最新版本

conda env list // 列出conda管理的所有环境

conda list // 列出当前环境的所有包

conda install numpy //安装numpy包

conda remove numpy //卸载numpy包

conda remove -n test --all // 删除test环境及下属所有包

conda update numpy //更新numpy包

conda env export &amp;gt; environment.yaml // 导出当前环境的包信息

conda env create -f environment.yaml // 用配置文件创建新的虚拟环境

conda init &amp;lt;SHELL_NAME&amp;gt; //首次使用时，在shell中初始化Anaconda

conda config --set auto_activate_base false // 取消打开命令行时，默认进入conda环境

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;环境变量&lt;/h3&gt;
&lt;p&gt;如果安装时没有默认勾选使用&lt;code&gt;conda&lt;/code&gt;环境变量，则可以手动配置以下环境变量，注意配置完成后一定要先重启，再使用，否则可能遇到玄学的Windows管理员权限问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//环境变量，以笔者设备为例，设置为Anaconda的安装位置

ANACONDA_HOME=C:\ProgramData\Anaconda3 


//Path列表

%ANACONDA_HOME%

%ANACONDA_HOME%\Scripts

%ANACONDA_HOME%\Library\bin

%ANACONDA_HOME%\Library\mingw-w64\bin

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;请参阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://www.jianshu.com/p/eaee1fadc1e9&lt;/li&gt;
&lt;li&gt;https://cloud.tencent.com/developer/article/1406417&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>Ubuntu 20.04 配置指南</title><link>https://blog.vonbrank.com/posts/ubuntu-20-04-config/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/ubuntu-20-04-config/</guid><pubDate>Thu, 04 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;最近遇到的项目需要在Linux环境下进行 &lt;s&gt;（因为WIndows版openpose的Python接口是坏的）&lt;/s&gt; ，由于各类Linux发行版不像Windows那样可以开箱即用，因此写下这篇文章记录Ubuntu 20.04下各种软件和环境的配置过程，方便个人查阅。本文将持续更新。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;System&lt;/h2&gt;
&lt;h3&gt;更换镜像源&lt;/h3&gt;
&lt;p&gt;Linux下的软件通常使用包管理器进行安装，Ubuntu默认的软件镜像源在国外，下载速度经常慢得离谱，因此我们需要更换为国内的镜像源。&lt;/p&gt;
&lt;p&gt;我们可以在「设置」-&amp;gt; 「关于」-&amp;gt;「软件和更新」-&amp;gt;「下载自」-&amp;gt;「其他站点」选择一个国内的镜像源，阿里源，淘宝源，清华源都是不错的选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/06/6nSyGt.md.png&quot; alt=&quot;6nSyGt.md.png&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;安装显卡驱动（NVIDIA）&lt;/h3&gt;
&lt;p&gt;本人使用的图形处理器是NVIDIA Geforce RTX 2060，然而我们会发现，在「设置」-&amp;gt; 「关于」中「图形」这一栏显示的不是我们的GPU。这是因为Ubuntu默认使用开源的显卡驱动，而非官方驱动，在性能和功能方面还是有些区别，而且无法部署CUDA环境，因此我们还是需要安装官方驱动 &lt;s&gt;（顺便打打游戏）&lt;/s&gt;  。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/06/6npiQK.md.png&quot; alt=&quot;6npiQK.md.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里提供一种 &lt;strong&gt;较简单&lt;/strong&gt; 的安装驱动操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在刚才的界面打开「软件和更新」，然后选择「附加驱动」，在加载出来的驱动列表中选择合适的驱动，然后点击「应用更改」。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/06/6n9ovV.md.png&quot; alt=&quot;6n9ovV.md.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装完成之后，系统会要求重启以加载驱动。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/06/6nCZ8I.png&quot; alt=&quot;6nCZ8I.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在此之前，会要求你设置密码，记得勾上前面的勾。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/06/6nCmxP.png&quot; alt=&quot;6nCmxP.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你图省事，设为“88888888”即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/06/6nCMqS.md.png&quot; alt=&quot;6nCMqS.md.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重新启动系统，会进入蓝色背景的Perform Mok Management界面，选择「Eroll Mok」。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/06/6nPuWR.md.jpg&quot; alt=&quot;6nPuWR.md.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进入Eroll Mok界面，选择「Continue」。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/06/6nPnY9.md.jpg&quot; alt=&quot;6nPnY9.md.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进入Eroll the Key界面，选择「Yes」。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/06/6nPmFJ.md.jpg&quot; alt=&quot;6nPmFJ.md.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入安装驱动时设置的密码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/06/6nP1OK.md.jpg&quot; alt=&quot;6nP1OK.md.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跳回蓝色背景的Perform Mok Management界面，这次选择第一个「Reboot」&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/06/6nPMS1.md.jpg&quot; alt=&quot;6nPMS1.md.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;正常情况下重启之后NVIDIA显卡驱动就成功安装并加载了，可以在终端里输入以下指令验证：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nvidia-smi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/06/6nPh60.md.png&quot; alt=&quot;6nPh60.md.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果可以成功启动Ubuntu，进入图形界面，输入&lt;code&gt;nvidia-smi&lt;/code&gt;却提示错误信息，可能是因为没有Disabale掉Secure Boot，可以在终端输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo mokutil --disable-validation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后重新启动，在蓝色界面按下任意键，在出现的菜单中，选择第二项改变Secure Boot状态，Disable之，然后boot即可。&lt;/p&gt;
&lt;p&gt;如果之后想重新Enable Secure Boot，只需在终端输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo mokutil --enable-validation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;reboot并重复上述操作，把Secure Boot State改为Enable即可。&lt;/p&gt;
&lt;p&gt;回到「设置」-&amp;gt; 「关于」，可以看到，我们的「图形」项已经显示正确了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/06/6nPbtJ.md.png&quot; alt=&quot;6nPbtJ.md.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;附上实时监测CPU/GPU信息的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU：使用htop工具。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install htop
$ htop
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GPU：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ watch -n 1 nvidia-smi
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;安装与配置Python&lt;/h3&gt;
&lt;p&gt;Ubuntu自带的是Python 3.x ，但某些情况下我们可能还需要使用Python 2.x ，可自行安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt install python
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是默认情况下要使用Python 2.x就必须输入&lt;code&gt;python&lt;/code&gt;，要使用Python 3.x就必须输入&lt;code&gt;python3&lt;/code&gt;，我们可以通过以下方法更换Python默认版本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设置python版本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100
sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换python版本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo update-alternatives --config python
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照提示输入编号即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;安装与配置Git&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;apt install git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全局初始化用户名和邮箱：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global user.name &quot;你的用户名&quot;
git config --global user.email &quot;你的邮箱&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用以下命令确认是否输入正确：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --list 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入以下命令开始进行Git与Github的绑定操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa -C &quot;你的邮箱&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在网页版Github「Settings」-&amp;gt;「SSH and GPG keys」中New一个SSH key，然后在&lt;code&gt;~\.ssh&lt;/code&gt;目录下找到&lt;code&gt;id_rsa.pub&lt;/code&gt;，复制里面的文本到刚才New SSH key界面的输入框中，点击「Add SSH key」完成绑定。&lt;/p&gt;
&lt;p&gt;在终端中输入以下指令验证是否绑定成功：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh -T git@github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果返回类似如下信息，即为绑定成功：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hi vonbrank! You&apos;ve successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Software&lt;/h2&gt;
&lt;h3&gt;安装与配置Clash&lt;/h3&gt;
&lt;p&gt;clash是在Windows/MacOS/Linux等多平台使用的代理工具，Windows下的clash可以开箱即用，Linux下需要手动配置，流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载clash-Linux&lt;a href=&quot;https://github.com/Dreamacro/clash/releases&quot;&gt;安装包&lt;/a&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/03/07/6KrJsg.md.png&quot; alt=&quot;6KrJsg.md.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在你喜欢的位置创建一个目录，将安装包放进去，可以修改成一个易于识别的名字，如&lt;code&gt;clash.gz&lt;/code&gt;，打开终端输入以下指令解压：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;gunzip clash.gz&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
+ 给予文件执行权限：

```bash
chmod +x clash
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;启动文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;./clash&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
+ 首次启动时clash会在`~/.config/clash`下自动生成两个文件：Config.yaml 和Country.mmdb。接着关闭clash，开始配置。

+ Country.mmdb为全球IP库，可以实现各个国家的IP信息解析和地理定位，没有这个文件clash无法运行。然而自动生成的文件无法支持clash运行，此处直接提供它的[下载地址](https://wws.lanzous.com/isEePmmiwaj)。

+ 编辑Config.yaml文件，其内容为服务器节点等信息，部分服务提供商会提供.yml文件，将其后缀修改为.yaml即可。对于提供订阅链接的服务商，可用以下命令生成Config.yaml文件：

```bash
wget -O Config.yaml {clash订阅地址}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将得到的Config.yaml 和Country.mmdb文件复制到&lt;code&gt;~/.config/clash&lt;/code&gt;目录下替换即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再次启动clash:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;./clash&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
+ 接着在「设置」-&amp;gt;「网络」-&amp;gt;「网络代理」,选择「手动」
将HTTP代理设为: `127.0.0.1:7890`
将Socks主机设为: `127.0.0.1:7891`

![6KsXB4.md.png](https://s3.ax1x.com/2021/03/07/6KsXB4.md.png)

+ 打开浏览器，访问 [http://clash.razord.top](http://clash.razord.top) 进行节点选择等操作。
+ 到此为止clash就配置完成了，你可以通过访问 [https://www.google.com/](https://www.google.com/) 来检验是否配置成功



然而我们目前只能让clash代理浏览器，终端内的`git`，`curl`，`wget`等指令仍然不走clash代理，因此用Git来push代码或用wget来下载海外服务器上的文件仍然很慢，我们可以用 **proxychains4** 来无脑设置代理。

+ 安装proxychains4：

```bash
sudo apt install proxychains4
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;配置代理信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;sudo nano /etc/proxychains4.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
+ 在最后一行加上clash的代理端口：

```bash
socks5 127.0.0.1 7891
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后就可以用proxychains4来代理&lt;code&gt;git&lt;/code&gt;，&lt;code&gt;curl&lt;/code&gt;，&lt;code&gt;wget&lt;/code&gt;等指令了，使用时只需要在这些指令前加上&lt;code&gt;proxychains4&lt;/code&gt;即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;proxychains4 git clone {远程仓库地址}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;安装Typora&lt;/h3&gt;
&lt;h3&gt;Hexo多终端工作&lt;/h3&gt;
&lt;hr /&gt;
&lt;h2&gt;Tips&lt;/h2&gt;
&lt;h3&gt;由Linux直接进入bios&lt;/h3&gt;
&lt;p&gt;很多时候我们希望重启之后直接进入bios，而不是疯狂按快捷键，可执行以下指令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo systemctl reboot --firmware-setup
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Issues&lt;/h2&gt;
&lt;h3&gt;Windows、Ubuntu 双系统时间不统一（引用）&lt;/h3&gt;
&lt;p&gt;由于Windows 与类 Unix 系统(Unix/Linux/Mac)看待系统硬件时间的方式是不一样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Windows 把计算机硬件时间当作本地时间(local time)，所以在 Windows 系统中显示的时间跟 BIOS 中显示的时间是一样的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类 Unix 系统把计算机硬件时间当作 UTC， 所以系统启动后会在该时间的基础上，加上电脑设置的时区数(比中国就加8)，因此 Ubuntu 中显示的时间总是比 Windows 中显示的时间快 8 小时。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当你在 Ubuntu 中把系统显示的时间设置正确后，计算机硬件时间就变成了在这个时间上减去 8 小时，所以当你切换成 Windows 系统后慢了8小时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt; ：在 Ubuntu 中把计算机硬件的时间改成系统显示时间，即禁用 Ubuntu 中的 UTC。在终端输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;timedatectl set-local-rtc 1 --adjust-system-clock
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;请参阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://juejin.cn/post/6844904149822210056#heading-0&lt;/li&gt;
&lt;li&gt;https://blog.csdn.net/sinat_37781304/article/details/82729029#t27&lt;/li&gt;
&lt;li&gt;https://www.cnblogs.com/sueyyyy/p/12424178.html&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>如何将Ubuntu安装到U盘-UEFI引导</title><link>https://blog.vonbrank.com/posts/ubuntu-usb-install-uefi/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/ubuntu-usb-install-uefi/</guid><pubDate>Sun, 28 Feb 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;现代Ubuntu操作系统的安装以&lt;a href=&quot;https://yukkohzq.github.io/&quot;&gt;Yukko&lt;/a&gt;的“虚拟机可以最大程度地减少对硬件的干扰”为嚆矢。滥觞于基于启动盘的Ubuntu物理机安装方案正失去它们的借鉴意义。但面对看似无垠的未来天空，我想循全新的利用VMware虚拟机将Ubuntu安装至USB存储设备的思路，好过过早地振翮.&lt;/p&gt;
&lt;p&gt;本教程主要讨论将Ubuntu装入U盘以提升便携性的方法，由&lt;a href=&quot;https://yukkohzq.github.io/&quot;&gt;Yukko&lt;/a&gt;提出，收录于此以备用。&lt;/p&gt;
&lt;h2&gt;先决条件&lt;/h2&gt;
&lt;h3&gt;确认你的操作系统是UEFI引导&lt;/h3&gt;
&lt;p&gt;传统MBR与UEFI的区别在此不再赘述，详细内容可以自行Google/Baidu.&lt;/p&gt;
&lt;p&gt;确认自己的系统是MBR或UEFI启动的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;键盘按下&lt;code&gt;Win+R&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在弹出的窗口中输入&lt;code&gt;msinfo32&lt;/code&gt;，按回车键确认&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在弹出的窗口中确认以下信息
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6Czly6.md.png&quot; alt=&quot;6Czly6.md.png&quot; /&gt;
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CzJTe.png&quot; alt=&quot;6CzJTe.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果显示如图所示的信息，请点击右上角的×关闭此页面；若不然，恭喜你，符合执行本教程的最低要求.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;准备一块空U盘&lt;/h3&gt;
&lt;p&gt;其实不止U盘，其他空的存储器也行，如硬盘，SD卡等。本教程将使用一块 &lt;a href=&quot;https://item.jd.com/100008461371.html#crumb-wrap&quot;&gt;SanDisk-CZ410-32GB-USB3.0&lt;/a&gt; U盘&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;下载DiskGenius并打开&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在右侧找到你的U盘，右键单击之&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果右键弹出菜单中“转换分区表类型为GUID格式”为可选状态，请先通过此选项将你的分区表类型转换为GUID；如果不可选，可忽略此步骤
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CT49U.md.png&quot; alt=&quot;6CT49U.md.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在右键菜单中选择”删除所有分区“，并点击界面左上角的“保存更改”。在执行此步骤前，请务必确认你选择的是所要用于安装Ubuntu的U盘
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CTzge.md.png&quot; alt=&quot;6CTzge.md.png&quot; /&gt;
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CTfhT.md.png&quot; alt=&quot;6CTfhT.md.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;配置VMware虚拟机&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;a href=&quot;https://www.vmware.com/&quot;&gt;VMware Workstation&lt;/a&gt;，详细过程在此不再赘述&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载&lt;a href=&quot;https://ubuntu.com/&quot;&gt;Ubuntu&lt;/a&gt;镜像，本教程将使用&lt;a href=&quot;https://mirror.xtom.com.hk/ubuntu-releases/20.04.2.0/ubuntu-20.04.2.0-desktop-amd64.iso&quot;&gt;ubuntu-20.04.2.0-desktop-amd64.iso&lt;/a&gt;进行安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开VMware，选择新建虚拟机，仅需在以下几步中进行特别设置，其他步骤保持默认值即可。虚拟机位置可自行设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CTON6.png&quot; alt=&quot;6CTON6.md.png&quot; /&gt;
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CT7u9.png&quot; alt=&quot;6CT7u9.png&quot; /&gt;
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CTbH1.png&quot; alt=&quot;6CTbH1.md.png&quot; /&gt;
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CTLAx.png&quot; alt=&quot;6CTLAx.md.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建完成后，点击“编辑虚拟机设置”，对以下几项进行特别设置
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CTv9O.md.png&quot; alt=&quot;6CTv9O.md.png&quot; /&gt;
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CTojJ.md.png&quot; alt=&quot;6CTojJ.md.png&quot; /&gt;
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CTx3D.md.png&quot; alt=&quot;6CTx3D.md.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置完成后点击开启虚拟机&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;在虚拟机内安装Ubuntu&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;（以下内容为引用）选择第一个&quot;Ubuntu&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CTg7q.md.png&quot; alt=&quot;6CTg7q.md.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CTcBn.md.png&quot; alt=&quot;6CTcBn.md.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在VMware顶部菜单中选择“可移动设备”，选择你的U盘，并点击“连接”，弹出的窗口中全选“确定”即可
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CHpGT.md.png&quot; alt=&quot;6CHpGT.md.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在这个界面右侧往下拉，会有中文可供选择。然后选择“安装Ubuntu”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CTWNV.md.png&quot; alt=&quot;6CTWNV.md.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;键盘布局看个人喜好&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CT53F.md.png&quot; alt=&quot;6CT53F.md.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量不要联网，也不要更新，否则边装边下载很慢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CTIc4.md.png&quot; alt=&quot;6CTIc4.md.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接下来的步骤非常重要。在此界面选择“其他选项”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CTHBR.md.png&quot; alt=&quot;6CTHBR.md.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在这里可以看见一个空分区，那就是我们的U盘&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CHhy4.md.png&quot; alt=&quot;6CHhy4.md.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们可以看见32GB的U盘在此显示为30765MB的空间，点空闲盘符，点击+进行分区&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CbpTI.md.png&quot; alt=&quot;6CbpTI.md.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;分区如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EFI：这个就是实现你双系统的原因了，这个就是用启动 ubuntu 的目录，里面会有系统的引导，这个文件其实只有几十兆，但是我们建议将其划分为 200M ,格式为EFI
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6Cbiff.png&quot; alt=&quot;6Cbiff.md.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;swap： &lt;strong&gt;（如果你的内存RAM大于4GB，请不要划分swap分区）&lt;/strong&gt; 这个是 Linux 也就是 Ubuntu 的交换区目录，这个一般的大小为内存的 2 倍左右，主要是用来在电脑内存不足的情况下，系统会调用这片区域，来运行程序，我们可以将其分为 4GB。 为创建这片空间，我们只需要点击+，将文件格式选择为“交换空间”（或者&quot;swap&quot;）.
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CbVXQ.png&quot; alt=&quot;6CbVXQ.md.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;/：这是 Linux 也就是 Ubuntu 的根目录就一个反斜杠表示，相当于windows的C盘，我们将其分为 10G，文件格式为 Ext4（根据你的磁盘空间调整，可以大一点，如果你拥有较大容量的U盘，可将其设为30-40GB，毕竟Ubuntu装软件都是默认装在根目录的）
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6Cb1pT.png&quot; alt=&quot;6Cb1pT.md.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;/home： &lt;strong&gt;（可以不分）&lt;/strong&gt; 这是 Ubuntu的其他盘，相当于Windows的其他盘，所以为了让我们自己的目录大一点，剩下的全分给它，文件格式为 Ext4
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6Cb8cF.png&quot; alt=&quot;6Cb8cF.md.png&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接下来这步非常重要。检查200MB的EFI分区前的编号是多少，我的是/dev/sdb1，不同机器可能略有不同。在这个界面下方，选择安装启动下拉菜单，然后在安装启动的下拉菜单中找到EFI分区的对应编号，并选中它，选择“继续”
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6Cb49f.png&quot; alt=&quot;6Cb49f.md.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;余下步骤一路默认即可。设置地区，键盘布局，系统用户等设定纯看个人口味&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CbONq.md.png&quot; alt=&quot;6CbONq.md.png&quot; /&gt;
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CquKe.md.png&quot; alt=&quot;6CquKe.md.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你不幸连接了互联网，在skip按钮亮起时可以点skip跳过下载某些组件，这不会影响安装，但可以加快进度。你可以在系统安装完成后再下载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CLreH.md.png&quot; alt=&quot;6CLreH.md.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后系统安装完成，会提示你重启，在虚拟机里通常重启不成功，可以直接弹出U盘。
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6COMtI.md.png&quot; alt=&quot;6COMtI.md.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭物理机，插上U盘，并重新开机。进入启动菜单并选择带有Ubuntu的选项，不同品牌的主板或笔记本进入启动菜单的快捷键略有不同，我这里的快捷键是F12；或进入bios将U盘设为第一启动顺序，直接启进Ubuntu。
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CvHDU.md.jpg&quot; alt=&quot;6CvHDU.md.jpg&quot; /&gt;
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CvbbF.md.jpg&quot; alt=&quot;6CvbbF.md.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你成功进入了Ubuntu系统登录菜单，那么恭喜你，成功将Ubuntu塞进了你的便携式独立存储器，现在你可以带着它随意行动了！！！
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CxA5d.md.png&quot; alt=&quot;6CxA5d.md.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;后续步骤&lt;/h2&gt;
&lt;p&gt;希望这篇教程对你有帮助，你也可以将其推荐给你希望把Ubuntu装进U盘的朋友。如果安装过程中出现了无法解决的问题，删除虚拟机，格式化U盘，并重新操作一遍即可。
&lt;img src=&quot;https://s3.ax1x.com/2021/02/28/6CxVPA.md.png&quot; alt=&quot;6CxVPA.md.png&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;请参阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://www.cnblogs.com/masbay/p/10745170.html&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>C语言答疑-04</title><link>https://blog.vonbrank.com/posts/hit-cs31106-explanation-04/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/hit-cs31106-explanation-04/</guid><description>C语言答疑-04 | Audience-120L0213 | By Von Brank</description><pubDate>Mon, 23 Nov 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;C 语言答疑-04&lt;/h1&gt;
&lt;p&gt;​ By Von Brank | 2020/11/23&lt;/p&gt;
&lt;h2&gt;目录&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;网站推荐&lt;/li&gt;
&lt;li&gt;近期知识梳理&lt;/li&gt;
&lt;li&gt;几道题&lt;/li&gt;
&lt;li&gt;答疑&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/DJSO81&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/23/DJSO81.md.jpg&quot; alt=&quot;DJSO81.md.jpg&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;网站推荐&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;算法可视化：visualgo.net/zh&lt;/li&gt;
&lt;li&gt;算法学习：oi-wiki.org&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;知识点梳理&lt;/h2&gt;
&lt;h3&gt;指针&lt;/h3&gt;
&lt;h4&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;：取地址的运算&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;scanf(&quot;%d&quot;, &amp;amp;n);&lt;/code&gt;里的&lt;code&gt;&amp;amp;&lt;/code&gt;是什么&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;%p&lt;/code&gt;用来输出地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int i = 0;
printf(&quot;0x%x\n&quot;, &amp;amp;i);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;int i = 0;
int p;
int p = (int)&amp;amp;i;
printf(&quot;0x%x\n&quot;, p);
printf(&quot;%p\n&quot;, &amp;amp;i);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;32 位与 64 位的区别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int i = 0;
printf(&quot;%lu\n&quot;, sizeof(int));
printf(&quot;%lu\n&quot;, sizeof(&amp;amp;i));
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;可以用于获得变量的地址，它的操作数必须是变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能对没有地址的东西取地址&lt;/p&gt;
&lt;p&gt;以下写法是正确的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int i = 0;
printf(&quot;%p\n&quot;, &amp;amp;i);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下写法都是错误的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a = 0, b = 1;
printf(&quot;%p\n&quot;, &amp;amp;(a++));
printf(&quot;%p\n&quot;, &amp;amp;(++a));
printf(&quot;%p\n&quot;, &amp;amp;(a + b));
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;些别的&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;相邻变量的地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a = 0, b = 1;
printf(&quot;%p\n%p\n&quot;, &amp;amp;a, &amp;amp;b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C 语言的变量存储在“栈”中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sizeof&lt;/code&gt;一个&lt;code&gt;&amp;amp;&lt;/code&gt;的结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int i = 0;
printf(&quot;%d\n&quot;, sizeof(&amp;amp;a));
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组的地址，首个数组单元的地址，相邻元素的地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[100];
printf(&quot;%p\n&quot;, a);
printf(&quot;%p\n&quot;, &amp;amp;a[0]);
printf(&quot;%p\n&quot;, &amp;amp;a[1]);
printf(&quot;%p\n&quot;, &amp;amp;a[2]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;指针变量&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;scanf(&quot;%d&quot;, &amp;amp;n)&lt;/code&gt;是什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scanf&lt;/code&gt;函数需要传入一个变量的地址，便于赋值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scanf&lt;/code&gt;函数需要对控制串进行处理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scanf&lt;/code&gt;函数的内部实现也仅仅是基于 C 语言的基本语法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指针变量的定义&lt;/p&gt;
&lt;p&gt;以下代码将&lt;code&gt;i&lt;/code&gt;的地址赋给&lt;code&gt;p&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int i;
int *p = &amp;amp;i;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下两种写法意思相同&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int *p;
int* p;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下写法定义了一个指针变量&lt;code&gt;p&lt;/code&gt;和一个&lt;code&gt;int&lt;/code&gt;类型的变量&lt;code&gt;q&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int *p, q;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下写法定义了两个指针变量&lt;code&gt;p&lt;/code&gt;和&lt;code&gt;q&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int *p, *q;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问地址上的变量*&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int i = 10;
int *p = &amp;amp;i;
printf(&quot;%d\n&quot;, i);
printf(&quot;%d\n&quot;, *p);
*p = 20;
printf(&quot;%d\n&quot;, i);
printf(&quot;%d\n&quot;, *p);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指针作为函数参数传入&lt;/p&gt;
&lt;p&gt;比较函数&lt;code&gt;f&lt;/code&gt;和&lt;code&gt;g&lt;/code&gt;的输出差异&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio&amp;gt;
void f(int *p)
{
    printf(&quot;%d\n&quot;, *p);
    printf(&quot;%p\n&quot;, p);
}
void g(int k)
{
    printf(&quot;%d\n&quot;, k);
    printf(&quot;%p\n&quot;, &amp;amp;k);
}
int main()
{
    int i = 10;
    f(&amp;amp;i);
    g(i);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;与&lt;code&gt;*&lt;/code&gt;互为反作用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int i = 10;
int *p = &amp;amp;i;
printf(&quot;%d\n&quot;, i);
printf(&quot;%d\n&quot;, *&amp;amp;i);
printf(&quot;%p\n&quot;, p);
printf(&quot;%p\n&quot;, &amp;amp;*p);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;scanf(&quot;%d&quot;, i);&lt;/code&gt;出错的原因&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;指针与数组&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;以下两段代码效果相同&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

void f(int a[], int start, int end)
{
    for(int i=start; i&amp;lt;=end; i++)
    {
        printf(&quot;%d &quot;, a[i]);
    }
}

int main()
{
    int start, end;
    int a[100] = {0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
    start = 1;
    end = 10;
    f(a, start, end);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

void f(int *a, int start, int end)
{
    for(int i=start; i&amp;lt;=end; i++)
    {
        printf(&quot;%d &quot;, a[i]);
    }
}

int main()
{
    int start, end;
    int a[100] = {0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
    start = 1;
    end = 10;
    f(a, start, end);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以下函数&lt;strong&gt;原型&lt;/strong&gt;等价&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int sum(int *p, int i);
int sum(int *, int i);
int sum(int a[], int i);
int sum(int [], int i);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组变量本身就是特殊的指针&lt;/p&gt;
&lt;p&gt;以下操作无需取地址符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[100];
int *p = a;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组的单元表达的是变量，需要取地址，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(a == &amp;amp;a[0])
{
    printf(&quot;YES!!!&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;[]&lt;/code&gt;运算符也可以用于指针，如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a = 10;
int *p = &amp;amp;a;
printf(&quot;%d\n&quot;, *p);
printf(&quot;%d\n&quot;, p[0]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt;也可以用于数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[100] = {0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
a[0] = 123;
printf(&quot;%d\n&quot;, a[0]);
printf(&quot;%d\n&quot;, *a);
*a = 456;
printf(&quot;%d\n&quot;, a[0]);
printf(&quot;%d\n&quot;, *a);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组变量是常量（const），即&lt;code&gt;int a[]&lt;/code&gt;等价于&lt;code&gt;int * const a&lt;/code&gt;，因此：&lt;/p&gt;
&lt;p&gt;以下写法是错误的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a = {0, 1, 2, 3};
int b[] = a;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下写法是正确的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a = {0, 1, 2, 3};
int *p = a;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;const 指针&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;int * const p = &amp;amp;i;&lt;/code&gt;的含义&lt;/p&gt;
&lt;p&gt;表示指针变量&lt;code&gt;p&lt;/code&gt;只能指向&lt;code&gt;i&lt;/code&gt;的地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int i, j;
int * const p = &amp;amp;i;
*p = 123; //可以
p = &amp;amp;j; //不可以
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;const int *p = &amp;amp;i&lt;/code&gt;的含义&lt;/p&gt;
&lt;p&gt;表示不允许通过&lt;code&gt;*p&lt;/code&gt;来修改变量的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int i, j;
const int *p = &amp;amp;i;
*p = 123; //不可以
i = 456; //可以
p = &amp;amp;j; //可以
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分辨以下写法的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const int* p = &amp;amp;i;&lt;/code&gt;表示不能通过&lt;code&gt;*p&lt;/code&gt;来修改变量的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int const* p = &amp;amp;i;&lt;/code&gt;表示不能通过&lt;code&gt;*p&lt;/code&gt;来修改变量的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int *const p = &amp;amp;i;&lt;/code&gt;表示不能改变指针变量&lt;code&gt;p&lt;/code&gt;指向的变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以用于防止函数修改指针所指向变量的值或数组的值，保证安全性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
void f(const int* a)
{
    int b = *a; //可以
    *a = 123; //不可以
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常量数组&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;类型的数组只能使用集成初始化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const int a[] = {0, 1, 2, 3, 4, 5};
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;指针的运算&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于一个指针变量&lt;code&gt;p&lt;/code&gt;，&lt;code&gt;p + 1&lt;/code&gt;的含义不是让指针的值&lt;code&gt;+1&lt;/code&gt;，而是加上&lt;code&gt;sizeof(&amp;lt;指针变量指向的变量类型&amp;gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char s[] = &quot;hello_world&quot;;
char *p = s;
printf(&quot;%p\n&quot;, p);
printf(&quot;%p\n&quot;, p + 1);
int a[] = {0, 1, 2, 3, 4, 5, 6};
int *q = a;
printf(&quot;%p\n&quot;, q);
printf(&quot;%p\n&quot;, q + 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;char s[] = &quot;hello_world&quot;;
char *p = s;
printf(&quot;%c\n&quot;, *p);
printf(&quot;%c\n&quot;, *(p + 1));
int a[] = {0, 1, 2, 3, 4, 5, 6};
int *q = a;
printf(&quot;%d\n&quot;, *q);
printf(&quot;%d\n&quot;, *(q + 1));
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;int a[105];
for(int i=1; i&amp;lt;=100; i++)
{
    scanf(&quot;%d&quot;, a + i);
}
for(int i=1; i&amp;lt;=100; i++)
{
    printf(&quot;%d&quot;, a + i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;a[i]&lt;/code&gt;和&lt;code&gt;*(a + i)&lt;/code&gt;完全等价&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指针变量可以进行加减，但指针的乘除没有意义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[100];
int *p1 = a;
int *p2 = &amp;amp;a[7];
printf(&quot;p1 = %p\n&quot;, p1);
printf(&quot;p2 = %p\n&quot;, p2);
printf(&quot;p2 - p1 = %d\n&quot;, p2 - p1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;*p++&lt;/code&gt;表示取出&lt;code&gt;p&lt;/code&gt;指向的那个数据，然后将&lt;code&gt;p&lt;/code&gt;移动到下一个位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[] = {0, 1, 2, 3, 4, 5, 6, 7, -1};
int *p = a;
while(*p != -1)
{
    printf(&quot;%d &quot;, *p++);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;指针使用的其他注意事项&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所有指针的大小都是一样的，32 位程序的指针是 4 字节，64 位是 8 字节&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了防止使用出错，指向不同数据类型的指针不能相互赋值，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int *p = &amp;amp;n;
char *q = &amp;amp;c;
p = q;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void*&lt;/code&gt;表示指向未知类型的指针，编译器不知道它指向的是什么数据类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int *p1 = &amp;amp;n;
char *p2 = &amp;amp;c;
void *p3;
p3 = p1;
p3 = p2;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指针也可以做强制类型转换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int *p = &amp;amp;n;
char *q = &amp;amp;c;
p = (void*)q;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指针究竟有什么用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;便于向函数中传入大量数据，如数组作为参数传入&lt;/li&gt;
&lt;li&gt;将数组传入函数后对数组作操作&lt;/li&gt;
&lt;li&gt;函数需要返回一个数组&lt;/li&gt;
&lt;li&gt;用函数修改外部变量的值&lt;/li&gt;
&lt;li&gt;动态内存分配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;几道题&lt;/h2&gt;
&lt;p&gt;关于指针的题没几道，关于链表的倒是有不少（bushi&lt;/p&gt;
</content:encoded></item><item><title>C语言答疑-03</title><link>https://blog.vonbrank.com/posts/hit-cs31106-explanation-03/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/hit-cs31106-explanation-03/</guid><description>C语言答疑-03 | Audience-120L0214 | By Von Brank</description><pubDate>Thu, 12 Nov 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;C 语言答疑-03&lt;/h1&gt;
&lt;p&gt;​ By Von Brank | 2020/11/12&lt;/p&gt;
&lt;h2&gt;目录&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;网站推荐&lt;/li&gt;
&lt;li&gt;近期知识梳理&lt;/li&gt;
&lt;li&gt;几道题&lt;/li&gt;
&lt;li&gt;答疑&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;lt;img src=&quot;https://s1.ax1x.com/2018/04/04/C9AddU.gif&quot; alt=&quot;funny&quot; style=&quot;zoom: 150%;&quot; /&amp;gt;&lt;/p&gt;
&lt;h2&gt;网站推荐&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;算法可视化：visualgo.net/zh&lt;/li&gt;
&lt;li&gt;算法学习：oi-wiki.org&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;知识点梳理&lt;/h2&gt;
&lt;h3&gt;字符串简介&lt;/h3&gt;
&lt;h4&gt;ASCII 码表&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;tool.ip138.com/ascii_code&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;char&lt;/code&gt;既是整数也是字符，取决于你怎么看它&lt;/p&gt;
&lt;p&gt;以下两个&lt;code&gt;printf&lt;/code&gt;语句输出都是&lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;printf(&quot;%c\n&quot;, 49);
printf(&quot;%d\n&quot;, 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下两个&lt;code&gt;printf&lt;/code&gt;语句输出都是&lt;code&gt;49&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;printf(&quot;%c\n&quot;, &apos;1&apos;);
printf(&quot;%d\n&quot;, 49);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以&quot;&lt;code&gt;char&lt;/code&gt;的方式&quot;看待&lt;code&gt;49&lt;/code&gt;这个&lt;strong&gt;整数&lt;/strong&gt;，它是字符&lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以&quot;&lt;code&gt;int&lt;/code&gt;的方式&quot;看待&lt;code&gt;1&lt;/code&gt;这个&lt;strong&gt;字符&lt;/strong&gt;，他是整数&lt;code&gt;49&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&apos;\n&apos;&lt;/code&gt;，&lt;code&gt;&apos;\t&apos;&lt;/code&gt;与空格&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;字符串的定义与初始化&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;char s[100];

char str[100] = &quot;Hello World!!!&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;字符串的输入与输出&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%s&lt;/code&gt;会将当前位置与下一个空格或回车之间的字符串赋值给字符串&lt;code&gt;s&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;char s[100];
scanf(&quot;%s&quot;, s);
printf(&quot;%s&quot;, s);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;上述写法中，&lt;code&gt;scanf&lt;/code&gt;会将输入字符串的首位赋值给&lt;code&gt;s[0]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;每个字符串都以&lt;code&gt;&apos;\0&apos;&lt;/code&gt;结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;常用字符串函数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;需要&lt;code&gt;#include &amp;lt;string.h&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getchar()&lt;/code&gt;单字符输入，&lt;code&gt;putchar()&lt;/code&gt;单字符输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strlen()&lt;/code&gt;计算字符串长度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strcmp()&lt;/code&gt;比较两个字符串是否相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strcpy()&lt;/code&gt;将一个字符串赋值给另一个字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strcat()&lt;/code&gt;将一个字符串拷贝到另一个字符串的后面，连成一个长的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数组补充&lt;/h3&gt;
&lt;h4&gt;将变量作为数组定义的元素数量，并作集成初始化的注意事项&lt;/h4&gt;
&lt;p&gt;以下定义方式在 C 语言中可以通过编译&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#define maxn 100
int main()
{
    int a[maxn] = {0, 1, 2, 3,};
    return 0;
}

------------------------------

#include &amp;lt;stdio.h&amp;gt;
int main()
{
    int a[100] = {0, 1, 2, 3,};
    return 0;
}

------------------------------

#include &amp;lt;stdio.h&amp;gt;
int main()
{
    const int maxn = 100;
    int a[maxn] = {0, 1, 2, 3,};
    return 0;
}

------------------------------

#include &amp;lt;stdio.h&amp;gt;
int main()
{
    int maxn = 100;
    int a[maxn] = {0, 1, 2, 3,};
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下定义方式在 C 语言中无法通过编译，但是在 C++中可以&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
const int maxn = 100;
int main()
{
    int a[100] = {0, 1, 2, 3,};
    return 0;
}

-------------------------------

#include &amp;lt;stdio.h&amp;gt;
int main()
{
    const int maxn = 100;
    int a[100] = {0, 1, 2, 3,};
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;初识动态规划（DP）&lt;/h3&gt;
&lt;h4&gt;记忆化搜索&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;洛谷 P1464 Function&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一个递归函数$w(a,b,c)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果$a \le 0\quad or\quad b \le 0 \quad or\quad c \le 0$就返回值$1$&lt;/li&gt;
&lt;li&gt;如果$a&amp;gt;20\quad or\quad b&amp;gt;20\quad or\quad c&amp;gt;20\quad$就返回$w(20,20,20)$&lt;/li&gt;
&lt;li&gt;如果$a&amp;lt;b$并且$b&amp;lt;c $就返回$w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c)$&lt;/li&gt;
&lt;li&gt;其它的情况就返回$w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是个简单的递归函数，但实现起来可能会有些问题。当$a,b,c$均为$15$时，调用的次数将非常的多。&lt;strong&gt;你要想个办法才行&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;对于一些特殊情况，比如 $w(30,-1,0)$既满足条件$1$又满足条件$2$，这种时候我们就按最上面的条件来算，所以答案为$1$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不使用数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int w(int a, int b, int c)
{
	if(a &amp;lt;= 0 || b &amp;lt;= 0 || c &amp;lt;= 0) return 1;
	else if(a &amp;gt; 20 || b &amp;gt; 20 || c &amp;gt; 20) return w(20, 20, 20);
	else if(a &amp;lt; b &amp;amp;&amp;amp; b &amp;lt; c) return w(a, b, c-1) + w(a, b -1, c - 1) - w(a, b, c - 1);
	else return w(a-1, b, c)+w(a-1, b-1, c)+w(a-1, b, c-1)-w(a-1, b-1, c-1);
}
int main()
{
	int a, b, c;
	while(1)
	{
		scanf(&quot;%d %d %d&quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
		if(a == -1 &amp;amp;&amp;amp; b == -1 &amp;amp;&amp;amp; c == -1)
		{
			break;
		}
		printf(&quot;w(%d, %d, %d) = %d\n&quot;, a, b, c, w(a, b, c));
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/03/BykPLd.png&quot; alt=&quot;BykPLd.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用数组（记忆化）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int vis[25][25][25];
void init()
{
    for(int i=0; i&amp;lt;=20; i++)
    {
        for(int j=0; j&amp;lt;=20; j++)
        {
			for(int k=0; k&amp;lt;=20; k++)
            {
                vis[i][j][k] = -1;
            }
        }
    }
}
int w(int a, int b, int c)
{
    if(a &amp;lt;= 0 || b &amp;lt;= 0 || c &amp;lt;= 0)
		a = b = c = 0;
    if(a &amp;gt; 20 || b &amp;gt; 20 || c &amp;gt; 20)
		a = b = c = 20;
    if(vis[a][b][c] != -1) return vis[a][b][c];
	else if(a &amp;lt;= 0 || b &amp;lt;= 0 || c &amp;lt;= 0) return vis[0][0][0] = 1;
	else if(a &amp;lt; b &amp;amp;&amp;amp; b &amp;lt; c) return vis[a][b][c] = w(a, b, c - 1) + w(a, b -1, c - 1) - w(a, b, c - 1);
	else return vis[a][b][c] = w(a - 1, b, c) + w(a - 1,  b- 1, c) + w(a - 1, b, c - 1) - w(a - 1, b - 1, c - 1);
}
int main()
{
	int a, b, c;
	while(1)
	{
		init(); //计算每组数据前要初始化数组
		scanf(&quot;%d %d %d&quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
		if(a == -1 &amp;amp;&amp;amp; b == -1 &amp;amp;&amp;amp; c == -1)
		{
			break;
		}
		printf(&quot;w(%d, %d, %d) = %d\n&quot;, a, b, c, w(a, b, c));
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;strong&gt;AC!!! :)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;最长上升子序列&lt;/h4&gt;
&lt;p&gt;给出一个序列$a_1, a_2, a_3, ... a_n$，找出其中最长的子序列$a_{t_1}, a_{t_2}, a_{t_3}, ...a_{t_m} (1 \leq t_i \leq n)$，满足$a_{t_i} &amp;lt; a_{t_{i+1}}$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[MAXN], d[MAXN];
int dp() {
  d[1] = 1;
  int ans = 1;
  for (int i = 2; i &amp;lt;= n; i++) {
    for (int j = 1; j &amp;lt; i; j++)
      if (a[j] &amp;lt; a[i]) {
        d[i] = max(d[i], d[j] + 1);
        ans = max(ans, d[i]);
      }
  }
  return ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;C 语言庶事&lt;/h3&gt;
&lt;h4&gt;整数是怎么表达的——原码，反码，补码&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;这些规定没什么别的目的，只是为了方便计算&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;各数据类型的表达范围与自然溢出&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;类型有 32 位，表达范围为$[-2^{31}, 2^{31}-1]$&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unsigned int&lt;/code&gt;数据范围是$[0, 2^{32}-1]$&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;各数据类型的输入输出&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;整数类型的输入输出&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unsigned int&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%lld&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;long long&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%llu&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unsigned long long&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;二进制，八进制，十六进制的整数（引用自：c.biancheng.net/view/1759.html）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;二进制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二进制数以&lt;code&gt;0b&lt;/code&gt;或&lt;code&gt;OB&lt;/code&gt;开头，只能包含&lt;code&gt;0&lt;/code&gt;和&lt;code&gt;1&lt;/code&gt;两个数&lt;/li&gt;
&lt;li&gt;标准 C 语言不支持该二进制写法，只有某些编译器支持&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;//合法的二进制
int a = 0b101;  //换算成十进制为 5
int b = -0b110010;  //换算成十进制为 -50
int c = 0B100001;  //换算成十进制为 33
//非法的二进制
int m = 101010;  //无前缀 0B，相当于十进制
int n = 0B410;  //4不是有效的二进制数字
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;八进制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用时以&lt;code&gt;0&lt;/code&gt;开头，只能包含&lt;code&gt;0&lt;/code&gt;~&lt;code&gt;7&lt;/code&gt;这八个数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;//合法的八进制数
int a = 015;  //换算成十进制为 13
int b = -0101;  //换算成十进制为 -65
int c = 0177777;  //换算成十进制为 65535
//非法的八进制
int m = 256;  //无前缀 0，相当于十进制
int n = 03A2;  //A不是有效的八进制数字
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;十六进制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以&lt;code&gt;0x&lt;/code&gt;或&lt;code&gt;0X&lt;/code&gt;开头&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;//合法的十六进制
int a = 0X2A;  //换算成十进制为 42
int b = -0XA0;  //换算成十进制为 -160
int c = 0xffff;  //换算成十进制为 65535
//非法的十六进制
int m = 5A;  //没有前缀 0X，是一个无效数字
int n = 0X3H;  //H不是有效的十六进制数字
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入与输出&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;short&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;long&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;八进制&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%ho&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%o&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%lo&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;十进制&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%hd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%ld&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;十六进制&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt; %hx&lt;/code&gt; 或&lt;code&gt; %hX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%x&lt;/code&gt; 或 &lt;code&gt;%X&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%lx&lt;/code&gt; 或 &lt;code&gt;%lX&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%hx&lt;/code&gt;、&lt;code&gt;%x&lt;/code&gt; 和 &lt;code&gt;%lx&lt;/code&gt; 中的&lt;code&gt;x&lt;/code&gt;小写，表明以小写字母的形式输出十六进制数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%hX&lt;/code&gt;、&lt;code&gt;%X&lt;/code&gt; 和 &lt;code&gt;%lX&lt;/code&gt; 中的&lt;code&gt;X&lt;/code&gt;大写，表明以大写字母的形式输出十六进制数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;浮点数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;令人头疼的精度问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
    if(1.1 + 0.1 == 1.2)
        printf(&quot;YES!!!&quot;);
    else
        printf(&quot;NO!!!&quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上程序输出的是&lt;code&gt;NO&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;1.1 + 0.1&lt;/code&gt;为什么不等于&lt;code&gt;1.2&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0.1转化为二进制的结果是一个循环小数:
0.00011001100110011001100110011001100110011001100110011010
double类型在二进制下的精度是53位有效数字，超出部分四舍五入

同理将1.1转化为二进制:
1.0001100110011001100110011001100110011001100110011010

二者相加
 	0.00011001100110011001100110011001100110011001100110011010
+	1.0001100110011001100110011001100110011001100110011010
---------------------------------------------------------------
 	1.0011001100110011001100110011001100110011001100110100



将结果转化为十进制：
1.20000000000000018

将1.2转化为二进制：
1.0011001100110011001100110011001100110011001100110011

与1.1+0.1的二进制结果:
1.0011001100110011001100110011001100110011001100110100
相比较

二者不同
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方案&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
const double eps = 1e-6;
double eps(double x)
{
      return x &amp;lt; 0 ? -x : x;
}
int main()
{
	if((abs(1.1 + 0.1 - 1.2) &amp;lt; eps)
		printf(&quot;YES!!!&quot;);
	else
		printf(&quot;NO!!!&quot;);
	return 0;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;以&lt;code&gt;&quot;\&quot;&lt;/code&gt;开头的字符&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;格式控制字符串中的一类字符&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;回退一格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;转到下一个制表位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;换行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\r&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;回车&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\&quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;双引号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\&apos;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单引号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\\&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;反斜杠&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本的文件读写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;思考：如何输出&lt;code&gt;%d&lt;/code&gt;这个字符串本身&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/code&gt;是什么——头文件简介&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;头文件是扩展名为 &lt;strong&gt;.h&lt;/strong&gt; 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gcc 的编译过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分步编译：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;预处理：&lt;code&gt;gcc -E hello.c -o hello.i&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编 译： &lt;code&gt;gcc -S hello.i -o hello.s&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;汇 编：&lt;code&gt;gcc -c hello.s -o hello.o&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链 接：&lt;code&gt;gcc hello.o -o hello_elf&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-E&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;只进行预处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-S&lt;/code&gt;大写&lt;/td&gt;
&lt;td&gt;只进行预处理和编译&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-c&lt;/code&gt;小写&lt;/td&gt;
&lt;td&gt;只进行预处理、编译和汇编&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-o file&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定生成的输出文件名为&lt;code&gt;file&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件后缀&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;.c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C 语言文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;.i&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;预处理后的 C 语言文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;.s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;编译后的汇编文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;.o&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;编译后的目标文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一步编译：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc hello.c -o demo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此指令依然经过：预处理、编译、汇编、链接的过程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译预处理指令——以&lt;code&gt;#&lt;/code&gt;开头的指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在编译预处理中，编译器会将头文件中的所有内容原封不动地“抄”到&lt;code&gt;.c&lt;/code&gt;文件中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;头文件内应只包含变量与的函数声名，不应包含变量与函数的定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;s&gt;&lt;code&gt;1.h&lt;/code&gt;的编写&lt;/s&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;算术表达式，关系表达式与逻辑表达式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;算数表达式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a = a + b;
b = b + 1

a = a * +b;
a = a * -b;

a=b+=c++-d+--e/-f;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优先级：&lt;code&gt;(++i --i) &amp;gt; (* /) &amp;gt; (+ -) &amp;gt; (i++ i--) &amp;gt; (= += *= -= /= %=)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;思考：下列程序的输出值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a = 0, b = 10, c = 8, d = 1, e = 1, f = 1;
a=b+=c++-d+--e/-f;
printf(&quot;%d&quot;, a);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关系表达式&lt;/p&gt;
&lt;p&gt;考虑下列程序对于输入&lt;code&gt;3&lt;/code&gt;的结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int n;
scanf(&quot;%d&quot;, &amp;amp;n);
switch(n)
{
    case 3 || 4:
        printf(&quot;YES!!!&quot;);
        break;
    case 5 || 6:
        printf(&quot;NO!!!&quot;);
        break;
    default:
        printf(&quot;No idea.&quot;);
        break;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;考虑下列语句的含义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;printf(&quot;%d&quot;, 5 &amp;gt; 3);
printf(&quot;%d&quot;, 3 &amp;amp;&amp;amp; 0);
printf(&quot;%d&quot;, !0);
a = 7 &amp;gt; 2 + 4;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关系运算优先级：（算术运算）&amp;gt; (关系运算) &amp;gt; (赋值)&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(a * b + c &amp;gt; c / d -e)
{
printf(“hello world”);
}
int f = a * b + c &amp;gt; c / d –e;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑表达式&lt;/p&gt;
&lt;p&gt;下列两个函数实现的效果完全相同&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int abs(int x)
{
    if(x &amp;lt; 0) return -x;
    else return x;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;int abs(int x)
{
    return x &amp;lt; 0 ? -x : x;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;变量的作用域与递归函数的本质&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;本地变量的作用域&lt;/li&gt;
&lt;li&gt;全局变量在定义时会自动初始化为 0，而本地变量不会，这意味着本地变量的初值是随机的，其取决于上一个使用这块内存的程序&lt;/li&gt;
&lt;li&gt;离开作用域的变量会被销毁&lt;/li&gt;
&lt;li&gt;递归的过程中究竟发生了什么？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C 语言程序设计上机测试其他注意事项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不要把&lt;strong&gt;SSE&lt;/strong&gt;当成&lt;strong&gt;IDE&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C 语言上机测试&lt;strong&gt;提交前&lt;/strong&gt;一定&lt;strong&gt;要在本地编译通过并用样例数据测试&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;善用输出调试与单步调试&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;几道题&lt;/h2&gt;
&lt;h3&gt;洛谷 P1059 明明的随机数&lt;/h3&gt;
&lt;p&gt;明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了$N$个$1$到$1000$之间的随机整数$(N≤100)$，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。&lt;/p&gt;
&lt;h3&gt;洛谷 P1177 【模板】快速排序（朴素算法）&lt;/h3&gt;
&lt;p&gt;给出$N$个数，将其从小到大排序.&lt;/p&gt;
&lt;p&gt;对于$100%$的数据，$N \leq 10^4$&lt;/p&gt;
&lt;h3&gt;洛谷 P3375 【模板】KMP 字符串匹配（朴素算法）&lt;/h3&gt;
&lt;p&gt;给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与$ s_2$完全相同，则称$ s_2 $在$ s_1 $中出现了，其出现位置为$l$。
现在请你求出 $s_2$ 在 $s_1 $中所有出现的位置。&lt;/p&gt;
&lt;p&gt;对于$100%$的数据，$s_1, s_2$的长度为$len_1, len_2$，$len_1, len_2 \leq 10^4$&lt;/p&gt;
&lt;h3&gt;洛谷 P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles&lt;/h3&gt;
&lt;p&gt;观察下面的数字金字塔。&lt;/p&gt;
&lt;p&gt;写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的样例中，从 $7 \to 3 \to 8 \to 7 \to 5$ 的路径产生了最大&lt;/p&gt;
&lt;h3&gt;洛谷 P1219 [USACO1.5]八皇后 Checker Challenge&lt;/h3&gt;
&lt;p&gt;一个如下的 $6×6$的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.luogu.com.cn/upload/pic/60.png&quot; alt=&quot;八皇后问题&quot; /&gt;&lt;/p&gt;
&lt;p&gt;上面的布局可以用序列$2\ 4\ 6\ 1\ 3\ 5$ 来描述，第 $i$ 个数字表示在第$i$行的相应位置有一个棋子，如下：&lt;/p&gt;
&lt;p&gt;行号 $1\ 2\ 3\ 4\ 5\ 6$&lt;/p&gt;
&lt;p&gt;列号 $2\ 4\ 6\ 1\ 3\ 5$&lt;/p&gt;
&lt;p&gt;这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。
并把它们以上面的序列方法输出，解按字典顺序排列。
请输出前 $3$个解。最后一行是解的总个数。&lt;/p&gt;
&lt;p&gt;输入样例&lt;code&gt;#1&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出样例&lt;code&gt;#2&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2 4 6 1 3 5
3 6 2 5 1 4
4 1 5 2 6 3
4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;P1784 数独【选做】&lt;s&gt;（困难但有趣）&lt;/s&gt;&lt;/h3&gt;
&lt;p&gt;数独是根据$ 9 \times 9$盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫内的数字均含 $1 - 9$ ，不重复。每一道合格的数独谜题都有且仅有唯一答案，推理方法也以此为基础，任何无解或多解的题目都是不合格的。&lt;/p&gt;
&lt;p&gt;芬兰一位数学家号称设计出全球最难的“数独游戏”，并刊登在报纸上，让大家去挑战。&lt;/p&gt;
&lt;p&gt;这位数学家说，他相信只有“智慧最顶尖”的人才有可能破解这个“数独之谜”。&lt;/p&gt;
&lt;p&gt;据介绍，目前数独游戏的难度的等级有一到五级，一是入门等级，五则比较难。不过这位数学家说，他所设计的数独游戏难度等级是十一，可以说是所以数独游戏中，难度最高的等级。他还表示，他目前还没遇到解不出来的数独游戏，因此他认为“最具挑战性”的数独游戏并没有出现。&lt;/p&gt;
&lt;p&gt;输入一个一个未填的数独，输出一个填好的数独。&lt;/p&gt;
&lt;p&gt;输入样例&lt;code&gt;#1&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8 0 0 0 0 0 0 0 0
0 0 3 6 0 0 0 0 0
0 7 0 0 9 0 2 0 0
0 5 0 0 0 7 0 0 0
0 0 0 0 4 5 7 0 0
0 0 0 1 0 0 0 3 0
0 0 1 0 0 0 0 6 8
0 0 8 5 0 0 0 1 0
0 9 0 0 0 0 4 0 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出样例&lt;code&gt;#1&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8 1 2 7 5 3 6 4 9
9 4 3 6 8 2 1 7 5
6 7 5 4 9 1 2 8 3
1 5 4 2 3 7 8 9 6
3 6 9 8 4 5 7 2 1
2 8 7 1 6 9 5 3 4
5 2 1 9 7 4 3 6 8
4 3 8 5 2 6 9 1 7
7 9 6 3 1 8 4 5 2
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>C语言答疑-02</title><link>https://blog.vonbrank.com/posts/hit-cs31106-explanation-02/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/hit-cs31106-explanation-02/</guid><description>C语言答疑-02 | Audience-120L0213 | By Von Brank</description><pubDate>Sat, 07 Nov 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;C 语言答疑-02&lt;/h1&gt;
&lt;p&gt;​ By Von Brank | 2020/11/07 | Audience: 120L0213&lt;/p&gt;
&lt;h2&gt;目录&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;集成开发环境（IDE）, 在线评测系统的(Online Judge)的推荐与使用&lt;/li&gt;
&lt;li&gt;近期知识梳理&lt;/li&gt;
&lt;li&gt;几道题&lt;/li&gt;
&lt;li&gt;答疑&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;集成开发环境（IDE）, 在线评测系统的(Online Judge)的推荐与使用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IDE
&lt;ul&gt;
&lt;li&gt;Dev-Cpp&lt;/li&gt;
&lt;li&gt;Visual Studio Code&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OJ
&lt;ul&gt;
&lt;li&gt;www.luogu.com.cn&lt;/li&gt;
&lt;li&gt;leetcode-cn.com&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;算法可视化
&lt;ul&gt;
&lt;li&gt;visualgo.net/zh&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;知识点梳理&lt;/h2&gt;
&lt;h3&gt;数组&lt;/h3&gt;
&lt;h4&gt;数组能够解决的基本问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;给出 $N$ 个数，计算它们的平均数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int main()
{
    int n, sum = 0, x;
    scanf(&quot;%d&quot;, &amp;amp;n);
    for(int i=1; i&amp;lt;=n; i++)
    {
        scanf(&quot;%d&quot;, &amp;amp;x);
        sum += x;
    }
    printf(&quot;%lf&quot;, (double)sum / n);
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;注意到不需要记录每一个输入的数
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;给出 $N$ 个数（$N \le 100$），输出所有大于平均数的数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
const int maxn = 105;
int main()
{
    int n, sum = 0;
    int a[maxn]; //定义数组
    double avg;
    scanf(&quot;%d&quot;, &amp;amp;n);
    for(int i=1; i&amp;lt;=n; i++)
    {
        scanf(&quot;%d&quot;, &amp;amp;a[i]); //读入数组
        sum += a[i];
    }
    avg = (double)sum / n;
    for(int i=1; i&amp;lt;=n; i++) //遍历数组
    {
		if(a[i] &amp;gt; avg) printf(&quot;%d &quot;, a[i]); //输出数组元素
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要记录很多数字，需要使用&lt;strong&gt;数组&lt;/strong&gt;存储&lt;/p&gt;
&lt;h4&gt;数组的定义&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 一维数组
 */
&amp;lt;变量类型&amp;gt; &amp;lt;变量名称&amp;gt;[元素数量];

int numbers[100];
double numberss[100];
for(int i=1; i&amp;lt;=n; i++)
	scanf(&quot;%d&quot;, numbers[i]);
/*
 * 二维数组
 */
&amp;lt;变量类型&amp;gt; &amp;lt;变量名称&amp;gt;[第一维长度][第二维长度];

int numbers[100][100];

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;元素数量必须是&lt;strong&gt;整数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;C99 标准之前，定义数组时元素数量应是&lt;strong&gt;常量&lt;/strong&gt;或&lt;strong&gt;用宏定义实现&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;C99 标准之后，在函数定义数组时元素的数量可以是&lt;strong&gt;变量&lt;/strong&gt;，但全局变量数组定义的元素数量仍&lt;strong&gt;只能使用宏定义&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;数组的集成初始化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一维数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[1050] = {0, 1, 1, 2, 3, 5, 8, 13,};

int a[] = {0, 1, 1, 2, 3, 5, 8, 13,};

int a[1050] = { [1] = 1, 1, 2, 3, 5, 8, 13,};
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二维数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[105][105] =
{
    {0, 1, 1, 2, 3, 5, 8, 13,},
    {0, 1, 2, 4, 8, 16, 32, 64,},
};
int b[][4] =
{
    {0, 1, 2, 3,},
    {0, 2, 4, 6,},
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二维数组&lt;strong&gt;第二维&lt;/strong&gt;长度必须被定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;将变量作为数组定义的元素数量并作集成初始化的注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下定义方式在 C 语言中可以通过编译&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#define maxn 100
int main()
{
    int a[maxn] = {0, 1, 2, 3,};
    return 0;
}

------------------------------

#include &amp;lt;stdio.h&amp;gt;
int main()
{
    int a[100] = {0, 1, 2, 3,};
    return 0;
}

------------------------------

#include &amp;lt;stdio.h&amp;gt;
int main()
{
    const int maxn = 100;
    int a[maxn] = {0, 1, 2, 3,};
    return 0;
}

------------------------------

#include &amp;lt;stdio.h&amp;gt;
int main()
{
    int maxn = 100;
    int a[maxn] = {0, 1, 2, 3,};
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下定义方式在 C 语言中无法通过编译，但是在 C++中可以&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
const int maxn = 100;
int main()
{
    int a[100] = {0, 1, 2, 3,};
    return 0;
}

-------------------------------

#include &amp;lt;stdio.h&amp;gt;
int main()
{
    const int maxn = 100;
    int a[100] = {0, 1, 2, 3,};
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;数组的赋值&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;错误示范&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[1050] = {0, 1, 2, 3, 4, 5,};
int b[1050];
b = a;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;正确示范&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[1050] = {0, 1, 2, 3, 4, 5,};
int b[1050];
for(int i=0; i&amp;lt;=5; i++)
    b[i] = a[i];
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;数组的遍历&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将数组从头至尾验视一次&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;一般使用&lt;code&gt;for&lt;/code&gt;循环进行数组遍历&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些遍历数组的例子&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数组的遍历赋值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(int i=1; i&amp;lt;=n; i++)
    b[i] = a[i];
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组的遍历初始化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(int i=1; i&amp;lt;=n; i++)
   a[i] = 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遍历数组查找元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(int i=1; i&amp;lt;=n; i++)
{
    if(key == a[i])
    {
        ans = i;
        break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出比平均值大的数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(int i=1; i&amp;lt;=n; i++)
{
    if(a[i] &amp;gt; avg)
    {
        printf(&quot;%d &quot;, a[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出数组中所有值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(int i=1; i&amp;lt;=n; i++)
{
    printf(&quot;%d &quot;, a[i]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;数组作为函数的参数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于一维数组，不能在&lt;code&gt;[]&lt;/code&gt;中给出数组的大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无法再利用&lt;code&gt;sizeof()&lt;/code&gt;函数给出数组的大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;往往需要再传入一个变量来描述数组大小&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int search(int key, int a[], int len)
{
    int ans = -1;
    for(int i=1; i&amp;lt;=len; i++)
    {
        if(a[i] == key)
        {
            ans = i;
            break;
        }
    }
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;字符串简介&lt;/h4&gt;
&lt;h5&gt;ASCII 码表&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;tool.ip138.com/ascii_code/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;char&lt;/code&gt;既是整数也是字符，取决于你怎么看它&lt;/p&gt;
&lt;p&gt;以下两个&lt;code&gt;printf&lt;/code&gt;语句输出都是&lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;printf(&quot;%c\n&quot;, 49);
printf(&quot;%d\n&quot;, 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下两个&lt;code&gt;printf&lt;/code&gt;语句输出都是&lt;code&gt;49&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;printf(&quot;%c\n&quot;, &apos;1&apos;);
printf(&quot;%d\n&quot;, 49);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以&quot;&lt;code&gt;char&lt;/code&gt;的方式&quot;看待&lt;code&gt;49&lt;/code&gt;这个&lt;strong&gt;整数&lt;/strong&gt;，它是字符&lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以&quot;&lt;code&gt;int&lt;/code&gt;的方式&quot;看待&lt;code&gt;1&lt;/code&gt;这个&lt;strong&gt;字符&lt;/strong&gt;，他是整数&lt;code&gt;49&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&apos;\n&apos;&lt;/code&gt;，&lt;code&gt;&apos;\t&apos;&lt;/code&gt;与空格&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;字符串的定义与初始化&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;char s[100];

char str[100] = &quot;Hello World!!!&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;字符串的输入与输出&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%s&lt;/code&gt;会将当前位置与下一个空格或回车之间的字符串赋值给字符串&lt;code&gt;s&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;char s[100];
scanf(&quot;%s&quot;, s);
printf(&quot;%s&quot;, s);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;上述写法中，&lt;code&gt;scanf&lt;/code&gt;会将输入字符串的首位赋值给&lt;code&gt;s[0]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;每个字符串都以&lt;code&gt;&apos;\0&apos;&lt;/code&gt;结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;常用字符串函数&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;需要&lt;code&gt;#include &amp;lt;string.h&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getchar()&lt;/code&gt;单字符输入，&lt;code&gt;putchar()&lt;/code&gt;单字符输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strlen()&lt;/code&gt;计算字符串长度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strcmp()&lt;/code&gt;比较两个字符串是否相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strcpy()&lt;/code&gt;将一个字符串赋值给另一个字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strcat()&lt;/code&gt;将一个字符串拷贝到另一个字符串的后面，连成一个长的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;数组其他注意事项&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数组是一种&lt;strong&gt;容器&lt;/strong&gt;，有如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个数组中所有元素类型相同&lt;/li&gt;
&lt;li&gt;数组一旦定义，不能改变大小&lt;/li&gt;
&lt;li&gt;任意维度的数组在内存中的排列是&lt;strong&gt;连续的&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组中的每一个单元是数组类型的一个变量，使用数组时&lt;code&gt;[]&lt;/code&gt;中的数字称为下标或索引，下标从$0$开始计数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个拥有$n$个元素的数组，下标的范围是$[0, n-1]$，以大于等于$n$的下标访问数组&lt;strong&gt;可能&lt;/strong&gt;会造成数组越界导致程序崩溃，但是&lt;strong&gt;编译器在编译时并不会检查数组是否越界&lt;/strong&gt;，因此务必保证程序只使用有效下标访问数组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建数组时，应给予冗余的数组元素个数，如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
const int maxn = 1050; //对于1e3的数据范围，给予额外50个元素
int main()
{
    int n;
    int a[maxn];
    scanf(&quot;%d&quot;, &amp;amp;n);
    for(int i=1; i&amp;lt;=n; i++)
        scanf(&quot;%d&quot;, &amp;amp;a[i]);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;s&gt;因数组越界而扣分所造成的损失比计算机内部多几个&lt;code&gt;int&lt;/code&gt;所造成的内存消耗严重得多（&lt;/s&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;数组的应用&lt;/h4&gt;
&lt;h5&gt;洛谷 P5737 【深基 7.例 3】闰年展示&lt;/h5&gt;
&lt;p&gt;输入 $x,y(1582\le x &amp;lt; y \le 3000)$，输出$[x,y] $区间中闰年个数，并在下一行输出所有闰年年份数字，使用空格隔开。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不使用数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
	int x, y, cnt = 0;
	scanf(&quot;%d %d&quot;, &amp;amp;x, &amp;amp;y);
	for(int i=x; i&amp;lt;=y; i++)
	{
		if(i % 4 == 0 &amp;amp;&amp;amp; !(i % 100 == 0 &amp;amp;&amp;amp; i % 400 != 0))
		{
			cnt++;
		}
	}
	printf(&quot;%d\n&quot;, cnt);
	for(int i=x; i&amp;lt;=y; i++) //需要做两遍计算
	{
		if(i % 4 == 0 &amp;amp;&amp;amp; !(i % 100 == 0 &amp;amp;&amp;amp; i % 400 != 0))
		{
			printf(&quot;%d &quot;, i);
		}
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
	int x, y, cnt = 0;
    int leapYear[1050];
	scanf(&quot;%d %d&quot;, &amp;amp;x, &amp;amp;y);
	for(int i=x; i&amp;lt;=y; i++)
	{
		if(i % 4 == 0 &amp;amp;&amp;amp; !(i % 100 == 0 &amp;amp;&amp;amp; i % 400 != 0))
		{
			leapYear[++cnt] = i;
		}
	}
	printf(&quot;%d\n&quot;, cnt);
	for(int i=1; i&amp;lt;=cnt; i++)
    {
        printf(&quot;%d&quot;, leapYear[i]);
    }
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;洛谷 P1255 数楼梯&lt;/h5&gt;
&lt;p&gt;楼梯有$N(N \leq 50 )^*$阶，上楼可以一步上一阶，也可以一步上二阶。&lt;/p&gt;
&lt;p&gt;编一个程序，计算共有多少种不同的走法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不使用数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
long long Fib(int n)
{
	if(n == 0 || n == 1) return 1;
	return Fib(n-1) + Fib(n-2);
}

int main()
{
	int n;
	scanf(&quot;%d&quot;, &amp;amp;n);
	printf(&quot;%d&quot;, Fib(n));
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/03/ByFmr9.png&quot; alt=&quot;ByFmr9.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
const int maxn = 10050;
int main()
{
	int n;
    long long a[maxn];
	scanf(&quot;%d&quot;, &amp;amp;n);
	a[0] = 0;
    a[1] = 1;
    for(int i=2; i&amp;lt;=n; i++)
        a[i] = a[i-1] + a[i-2];
    printf(&quot;%lld&quot;, a[n]);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;*运行结果：&lt;strong&gt;AC!!! :)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;洛谷 P1464 Function&lt;/h5&gt;
&lt;p&gt;对于一个递归函数$w(a,b,c)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果$a \le 0\quad or\quad b \le 0 \quad or\quad c \le 0$就返回值$11$&lt;/li&gt;
&lt;li&gt;如果$a&amp;gt;20\quad or\quad b&amp;gt;20\quad or\quad c&amp;gt;20\quad$就返回$w(20,20,20)$&lt;/li&gt;
&lt;li&gt;如果$a&amp;lt;b$并且$b&amp;lt;c $就返回$w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c)$&lt;/li&gt;
&lt;li&gt;其它的情况就返回$w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是个简单的递归函数，但实现起来可能会有些问题。当$a,b,c$均为$15$时，调用的次数将非常的多。&lt;strong&gt;你要想个办法才行&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;对于一些特殊情况，比如 $w(30,-1,0)$既满足条件$1$又满足条件$2$，这种时候我们就按最上面的条件来算，所以答案为$1$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不使用数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int w(int a, int b, int c)
{
	if(a &amp;lt;= 0 || b &amp;lt;= 0 || c &amp;lt;= 0) return 1;
	else if(a &amp;gt; 20 || b &amp;gt; 20 || c &amp;gt; 20) return w(20, 20, 20);
	else if(a &amp;lt; b &amp;amp;&amp;amp; b &amp;lt; c) return w(a, b, c-1) + w(a, b -1, c - 1) - w(a, b, c - 1);
	else return w(a-1, b, c)+w(a-1, b-1, c)+w(a-1, b, c-1)-w(a-1, b-1, c-1);
}
int main()
{
	int a, b, c;
	while(1)
	{
		scanf(&quot;%d %d %d&quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
		if(a == -1 &amp;amp;&amp;amp; b == -1 &amp;amp;&amp;amp; c == -1)
		{
			break;
		}
		printf(&quot;w(%d, %d, %d) = %d\n&quot;, a, b, c, w(a, b, c));
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/03/BykPLd.png&quot; alt=&quot;BykPLd.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用数组（记忆化）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int vis[25][25][25];
void init()
{
    for(int i=0; i&amp;lt;=20; i++)
    {
        for(int j=0; j&amp;lt;=20; j++)
        {
			for(int k=0; k&amp;lt;=20; k++)
            {
                vis[i][j][k] = -1;
            }
        }
    }
}
int w(int a, int b, int c)
{
    if(a &amp;lt;= 0 || b &amp;lt;= 0 || c &amp;lt;= 0)
		a = b = c = 0;
    if(a &amp;gt; 20 || b &amp;gt; 20 || c &amp;gt; 20)
		a = b = c = 20;
    if(vis[a][b][c] != -1) return vis[a][b][c];
	else if(a &amp;lt;= 0 || b &amp;lt;= 0 || c &amp;lt;= 0) return vis[0][0][0] = 1;
	else if(a &amp;lt; b &amp;amp;&amp;amp; b &amp;lt; c) return vis[a][b][c] = w(a, b, c - 1) + w(a, b -1, c - 1) - w(a, b, c - 1);
	else return vis[a][b][c] = w(a - 1, b, c) + w(a - 1,  b- 1, c) + w(a - 1, b, c - 1) - w(a - 1, b - 1, c - 1);
}
int main()
{
	int a, b, c;
	while(1)
	{
		init(); //计算每组数据前要初始化数组
		scanf(&quot;%d %d %d&quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
		if(a == -1 &amp;amp;&amp;amp; b == -1 &amp;amp;&amp;amp; c == -1)
		{
			break;
		}
		printf(&quot;w(%d, %d, %d) = %d\n&quot;, a, b, c, w(a, b, c));
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;strong&gt;AC!!! :)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C 语言庶事&lt;/h3&gt;
&lt;h4&gt;整数是怎么表达的——原码，反码，补码&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;没什么目的，只是为了方便计算&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;各数据类型的表达范围与自然溢出&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;类型有 32 位，表达范围为$[-2^{31}, 2^{31}-1]$&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unsigned int&lt;/code&gt;数据范围是$[0, 2^{32}-1]$&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;各数据类型的输入输出&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unsigned int&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%lld&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;long long&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%llu&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unsigned long long&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;浮点数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;令人头疼的精度问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
    if(1.1 + 0.1 == 1.2)
        printf(&quot;YES!!!&quot;);
    else
        printf(&quot;NO!!!&quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上程序输出的是&lt;code&gt;NO&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;1.1 + 0.1&lt;/code&gt;为什么不等于&lt;code&gt;1.2&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0.1转化为二进制的结果是一个循环小数:
0.00011001100110011001100110011001100110011001100110011010
double类型在二进制下的精度是53位有效数字，超出部分四舍五入

同理将1.1转化为二进制:
1.0001100110011001100110011001100110011001100110011010

二者相加
 	0.00011001100110011001100110011001100110011001100110011010
+	1.0001100110011001100110011001100110011001100110011010
---------------------------------------------------------------
 	1.0011001100110011001100110011001100110011001100110100



将结果转化为十进制：
1.20000000000000018

将1.2转化为二进制：
1.0011001100110011001100110011001100110011001100110011

与1.1+0.1的二进制结果:
1.0011001100110011001100110011001100110011001100110100
相比较

二者不同
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方案&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;  #include &amp;lt;stdio.h&amp;gt;
const double eps = 1e-6;
  double eps(double x)
  {
      return x &amp;lt; 0 ? -x : x;
  }
  int main()
  {
      if((abs(1.1 + 0.1 - 1.2) &amp;lt; eps)
          printf(&quot;YES!!!&quot;);
      else
          printf(&quot;NO!!!&quot;);
      return 0;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;C 语言程序设计其他注意事项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不要把&lt;strong&gt;SSE&lt;/strong&gt;当成&lt;strong&gt;IDE&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;C 语言上机测试&lt;strong&gt;提交前&lt;/strong&gt;一定&lt;strong&gt;要在本地编译通过并用样例数据测试&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;循环变量使用$i, j, k$&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int a, tmp;
for(a = 1, tmp = 0; a &amp;lt;= n; a++) //错误示范
{
    ...
    ...
}

int i;
int tmp = 0;
for(i = 1; i &amp;lt;= n; i++) //正确示范
{
    ...
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;遵循 C 语言标准代码规范&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;运算符两端空格&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a=b+1; //错误示范

int a = b + 1; //正确示范
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;s&gt;当然，嫌&lt;code&gt;for&lt;/code&gt;循环内空格太多也可以不遵循本条&lt;/s&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;采用缩进风格&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(n == 0) //错误示范
{
a = b + 1;
b ++;
}

if(n == 0)  //正确示范
{
    a = b + 1;
    b ++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免把多行语句写在同一行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a = b + 1; b++;  //错误示范

int a = b + 1;  //正确示范
b++;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;几道题&lt;/h2&gt;
&lt;h3&gt;洛谷 P1177 【模板】快速排序&lt;/h3&gt;
&lt;p&gt;给出$N$个数，将其从小到大排序.&lt;/p&gt;
&lt;p&gt;对于$100%$的数据，$N \leq 10^5$&lt;/p&gt;
&lt;h3&gt;相亲数&lt;/h3&gt;
&lt;p&gt;输入一个数$n$，输出$[0, n]$范围内每一对相亲数&lt;/p&gt;
&lt;p&gt;注：相亲数指两个正整数中，彼此的全部约数之和（本身除外）与另一方相等&lt;/p&gt;
&lt;h3&gt;洛谷 P3383 【模板】线性筛素数&lt;/h3&gt;
&lt;p&gt;给定一个范围 $n$，有 $q$ 个询问，每次输出区间$[0, n]$范围内第 $k$ 小的素数。&lt;/p&gt;
&lt;p&gt;对于$100%$的数据，$n \leq 10^8$，$q \leq 10^6$，&lt;strong&gt;保证输入合法&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;洛谷 P1706 全排列问题&lt;/h3&gt;
&lt;p&gt;输入一个数$n$输出自然数$1$到$n$所有不重复的排列，即$n$的全排列，要求所产生的任一数字序列中不允许出现重复的数字。&lt;/p&gt;
&lt;p&gt;输出的所有排列按&lt;strong&gt;字典序&lt;/strong&gt;排序&lt;/p&gt;
&lt;p&gt;对于$100%$的数据，$1 \leq n \leq 9$&lt;/p&gt;
</content:encoded></item><item><title>C语言答疑-01</title><link>https://blog.vonbrank.com/posts/hit-cs31106-explanation-01/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/hit-cs31106-explanation-01/</guid><description>C语言答疑-01 | Audience-120L0216 | By Von Brank</description><pubDate>Wed, 28 Oct 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;C 语言答疑-01&lt;/h1&gt;
&lt;p&gt;​ By Von Brank | 2020/10/28&lt;/p&gt;
&lt;h2&gt;目录:&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;IDE 的推荐与使用&lt;/li&gt;
&lt;li&gt;在线评测系统的推荐与使用&lt;/li&gt;
&lt;li&gt;近期所学知识梳理&lt;/li&gt;
&lt;li&gt;常见错误&lt;/li&gt;
&lt;li&gt;几道例题&lt;/li&gt;
&lt;li&gt;答疑&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;IDE 的推荐与使用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Dev-Cpp&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Visual Studio Code&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;在线评测系统的推荐与使用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;www.luogu.com.cn&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;知识点梳理&lt;/h2&gt;
&lt;h3&gt;函数&lt;/h3&gt;
&lt;hr /&gt;
&lt;h4&gt;函数的基本应用&lt;/h4&gt;
&lt;p&gt;解决代码重复率高，质量低下的问题&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int i, sum;
for(i=1, sum=0; i&amp;lt;=10; i++) //计算1~10的和
{
    sum += i;
}
printf(&quot;%d\n&quot;, sum);

for(i=11, sum=0; i&amp;lt;=20; i++) //计算11~20的和
{
    sum += i;
}
printf(&quot;%d\n&quot;, sum);

for(i=21, sum=0; i&amp;lt;=30; i++) //计算21~30的和
{
    sum += i;
}
printf(&quot;%d\n&quot;, sum);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;写成函数形式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void sum(int a, int b)
{
    int ans = 0, i;
    for(i=a; i&amp;lt;=b; i++)
    {
        ans += i;
    }
    printf(&quot;%d\n&quot;, ans);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;函数的定义&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;函数头&amp;gt; &amp;lt;函数名&amp;gt;(参数表)
{
    函数体
}

void sum(int a, int b)
{
    int ans = 0, i;
    for(i=a; i&amp;lt;=b; i++)
    {
        ans += i;
    }
    printf(&quot;%d\n&quot;, ans);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;函数的调用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
void hello()
{
    printf(&quot;Hello World!!!&quot;);
}
int main()
{
    hello; -&amp;gt; 错误写法
    hello(); //没有参数也要()
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
void sum(int a, int b)
{
    int ans = 0, i;
    for(i=a; i&amp;lt;=b; i++)
    {
        ans += i;
    }
    printf(&quot;%d\n&quot;, ans);
}
int main()
{
    sum(1, 10);
    sum(11, 20);
    sum(21, 30);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;函数的返回值&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;返回类型&lt;/th&gt;
&lt;th&gt;写法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void function(); &lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;int function();&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;double&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;double function();&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int sum(int a, int b)
{
    int ans = 0, i;
    for(i=a; i&amp;lt;=b; i++)
    {
        ans += i;
    }
    return ans;  //注意：非void类型函数结尾必须写return语句
}
int main()
{
    printf(&quot;%d\n&quot;, sum(1, 10));
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;return&lt;/code&gt;是函数的出口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return &amp;lt;变量&amp;gt;;&lt;/code&gt;是非&lt;code&gt;void&lt;/code&gt;函数的出口，并返回一个值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void&lt;/code&gt;函数中的&lt;code&gt;return;&lt;/code&gt;仅作为函数的出口&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;函数原型（声名）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;main&lt;/code&gt; 函数之前声名，在&lt;code&gt;main&lt;/code&gt;函数后定义一定程度上可以避免头重脚轻，但通常不会这么写&lt;/li&gt;
&lt;li&gt;C/C++/Java 语言对于声名，定义等概念有严格要求&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int sum(int a, int b); //告诉编译器这个函数的样子
int main()
{
    printf(&quot;%d\n&quot;, sum(1, 10));
    return 0;
}
int sum(int a, int b)
{
    int ans = 0, i;
    for(i=a; i&amp;lt;=b; i++)
    {
        ans += i;
    }
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;参数的传递&lt;/h4&gt;
&lt;p&gt;本质上是用传入的参数初始化函数参数表的变量&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传递的参数要与参数表对应类型相匹配&lt;/li&gt;
&lt;li&gt;传递参数的个数要与对应函数参数表的变量个数相匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
void sum(int a, int b)
{
    int ans = 0, i;
    for(i=a; i&amp;lt;=b; i++)
    {
        ans += i;
    }
    printf(&quot;%d\n&quot;, ans);
}
int main()
{
    sum(1.1, 9.9); //不匹配的参数类型会被强制类型转换，然后以其结果初始化参数
    sum(11, 20, 30); //传入的参数个数不匹配会导致编译错误
    sum(21, 30);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;参数在函数内是本地变量&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;变量的值作为参数初始化参数表的变量时，参变量值的改变不会改变被传入参数的值&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
void sum(int a, int b)
{
    n = 1;
    int ans = 0, i;
    for(i=a; i&amp;lt;=b; i++)
    {
        ans += i;
    }
    printf(&quot;%d\n&quot;, ans);
}
int main()
{
    int m = 1, n = 10;
    sum(m, n);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;与全局变量同名的参数表变量会将该全局变量屏蔽&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int a, b;
void sum(int a, int b)
{
    int ans = 0, i;
    for(i=a; i&amp;lt;=b; i++)
    {
        ans += i;
    }
    printf(&quot;%d\n&quot;, ans);
}
int main()
{
    sum(1, 10);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;不与参变量同名的全局非常量变量可以在函数内直接被修改&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int n;
void sum(int a, int b)
{
    n = 1;
    int ans = 0, i;
    for(i=a; i&amp;lt;=b; i++)
    {
        ans += i;
    }
    printf(&quot;%d\n&quot;, ans);
}
int main()
{
    sum(1, 10);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;代码块内部的变量也是本地变量，与函数内的本地变量类似&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int main()
{
    int a, b;
    a = 1;
    b = 2;
    printf(&quot;%d %d\n&quot;, a, b);
    {
        int a;
        a = 3;
        printf(&quot;%d %d\n&quot;, a, b);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;关于函数的一些细节&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void function(void);&lt;/code&gt;以及&lt;code&gt;void function();&lt;/code&gt;表示参数未知，并不表示没有参数，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
void f();
int main()
{
	int a = 1, b = 2;
    f(a, b);
    return 0;
}
void f(double a, double b)
{
    printf(&quot;%d %d&quot;, a, b);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这类写法是编译器的作者没想到的，因此在编写函数原型时一定要写全参数，在没有参数时可写&lt;code&gt;void&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逗号预算符&lt;code&gt;,&lt;/code&gt;在参数传递中可能导致的错误&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int a, b;
void sum(int a, int b)
{
    int ans = 0, i;
    for(i=a; i&amp;lt;=b; i++)
    {
        ans += i;
    }
    printf(&quot;%d\n&quot;, ans);
}
int main()
{
    int a = 1, b = 10;
    sum(a, b);
    sum((a, b));  //比较这两行的区别
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;C/C++语言不允许函数内嵌套函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;几种鬼畜的写法&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int i, j, sum(int a, int b);

return (ans);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上写法可以通过编译，但不推荐使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;main()&lt;/code&gt;是什么&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int main()&lt;/code&gt;也是一个函数&lt;/li&gt;
&lt;li&gt;可以写成&lt;code&gt;int main(void)&lt;/code&gt;但通常不这么写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt;函数结尾的&lt;code&gt;return 0;&lt;/code&gt;是有意义的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;递归&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;递归是程序运行过程中函数调用自身的行为&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;阶乘&lt;/strong&gt;与&lt;strong&gt;斐波那契数列&lt;/strong&gt;是经典的递归案例，但是学完数组之后你很可能不会再用递归来实现它们&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int Fib(int n)
{
    if(n == 1 || n == 2) return 1;
    else return Fib(n - 1) + Fib(n - 2);
}

int Fac(int n)
{
    if(n == 0) return 1;
    else return n * Fac(n - 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C 语言中递归的本质——&lt;strong&gt;栈&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;几道题&lt;/h2&gt;
&lt;h3&gt;洛谷 P5735 【深基 7.例 1】距离函数&lt;/h3&gt;
&lt;p&gt;给出平面坐标上不在一条直线上三个点坐标$ (x_1,y_1),(x_2,y_2),(x_3,y_3)$，坐标值是实数，且的绝对值不超过 $100.00$，求围成的三角形周长。保留两位小数。&lt;/p&gt;
&lt;p&gt;对于平面上的两个点 $(x_1,y_1),(x_2,y_2)$，则这两个点之间的距离 $dis=\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$&lt;/p&gt;
&lt;h3&gt;洛谷 P5737 【深基 7.例 3】闰年展示&lt;/h3&gt;
&lt;p&gt;输入 $x,y(1582\le x &amp;lt; y \le 3000)$，输出$[x,y] $区间中闰年个数，并在下一行输出所有闰年年份数字，使用空格隔开。&lt;/p&gt;
&lt;h3&gt;洛谷 P1255 数楼梯&lt;/h3&gt;
&lt;p&gt;楼梯有$N$阶，上楼可以一步上一阶，也可以一步上二阶。&lt;/p&gt;
&lt;p&gt;编一个程序，计算共有多少种不同的走法。&lt;/p&gt;
&lt;h3&gt;洛谷 P1464 Function&lt;/h3&gt;
&lt;p&gt;对于一个递归函数$w(a,b,c)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果$a \le 0\quad or\quad b \le 0 \quad or\quad c \le 0$就返回值$11$&lt;/li&gt;
&lt;li&gt;如果$a&amp;gt;20\quad or\quad b&amp;gt;20\quad or\quad c&amp;gt;20\quad$就返回$w(20,20,20)$&lt;/li&gt;
&lt;li&gt;如果$a&amp;lt;b$并且$b&amp;lt;c $就返回$w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c)$&lt;/li&gt;
&lt;li&gt;其它的情况就返回$w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是个简单的递归函数，但实现起来可能会有些问题。当$a,b,c$均为$15$时，调用的次数将非常的多。你要想个办法才行.&lt;/p&gt;
&lt;p&gt;对于一些特殊情况，比如 $w(30,-1,0)$既满足条件$1$又满足条件$2$，这种时候我们就按最上面的条件来算，所以答案为$1$&lt;/p&gt;
&lt;h3&gt;洛谷 P1029 最大公约数和最小公倍数问题&lt;/h3&gt;
&lt;p&gt;输入两个正整数 $x_0, y_0$，求出满足下列条件的 $P, Q$ 的个数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$P,Q$ 是正整数。&lt;/li&gt;
&lt;li&gt;要求 $P, Q$ 以 $x_0$ 为最大公约数，以 $y_0$ 为最小公倍数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;试求：满足条件的所有可能的 $P, Q$ 的个数。&lt;/p&gt;
</content:encoded></item><item><title>Windows下的Visual Studio Code 配置指南（C/C++）</title><link>https://blog.vonbrank.com/posts/visual-studio-code-c-config-windows/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/visual-studio-code-c-config-windows/</guid><pubDate>Fri, 11 Sep 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;现代vscode开发环境的搭建以&lt;a href=&quot;https://yukkohzq.github.io/&quot;&gt;Yukko&lt;/a&gt;的“编译器版本越新越好”为嚆矢。滥觞于C与C++的传统vscode配置方案正失去它们的借鉴意义。但面对看似无垠的未来天空，我想循全新的vscode的自动配置设置，好过过早地振翮。&lt;/p&gt;
&lt;p&gt;本篇部分内容参考&lt;a href=&quot;https://blog.csdn.net/bat67/article/details/81268581&quot;&gt;这篇文章&lt;/a&gt;，仅限学习用途&lt;/p&gt;
&lt;h2&gt;先决条件&lt;/h2&gt;
&lt;h3&gt;下载尽可能新版的MinGW&lt;/h3&gt;
&lt;p&gt;过程略，详情请咨询&lt;a href=&quot;https://yukkohzq.github.io/&quot;&gt;Yukko&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;配置环境变量&lt;/h3&gt;
&lt;p&gt;以编译器路径为 &lt;strong&gt;C:\MinGW&lt;/strong&gt; 为例，将其中的bin文件夹路径 &lt;strong&gt;C:\MinGW\bin&lt;/strong&gt; 添加至 &lt;strong&gt;Path&lt;/strong&gt; 即可（示意图仅供参考，请以实际路径为准）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/09/18/w4qzYF.png&quot; alt=&quot;配置环境变量&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Visual Studio Code 安装与配置&lt;/h2&gt;
&lt;h3&gt;下载与安装 Visual Studio Code&lt;/h3&gt;
&lt;p&gt;过程略&lt;/p&gt;
&lt;h3&gt;安装 VSCode C/C++ 插件&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/09/18/w4q2Lt.png&quot; alt=&quot;vscode-cpp&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;配置.vscode文件&lt;/h3&gt;
&lt;p&gt;与传统方法不同，基于新版vscode的特性，&lt;strong&gt;.vscode&lt;/strong&gt; 中的文件可以自动配置&lt;/p&gt;
&lt;h4&gt;运行&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;在任意位置新建文件夹，创建一个 &lt;strong&gt;.cpp&lt;/strong&gt; 文件并编写一个简单的程序（以 &lt;strong&gt;a.cpp&lt;/strong&gt; 为例）
&lt;img src=&quot;https://s1.ax1x.com/2020/09/11/wNLMf1.png&quot; alt=&quot;新建&quot; /&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/09/11/wNOs81.png&quot; alt=&quot;a.cpp&quot; /&gt;&lt;/li&gt;
&lt;li&gt;按下 &lt;strong&gt;Ctrl+Shift+B&lt;/strong&gt; 以进行编译，在弹出菜单中选择 &lt;strong&gt;g++&lt;/strong&gt; 项
&lt;img src=&quot;https://s1.ax1x.com/2020/09/11/wNOT2t.png&quot; alt=&quot;编译&quot; /&gt;&lt;/li&gt;
&lt;li&gt;创建一个新的终端，在指定路径输入 &lt;strong&gt;.\a&lt;/strong&gt; 即可运行
&lt;img src=&quot;https://s1.ax1x.com/2020/09/11/wNXSGn.png&quot; alt=&quot;run&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;调试&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;添加断点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/09/11/wNXfyV.png&quot; alt=&quot;断点&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择 &lt;strong&gt;运行和调试&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/09/11/wNX3ZD.png&quot; alt=&quot;debug&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在弹出的菜单中选择&lt;strong&gt;C++(GDB/LLDB)&lt;/strong&gt; -&amp;gt; &lt;strong&gt;g++.exe&lt;/strong&gt;项，vscode将自动生成一份 &lt;strong&gt;launch.json&lt;/strong&gt; 配置文件（只有正确配置环境变量才能生成正确的配置文件）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/09/11/wNjklt.png&quot; alt=&quot;gdb&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/09/11/wNvEC9.png&quot; alt=&quot;g++&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/09/11/wNvLqK.png&quot; alt=&quot;launch.json&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;点击 &lt;strong&gt;绿色三角形&lt;/strong&gt; 开始调试&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/09/11/wNxmGj.png&quot; alt=&quot;debug&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;vscode的调试功能支持单步调试，单步跳过，堆栈信息查看等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/09/11/wNxQs0.png&quot; alt=&quot;debug_success&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;后续步骤&lt;/h2&gt;
&lt;p&gt;到此为止，你完成了vscode在Windows下针对C++编程的基本配置。&lt;/p&gt;
&lt;p&gt;希望这篇文章对你有帮助，你也可以将其推荐给你使用C++编写程序却不了解如何在vscode上进行配置的朋友，希望可以让他们在vscode的配置上少走一些弯路.&lt;/p&gt;
</content:encoded></item><item><title>NOIP 2018 退役记</title><link>https://blog.vonbrank.com/posts/noip-2018-afo-experience/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/noip-2018-afo-experience/</guid><description>NOIP 2018 退役记</description><pubDate>Tue, 13 Nov 2018 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;本文迁移自洛谷，原文链接：&lt;a href=&quot;https://von-brank.blog.luogu.org/Noip-2018-final-blog&quot;&gt;https://von-brank.blog.luogu.org/Noip-2018-final-blog&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;NOIP 2018 试题列表：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P5019&quot;&gt;D1T1 铺设道路&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P5020&quot;&gt;D1T2 货币系统&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P5021&quot;&gt;D1T3 赛道修建&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P5022&quot;&gt;D2T1 旅行&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P5023&quot;&gt;D2T2 填数游戏&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P5024&quot;&gt;D2T3 保卫王国&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;s&gt;一年OI一场空...&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;这是我第一次参加NOIP，也是最后一次参加NOIP了&lt;/p&gt;
&lt;p&gt;在退役之前写一篇文章纪念一下&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;2017.07 - 2017.10&lt;/h1&gt;
&lt;p&gt;中考完后的暑假，不是在家和朋友语音开黑聊天打游戏，就是出门浪~~(颓废)~~。闲来无事，突然心血来潮想要学习C语言，在B站找到了&lt;a href=&quot;https://www.bilibili.com/video/BV1sJ411E7St&quot;&gt;翁恺的C语言慕课&lt;/a&gt;开始学敲代码(130多集的微课我居然三个月就看完了)，我的OI生涯从这里开始.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;2017.11 - 2018.11&lt;/h1&gt;
&lt;h2&gt;正式OI生涯&lt;/h2&gt;
&lt;h3&gt;2017.11.04&lt;/h3&gt;
&lt;p&gt;加入Luogu&lt;/p&gt;
&lt;h3&gt;2017.11.05&lt;/h3&gt;
&lt;p&gt;成为了小小牛&lt;/p&gt;
&lt;h3&gt;2017.11.08&lt;/h3&gt;
&lt;p&gt;成为了小小犇&lt;/p&gt;
&lt;h3&gt;2017.11.22&lt;/h3&gt;
&lt;p&gt;成为了小牛&lt;/p&gt;
&lt;h3&gt;2017.12.24&lt;/h3&gt;
&lt;p&gt;成为了小犇&lt;/p&gt;
&lt;h3&gt;2018.01.13&lt;/h3&gt;
&lt;p&gt;成为了中牛&lt;/p&gt;
&lt;h3&gt;2018.02.05&lt;/h3&gt;
&lt;p&gt;成为了中犇&lt;/p&gt;
&lt;h3&gt;2018.02.25&lt;/h3&gt;
&lt;p&gt;成为了大牛&lt;/p&gt;
&lt;h3&gt;2018.03.15&lt;/h3&gt;
&lt;p&gt;AC&lt;a href=&quot;https://www.luogu.org/record/show?rid=6222115&quot;&gt;树链剖分模板&lt;/a&gt;——我人生中AC的第一道紫题啊！！！&lt;/p&gt;
&lt;h3&gt;2018.03.28&lt;/h3&gt;
&lt;p&gt;第一次独立AC蓝题&lt;/p&gt;
&lt;h3&gt;2018.03.30&lt;/h3&gt;
&lt;p&gt;成为了大犇&lt;/p&gt;
&lt;h3&gt;2018.05.04&lt;/h3&gt;
&lt;p&gt;AC 100题(大概有90%是黄题及以下吧Orz)&lt;/p&gt;
&lt;h3&gt;2018.05.12&lt;/h3&gt;
&lt;p&gt;成为了神牛&lt;/p&gt;
&lt;h3&gt;2018.06.23&lt;/h3&gt;
&lt;p&gt;AC 200题&lt;/p&gt;
&lt;h3&gt;&lt;s&gt;2018.08.02&lt;/s&gt;&lt;/h3&gt;
&lt;p&gt;&lt;s&gt;成为了神犇(fAKe)&lt;/s&gt;&lt;/p&gt;
&lt;h3&gt;2018.10.11&lt;/h3&gt;
&lt;p&gt;AC 300题&lt;/p&gt;
&lt;h2&gt;特别感谢&lt;a href=&quot;https://yukkohzq.github.io/&quot;&gt;Yukko&lt;/a&gt;(尽管如今他已经退役了):&lt;/h2&gt;
&lt;p&gt;初中三年每年都看着他参加NOIP，以前闲聊时他也常常给我普及一些算法知识(尽管当时的我不怎么听得懂)。在我入坑OI后他不仅经常手把手教我调试Luogu新手村的水题(在当时的我看来都是神题)，还在第一时间教会了我怎么写dfs、bfs、求最长上升子序列 LIS，以及用 Floyd/Dijkstra/SPFA 求单源最短路，这在当时(2017.12)算是领先了与我同时期入坑OI的大多数人(尽管现在我已经远远落后于各路神犇)，为我之后学习各种算法奠定了坚实基础。&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;Day-1 &amp;amp; Day0&lt;/h1&gt;
&lt;h2&gt;2018.11.08 - 2018.11.09&lt;/h2&gt;
&lt;p&gt;考前两天已经不怎么写新题了，就打了几个模板，再从&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1000&quot;&gt;P1000 超级玛丽游戏&lt;/a&gt;开始看看这一年写过的题. 学机房dalao打了一颗&lt;a href=&quot;https://www.luogu.org/paste/evgtymjh&quot;&gt;完美线段树&lt;/a&gt;，不知道考场上用不用得上.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;Day1&lt;/h1&gt;
&lt;h2&gt;2018.11.10&lt;/h2&gt;
&lt;p&gt;毕竟我是第一次考NOIP，虽然模拟赛已经打了不少了，但是真正上考场还是比较虚的，并没有十足的把握拿省一.&lt;/p&gt;
&lt;h2&gt;8:30&lt;/h2&gt;
&lt;p&gt;拿到题目之后看的第一眼，三道题名暗示了图论?(road), 数论?(money)，数据结构神题?(track)，不过看了一眼内存空间限制512MB，感觉应该比某些毒瘤卡空间模拟赛轻松一些.&lt;/p&gt;
&lt;h2&gt;8:32&lt;/h2&gt;
&lt;p&gt;看完T1题面的第一反应：woc，这不是&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1969&quot;&gt;NOIP 2013 D1T1 积木大赛&lt;/a&gt;？我没有读错题吧，是不是有坑？然而5分钟敲完的积木大赛的代码，小样例大样例都能直接过掉，应该没什么问题. 100pts到手了.&lt;/p&gt;
&lt;p&gt;炒冷饭，就服CCF，hhh......&lt;/p&gt;
&lt;h2&gt;8:40&lt;/h2&gt;
&lt;p&gt;读懂T2题面后的感觉是：这难道是小凯的疑惑毒瘤增强版？那遇到纯数论题就只能打暴力的我岂不是凉了？再看一眼数据范围 $n \leq 100$, $a_i \leq 25000$，没达到$10^{18}$那么吓人，感觉暴力或者乱搞还是勉强能拿部分分的.&lt;/p&gt;
&lt;p&gt;在草稿纸上乱搞了10分钟后发现答案应该是给出的那一堆货币面额的子集，否则会不符合题意，那么似乎可以$O(n^3)$枚举每三个数，看看较小的那两个数能不能凑出较大的那个数，如果可以就去掉.&lt;/p&gt;
&lt;p&gt;诶？这是不是小凯的疑惑？又花了十几分钟打出一个 $O(T * n ^ 3)$ 的做法，过了样例1，但是样例2没过——第七组和第九组数据WA了，输出居然比答案多1. 赶紧debug看看是哪一个数字没有被fuck掉，发现一个数如果能被另外三个或以上的数乘上系数凑出来也是可以合法被去掉的——woc这真是小凯的疑惑毒瘤增强版.&lt;/p&gt;
&lt;p&gt;冷静一下，我开始认真思考这题要怎么搞，想起有道dp题叫&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2347&quot;&gt;砝码称重&lt;/a&gt;，把数从小到大排序，赋初值$ans=n$，开个$bool$数组记录一下每个数可不可以被前面的数凑出来，如果可以(被标记过)就令$ans-1$，否则遍历该$bool$数组并把&quot;这个数的倍数+已标记的$bool$数组下标&quot;标记上。把这个做法敲出来，调一调就过样例2了，期望如果数据友好一些就可以AC了. YES!!!&lt;/p&gt;
&lt;h2&gt;10:35&lt;/h2&gt;
&lt;p&gt;写T2之前就瞥了一眼T3，感觉题目太长就没细看，觉得T3敲个暴力就差不多了，毕竟T3通常不可做.&lt;/p&gt;
&lt;p&gt;现在仔细读题：要求最小值最大？明显要二分. 再看第一档部分分：$m=1$？也就是说求个树的直径就可以拿20. 赶紧敲了个$Dijkstra$+$Heap$优化的最短路（因为写的比较熟）.&lt;/p&gt;
&lt;p&gt;再看看剩下的部分分，菊花图和一条链的数据好像可做，菊花图搞个 二分+排序+贪心 应该就可以了， 一条链也是 二分+贪心， 又搞了40分钟，生成了几组小数据拍过了，感觉可以拿55了，剩下的分看起来是树形dp，但是懒得想了（主要是我太菜了想不出来，而且也没时间了），所以写到这里就差不多可以交了.&lt;/p&gt;
&lt;h2&gt;12:00&lt;/h2&gt;
&lt;p&gt;检查完文件名和输入输出就交了. DAY1 考场部分到此结束，刚出考场时期望得分还是有255的.&lt;/p&gt;
&lt;h2&gt;15:30&lt;/h2&gt;
&lt;p&gt;一觉醒来准备想去机房颓废，突然想起：早上T2如果造出前99个质数+一个25000的数据那我岂不是TLE飞去？因为这时候复杂度最坏可以达到$O(T * n * ({max{a_i}})^2)$. 这么算来T2只有75分是稳的了，希望数据友好一些吧......&lt;/p&gt;
&lt;p&gt;还有T3，突然想起来我二分答案的范围好像设错了，原题中是 $l_i \leq 10000$ 来着，而我为了调样例方便把上界设为 $r=30000$ ，提交前忘记改回来了，并且在一条链的数据中忘记将边的长度序列从小到大排序，如果数据中$m$比较小或者输入的树边不是按顺序的那就gg了. 菊花图和链的30分又没了，唉...... D1期望得分掉回225-了.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;Day2&lt;/h1&gt;
&lt;h2&gt;2018.11.11&lt;/h2&gt;
&lt;p&gt;由于D1T1出了NOIP2013原题，导致Day1整体偏简单(大概全机房除了我，都AK了吧).所以早有传闻Day2的题会爆难(同机房dalao多次警告：可能会有传说中毁天灭地的第七分块，建议直接打暴力...Orz).&lt;/p&gt;
&lt;h2&gt;8:30&lt;/h2&gt;
&lt;p&gt;由于早就听说Day2的题不太可做，于是开考后我先干点别的，比如先验证一下昨天机房dalao所说的今年CCF评测机换成 Intel® Core™ i7-8700K Processor + 32GB RAM 了，一看注意事项还真是如此，Day1考试的时候没注意这一点，没想到第一次参加NOIP就碰上CCF老爷机换成CCF队爷机了，这就意味着代码常数大一点也没事，但是不知道是用什么主板，而且Noi Linux万年32位的系统又怎么寻址得了32GB？&lt;s&gt;不过如果CPU上个液态氮，超频到8.0GHz，那么写个暴力大搜索也是能过的吧&lt;/s&gt;.&lt;/p&gt;
&lt;h2&gt;8:33&lt;/h2&gt;
&lt;p&gt;颓废结束. 先把3题都看了一眼，感觉T2 T3题目又臭又长又不可做呢.&lt;/p&gt;
&lt;h2&gt;8:35&lt;/h2&gt;
&lt;p&gt;跳回来认真看T1.依照题意，要求一张图的字典序最小的dfs续，看起来直接从1号节点开始贪心dfs可做，不过第一眼看错题目了，以为是一张普通无向图，想了5分钟想不出一些边界条件的处理方法，然后才发现有 $m \leq n$ 这个条件.&lt;/p&gt;
&lt;p&gt;那么前60分$m = n - 1$的数据就稳了，几分钟写个dfs，然后先用邻接矩阵村边，再从大到小遍历邻接矩阵，改成链式前向星存边，这样就可以保证严格按照最小字典序进行dfs遍历，而且是跑得超快的 $O(2n-1)$ 时间复杂度的dfs.&lt;/p&gt;
&lt;p&gt;重点是后40分 $n = m$ 的情况，咋一看直接照着前60分的方法dfs一次，遇到走过的点就退出就可以了，结果样例都过不了. 然后开始想各种奇怪的dfs方法，什么“记录每个节点的次小子节点并与当前节点比较来决定是否回溯”、“记录每个节点前驱最小子节点并与当前节点编号比较来决定是否回溯”、“动态判断子节点能否被再次搜索到来决定是否回溯”之类的玄学方法，但是都过不了样例. 此时已经9:15了，如果再写不出T1，Day2就凉了......&lt;/p&gt;
&lt;p&gt;突然想起来我们不是要处理环嘛，若要很方便地处理环套树，那自然是用Tarjan求双联通分量，然后只要记录一下首次搜索到环的入口节点的次小环上子节点，一旦搜索到编号比该节点大的环上节点就立即回溯，这样应该就是最优解了. 花10分钟写了个Tarjan，结果写挂了，调了20分钟才救回来. 测一下样例，诶？居然大小样例都能过，那这题就AC了？(事实上这样做是错的，Day2当天晚上同机房大佬&lt;a href=&quot;https://www.luogu.org/space/show?uid=96312&quot;&gt;srydsf123&lt;/a&gt;在听了我的解法后瞬间出了一组数据Hack掉了这种做法，这说明大样例还是挺水的).&lt;/p&gt;
&lt;h2&gt;10:00&lt;/h2&gt;
&lt;p&gt;T1已经困了我一个半小时了，T2 T3打打暴力应该就差不多了，毕竟Day2对于我这种蒟蒻来说有个100+就不错了.&lt;/p&gt;
&lt;p&gt;看见T2，读了差不多10分钟才知道题目想干嘛. 感觉要做出来得打表找规律，那就先打暴力. 但是这个暴力还是不太好打的，得先枚举出所有路径，再枚举01矩阵并检验是否合法. 打了20分钟的暴力，测测样例1：Yes!!! 过了；测测样例2：woc!!! 输出96？什么鬼，我暴力写挂了？然而20分钟肉眼调试并没有查出错误...... (为什么CCF不把样例2解释一下啊，112种可能结果很难一一列举出来么#滑稽). 没辙，已经快11:00了，万一T3暴力又写挂今天就真的凉了，于是T2我放上写挂的搜索+输出所有样例就走了. 至于这题有没有样例分就只能拼rp了.&lt;/p&gt;
&lt;h2&gt;10:55&lt;/h2&gt;
&lt;p&gt;T3题意蛮容易读的，可能正因为这样，我竟然读错题了，我以为这题就是&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2458&quot;&gt;保安站岗&lt;/a&gt;. 先10分钟打出 $O(m * 2^n)$ 的大暴力，测一测小样例，可以过。然后因为不太记得保安站岗的详细做法，所以决定先不写保安站岗的树形dp了，转而去写一条链的部分分. 又是20分钟过去了.&lt;/p&gt;
&lt;p&gt;已经11:30了， 因为没有一条链的样例，所以这个做法对不对只能听天由命了. 然后突然发现样例2的数据规模挺小的 $n,m \leq 10$， 就拿来测一下 $O(m * 2^n)$ 的大暴力——竟然WA了？还剩半个小时突然发现T3面临爆零...赶紧肉眼静态查错(在我这种蒟蒻眼中debug暴力程序的方法就只有这种了吧). 一查又是20分钟，找不出任何bug，样例2死活过不去，但只能这样了.&lt;/p&gt;
&lt;h2&gt;11:50&lt;/h2&gt;
&lt;p&gt;检查文件输入输出就准备交了吧，T1算法的正确性仍有待验证，T2 T3很可能爆零，Day2估计是凉了.&lt;/p&gt;
&lt;h2&gt;12:00&lt;/h2&gt;
&lt;p&gt;刚出考场就突然想到，woc T1直接$O(n^2)$枚举删掉哪一条边然后再dfs不就可以了？我在考场上居然没想出来......&lt;/p&gt;
&lt;h2&gt;21:20&lt;/h2&gt;
&lt;p&gt;机房大佬&lt;a href=&quot;https://www.luogu.org/space/show?uid=96312&quot;&gt;srydsf123&lt;/a&gt;Hack掉了我T1的后40分做法，至此，Day2期望得分只有60-80分了&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;期望最高得分($Day$ $Dream$ -  Orz):&lt;/p&gt;
&lt;p&gt;100 + 100 + 55 + 100 + 5 + 0 = 360&lt;/p&gt;
&lt;p&gt;期望最低得分：&lt;/p&gt;
&lt;p&gt;100 + 80 + 20 + 60 + 0 + 0 = 260&lt;/p&gt;
&lt;p&gt;用&lt;a href=&quot;https://www.luogu.org/contestnew/show/12952&quot;&gt;Luogu&lt;/a&gt;提供的数据测试得分:&lt;/p&gt;
&lt;p&gt;100 + 95 + 55 + 72 + 5 + 0 = 327&lt;/p&gt;
&lt;p&gt;用机房大佬&lt;a href=&quot;https://www.luogu.org/space/show?uid=117525&quot;&gt;Dystractor&lt;/a&gt;提供的数据测试得分:&lt;/p&gt;
&lt;p&gt;100 + 100 + 25 + 76 + 5 + 0 = 306&lt;/p&gt;
&lt;p&gt;用友邦提供的数据测试得分(运行结果由&lt;a href=&quot;https://www.luogu.org/space/show?uid=51441&quot;&gt;laybxc&lt;/a&gt;传达):&lt;/p&gt;
&lt;p&gt;$\overline{???}$ + $\overline{???}$ $\Big( \overline{??} \Big)$ + $\overline{??}$ + $\overline{??}$ + $\overline{?}$ + $\overline{?}$ = 309&lt;/p&gt;
&lt;p&gt;CCF生成测试数据得分(Reality)：&lt;/p&gt;
&lt;p&gt;100 + 100 + 35 + 68 + 10 + 0 = 313&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 
*      ┏┛ ┻━━━━━┛ ┻┓
*      ┃　　　　　　 ┃
*      ┃　　　━　　　┃
*      ┃　┳┛　  ┗┳　┃
*      ┃　　　　　　 ┃
*      ┃　　　┻　　　┃
*      ┃　　　　　　 ┃
*      ┗━┓　　　┏━━━┛
*        ┃　　　┃   神兽保佑
*        ┃　　　┃   代码无BUG！
*        ┃　　　┗━━━━━━━━━┓
*        ┃　　　　　　　    ┣┓
*        ┃　　　　         ┏┛
*        ┗━┓ ┓ ┏━━━┳ ┓ ┏━┛
*          ┃ ┫ ┫   ┃ ┫ ┫
*          ┗━┻━┛   ┗━┻━┛
*/ 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;个人认为今年NOIP画风是真的鬼畜(贪心运气好就AC，运气不好则爆零；猜结论猜对者AC，猜错者爆零)，D1T1出2013年原题实在欠妥，这不仅让GX-TG组的省一分数线提高数十分之多，而且对没写过此题的选手不公平(友邦朋友验证). 另外，这次NOIP竟然没有考数据结构题(不考线段树、树状数组~~、BST、Treap普通平衡树~~之类的就算了，连个栈、队列、链表都不考么，这堆数据结构学了然并卵诶).&lt;/p&gt;
&lt;p&gt;NOIP 2018在GX-TG组的省一分数线目前尚不明确(机房大佬们预测省一线在250分左右). 虽然有消息称我的分数是稳省一的，但是由于我在这次比赛中过多使用玄学算法，因此我最终的得分与排名仍有很大的不确定性.&lt;/p&gt;
&lt;p&gt;对我个人而言，Day2考的太差，因为看错、写挂而丢了很多分，早知如此就应该死磕D2T1，不打T2 T3了.&lt;/p&gt;
&lt;p&gt;有人告诉我说我搞一年OI就可以得省一其实挺值的，但在我看来，这次NOIP终究是有挺多遗憾的......&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;最后在此感谢所有帮助过我或与我共同奋斗过的人:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=31470&quot;&gt;Uchiha_Obito&lt;/a&gt;/&lt;a href=&quot;https://www.luogu.org/space/show?uid=117525&quot;&gt;Dystractor&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=52563&quot;&gt;GoldenPotato&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=60418&quot;&gt;li_z&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://yukkohzq.github.io/&quot;&gt;Yukko&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=81494&quot;&gt;Ace_Heart&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=13447&quot;&gt;Maxwei_wzj&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=83224&quot;&gt;114514_hb&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=96312&quot;&gt;srydsf123&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=58595&quot;&gt;Capacitance_core&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=77262&quot;&gt;迅捷之松&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=64314&quot;&gt;Summer_Night_Sky&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=81746&quot;&gt;Glodfish&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=51441&quot;&gt;laybxc&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=82001&quot;&gt;zhlgzhh&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=83709&quot;&gt;Seass&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=90249&quot;&gt;SHDZAYN&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=85126&quot;&gt;LSYZX&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=81747&quot;&gt;502Chain&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=41950&quot;&gt;泅荼&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=43068&quot;&gt;nnezhb&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=28416&quot;&gt;nnez_xiaoliwei&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=9661&quot;&gt;hebomou&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=4025&quot;&gt;o0数学迷0o&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=116425&quot;&gt;[用户名敏感问题待定]&lt;/a&gt; (stO %%% zxbtql %%% --☐-☐-- %%% Orz)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=116588&quot;&gt;Mireco&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=36701&quot;&gt;5743377_2002&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=65899&quot;&gt;ComputerEngine&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=73738&quot;&gt;Zarathustra&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=86680&quot;&gt;dmidcoder&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=81724&quot;&gt;AMDYES&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/space/show?uid=85734&quot;&gt;nnezhhh&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有值得感谢但因为各种原因未在该列表中出现的人&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/11/19/FpUOHS.jpg&quot; alt=&quot;XMD_LYJ_AK_IOI&quot; /&gt;&lt;/p&gt;
&lt;p&gt;祝各位NOIP 2018 RP++.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;By &lt;a href=&quot;https://www.luogu.org/space/show?uid=70367&quot;&gt;Von Brank&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Last Updated at 2018-11-20 08:23:49&lt;/p&gt;
</content:encoded></item><item><title>【洛谷】题解 - P1797 【克鲁斯的加减法_NOI导刊2010提高（05）】</title><link>https://blog.vonbrank.com/posts/luogu-solution-p1797/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/luogu-solution-p1797/</guid><pubDate>Thu, 11 Oct 2018 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;这题是&lt;a href=&quot;https://www.luogu.org/space/show?uid=51441&quot;&gt;@laybxc&lt;/a&gt;这位神犇推荐给我写的。从开始写到AC前后时间跨度一个星期，这是我第一次认认真真写高精，100+的总提交次数应该有15次是我提交的，因为实在太毒瘤了，感谢@laybxc提供的高精度模板让我找出了原本我写的代码中的错误，今天终于AC了，所以发一篇题解庆祝一下。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;这道题本质是道模拟题（第一次看的时候还是黄题，现在居然蓝了），主要做法就是遍历字符串并找出每一项的值，然后加起来，用int可以过60分，long long和int128也都只能过60分，显然剩下40分必须用高精了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
//因为我太弱了，不会写高精度类，只会用struct
//而且写高精度算法的经验比较少，所以高精写的比较丑
struct BigInt	
{
    int ch;
    int x[300];
};
inline void clear(BigInt&amp;amp; x);		//初始化BigInt
inline BigInt read();				//读入BigInt（好像这题并没有用）
inline int Compare(BigInt a, BigInt b);//比较函数
inline BigInt Plus(BigInt a, BigInt b);//高精加
inline BigInt Minus(BigInt a, BigInt b);//高精减
inline BigInt Multi(BigInt a, BigInt b);//高精乘
inline BigInt Int_to_BigInt(int x);//把int转换成BigInt
inline void clear(BigInt&amp;amp; x)
{
    memset(x.x, 0, sizeof(x.x));
    x.ch = 1;
}
inline BigInt read()
{
    BigInt x;
    clear(x);
    char ch = getchar();
    while(!isdigit(ch) &amp;amp;&amp;amp; ch != &apos;-&apos;)
        ch = getchar();
    if(ch == &apos;-&apos;)
    {
        x.ch = -1;
        ch = getchar();
    }
    while(isdigit(ch))
    {
        x.x[++x.x[0]] = ch - &apos;0&apos;;
        ch = getchar();
    }
    for(int i=1; i&amp;lt;=x.x[0]/2; i++)
    {
        swap(x.x[i], x.x[x.x[0]-i+1]);
    }
    return x;
}
inline BigInt Int_to_BigInt(int x)
{
    BigInt c;
    clear(c);
    if(x &amp;lt; 0)
    {
        c.ch = -1;
        x = -x;
    }
    if(x == 0) c.x[0]++;
    while(x)
    {
        c.x[++c.x[0]] = x % 10;
        x /= 10;
    }
    return c;
}
inline int Compare(BigInt a, BigInt b)
{
    if(a.x[0] &amp;gt; b.x[0]) return 1;
    if(a.x[0] &amp;lt; b.x[0]) return -1;
    for(int i=a.x[0]; i; i--)
    {
        if(a.x[i] &amp;gt; b.x[i]) return 1;
        if(a.x[i] &amp;lt; b.x[i]) return -1;
    }
    return 0;
}
inline BigInt Plus(BigInt a, BigInt b)
{
    BigInt c;
    clear(c);
    if(a.ch == 1 &amp;amp;&amp;amp; b.ch == -1)
    {
        b.ch = 1;
        return Minus(a, b);
    }
    if(a.ch == -1 &amp;amp;&amp;amp; b.ch == 1)
    {
        a.ch = 1;
        return Minus(b, a);
    }
    if(a.ch == -1 &amp;amp;&amp;amp; b.ch == -1)
    {
        c.ch = -1;
    }
    int k = a.x[0] &amp;gt; b.x[0] ? a.x[0] : b.x[0], g = 0;
    for(int i=1; i&amp;lt;=k; i++)
    {
        c.x[i] = a.x[i] + b.x[i] + g;
        g = c.x[i] / 10;
        c.x[i] %= 10;
    }
    if(g) c.x[++k] = g;
    c.x[0] = k;
    return c;
}
inline BigInt Minus(BigInt a, BigInt b)
{
    BigInt c;
    clear(c);
    if(a.ch == -1 &amp;amp;&amp;amp; b.ch == -1)
    {
        a.ch = 1;
        b.ch = 1;
        return Minus(b, a);
    }
    if(a.ch == -1 &amp;amp;&amp;amp; b.ch == 1)
    {
        a.ch = 1;
        c = Plus(a, b);
        c.ch = -1;
        return c;
    }
    if(a.ch == 1 &amp;amp;&amp;amp; b.ch == -1)
    {
        b.ch = 1;
        return Plus(a, b);
    }
    int flag = Compare(a, b);
    if(flag == 0)
    {
        c.x[0] = 1;
        return c;		
    }
    if(flag == 1)
    {
        int k = a.x[0];
        for(int i=1; i&amp;lt;=k; i++)
        {
            if(a.x[i] &amp;lt; b.x[i])
            {
                a.x[i+1]--;
                a.x[i] += 10;
            }
            c.x[i] = a.x[i] - b.x[i];
        }
        while(c.x[k] == 0) k--;
        c.x[0] = k;
        return c;
    }
    else
    {
        int k = b.x[0];
        c.ch = -1;
        for(int i=1; i&amp;lt;=k; i++)
        {
            if(b.x[i] &amp;lt; a.x[i])
            {
                b.x[i+1]--;
                b.x[i] += 10;
            }
            c.x[i] = b.x[i] - a.x[i];
        }
        while(c.x[k] == 0) k--;
        c.x[0] = k;
        return c;
    }
}
inline BigInt Multi(BigInt a, BigInt b)
{
    BigInt c;
    clear(c);
    c.ch = a.ch * b.ch;
    int ka = a.x[0], kb = b.x[0], k = ka + kb + 1;
    for(int i=1; i&amp;lt;=ka; i++)
    {
        for(int j=1; j&amp;lt;=kb; j++)
        {
            c.x[i+j-1] += a.x[i] * b.x[j];
            c.x[i+j] += c.x[i+j-1] / 10;
            c.x[i+j-1] %= 10;
        }
    }
    while(!c.x[k]) k--;
    c.x[0] = k;
    return c;
}
inline void print(BigInt x)//打印高精度数
{
    if(x.x[0] == 0) printf(&quot;0&quot;);
    if(x.ch == -1) printf(&quot;-&quot;);
    for(int i=1; i&amp;lt;=x.x[0]; i++)
        printf(&quot;%d&quot;, x.x[x.x[0]-i+1]);
}
const int maxn = 205;
int top, len;
int b[maxn];
BigInt ansx, ans[maxn], tmp;
char a[maxn];
int main()
{
    clear(ansx);
    ansx.x[0] = 1;
    scanf(&quot;%s&quot;, a+1);
    len = strlen(a+1);
    for(int i=1; i&amp;lt;=len; i++)
    {
        if(i == 1 &amp;amp;&amp;amp; (a[i] &amp;gt;= &apos;0&apos; &amp;amp;&amp;amp; a[i] &amp;lt;= &apos;9&apos;))
        {	//如果第一个字符属于第一个数，则直接存起来
            int l, r;
            for(l=1; l&amp;lt;=len; l++)
            {
                if(a[l] &amp;lt; &apos;0&apos; || a[l] &amp;gt; &apos;9&apos;)
                {
                    r = l-1;
                    break;
                }
            }
            ++top;
            clear(ans[top]);
            ans[top] = Plus(ans[top], Int_to_BigInt(a[1] - &apos;0&apos;));
            for(int j=2; j&amp;lt;=r; j++)
            {
            	clear(tmp);
            	ans[top] = Multi(ans[top], Int_to_BigInt(10));
                ans[top] = Plus(ans[top], Int_to_BigInt(a[j]-&apos;0&apos;));
            }
            continue;
        }
        if(a[i] == &apos;+&apos; || a[i] == &apos;-&apos;)
        {	//遇到&apos;+&apos;号或&apos;-&apos;号就处理这一项的值
            char character;
            character = a[i];
            int m, k, l;
            BigInt ax, bx, numc;
            clear(ax);
            clear(bx);
            clear(numc);
            for(int j=i; j&amp;lt;=len; j++)
            {	//找出&apos;+&apos;号或&apos;-&apos;号的个数
                if(a[j] != character)
                {
                    m = j - 1;
                    break;
                } 
                numc = Plus(numc, Int_to_BigInt(1));
            }
            if(a[m+1] == &apos;(&apos;)
            {	//处理括号内的数的值
                for(int j=m+2; j&amp;lt;=len; j++)
                {
                    if(a[j] == &apos;)&apos;)
                    {
                        k = j-1;
                        break;
                    }
                }
                ax = Plus(ax, Int_to_BigInt(a[m+2] - &apos;0&apos;));
                for(int j=m+3; j&amp;lt;=k; j++)
                {
                	ax = Multi(ax, Int_to_BigInt(10));
                    ax = Plus(ax, Int_to_BigInt(a[j] - &apos;0&apos;));
                }				
            }
            else
            {
                k = m - 1;
                ax = Plus(Int_to_BigInt(0), Int_to_BigInt(1));
                //如果并没有括号则 ax = 1;
            }
            for(int j=k+2; j&amp;lt;=len; j++)
            {	//处理此项剩余部分的值
                if(j == len) l = j;
                if(a[j] &amp;lt; &apos;0&apos; || a[j] &amp;gt; &apos;9&apos;)
                {
                    l = j-1;
                    break;
                }
            }
            bx = Plus(bx, Int_to_BigInt(a[k+2] - &apos;0&apos;));
            for(int j=k+3; j&amp;lt;=l; j++)
            {
            	bx = Multi(bx, Int_to_BigInt(10));
                bx = Plus(bx, Int_to_BigInt(a[j] - &apos;0&apos;));
            }
            ++top;
            clear(ans[top]);
            ans[top] = Plus(Int_to_BigInt(0), Int_to_BigInt(1));
            ans[top] = Multi(ans[top], ax);
            ans[top] = Multi(ans[top], bx);
            ans[top] = Multi(ans[top], numc);
            //把符号个数，括号内的数，后的数的值乘起来
            i = l;
            if(character == &apos;-&apos;)//如果是&apos;-&apos;号则项取相反数
            	ans[top] = Multi(ans[top], Int_to_BigInt(-1));
        }
    }
    for(int i=1; i&amp;lt;=top; i++) //把每一项的数加起来作为答案输出
    	ansx = Plus(ansx, ans[i]);
    print(ansx);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>【洛谷】题解 - P4285 【[SHOI2008]汉诺塔】</title><link>https://blog.vonbrank.com/posts/luogu-solution-p4285/</link><guid isPermaLink="true">https://blog.vonbrank.com/posts/luogu-solution-p4285/</guid><pubDate>Thu, 02 Aug 2018 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;分享一下蒟蒻我的奇葩做法，因为不会dp……&lt;/p&gt;
&lt;p&gt;这道题第一眼看便想到参考&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1242&quot;&gt;P1242 新汉诺塔&lt;/a&gt;的递归移圆盘的方法，在递归的过程中判断一下优先级就可以了，模拟即可。&lt;/p&gt;
&lt;p&gt;20分的做法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;
const int maxn = 50;
int n, last;
int pos[maxn], rnk[50], first[5], stk[4][maxn];
long long ans;
bool check()
{
    for(int i=2; i&amp;lt;=n; i++)
        if(pos[i] != pos[i-1] || (pos[i] == 1 || pos[i-1] == 1)) return false;
    return true;
}
void getRnk(int x, int &amp;amp;a, int &amp;amp;b)
{
    a = x / 10;
    b = x % 10;
}
void dfs()
{
    if(check()) return;
    for(int i=1; i&amp;lt;=6; i++)
    {
        int a, b;
        getRnk(rnk[i], a, b);
        if(stk[a][0] &amp;amp;&amp;amp; stk[a][stk[a][0]] != last &amp;amp;&amp;amp; (stk[a][stk[a][0]] &amp;lt; stk[b][stk[b][0]] || !stk[b][0]))
        {
            last = stk[a][stk[a][0]--];
            stk[b][++stk[b][0]] = last;
            pos[last] = b;
            dfs();
            break;
        }
    }
    ans++;
}
int main()
{
    scanf(&quot;%d&quot;, &amp;amp;n);
    for(int i=1; i&amp;lt;=n; i++) pos[i] = 1;
    for(int i=1; i&amp;lt;=6; i++)
    {
        char tmp[3];
        scanf(&quot;%s&quot;, tmp+1);
        int now = int(tmp[1]-&apos;A&apos;+1)*10 + int(tmp[2]-&apos;A&apos;+1);
        rnk[i] = now;
    }
    for(int i=1; i&amp;lt;=n; i++) stk[1][++stk[1][0]] = n-i+1;
    dfs();
    printf(&quot;%d&quot;, ans);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是面对接近$10^{18}$的答案范围，显然在递归过程中会MLE——&lt;s&gt;所以自然要打表找规律啦&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;因为总的顺序数就是6！，即720种可能情况，用1代表AB，2代表AC，3代表BA，4代表BC，5代表CA，6代表CB，枚举一下1，2，3，4，5，6的全排列，我们发现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n=3时有7, 9, 17这三种答案
n=4时有15, 27, 53这三种答案
n=5时有31, 81, 161这三种答案
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以对于n，答案就是$2^n-1$,  $3^{n-1}$, $2*3^{n-1}-1$中的某一个，根据n=3时的结果得出mark数组.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
const int maxn = 50;
int n, last;
int a[10], p[10];
int mark[721] =
{
/*
看一下对于AB, AC, BA, BC, CA, CB的
每一个排列对应的答案是哪一个
1, 2, 3分别表示2^n-1, 3^(n-1), 2*3^(n-1)-1
*/
    3, 3, 3, 3, 3, 3, 1, 2, 1, 1, 
    2, 2, 3, 3, 1, 1, 3, 1, 3, 3, 
    2, 2, 3, 2, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 1, 2, 
    1, 1, 2, 2, 1, 2, 1, 1, 2, 2, 
    1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 
    2, 2, 3, 3, 1, 1, 3, 1, 3, 3, 
    3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 
    3, 1, 3, 3, 1, 1, 3, 3, 2, 2, 
    3, 2, 3, 3, 3, 3, 3, 3, 2, 2, 
    2, 2, 2, 2, 3, 2, 3, 3, 2, 2, 
    3, 1, 3, 3, 1, 1, 3, 2, 3, 3, 
    2, 2, 3, 3, 3, 3, 3, 3, 1, 1, 
    2, 2, 1, 2, 3, 1, 3, 3, 1, 1, 
    3, 1, 3, 3, 1, 1, 3, 3, 3, 3, 
    3, 3, 1, 1, 1, 1, 1, 1, 3, 2, 
    3, 3, 2, 2, 3, 2, 3, 3, 2, 2, 
    3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 
    2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 1, 1, 2, 2, 
    1, 2, 1, 1, 1, 1, 1, 1, 2, 2, 
    2, 2, 2, 2, 1, 2, 1, 1, 2, 2, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 1, 3, 3, 1, 1, 
    3, 1, 3, 3, 1, 1, 3, 3, 3, 3, 
    3, 3, 1, 1, 1, 1, 1, 1, 3, 3, 
    3, 3, 3, 3, 3, 1, 3, 3, 1, 1, 
    3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 
    3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 1, 1, 1, 1, 1, 1, 3, 3, 
    1, 1, 3, 1, 3, 3, 1, 1, 3, 1, 
    1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 
    2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 
    2, 2, 2, 2, 3, 2, 3, 3, 2, 2, 
    3, 2, 3, 3, 2, 2, 3, 3, 3, 3, 
    3, 3, 2, 2, 2, 2, 2, 2, 1, 2, 
    1, 1, 2, 2, 3, 2, 3, 3, 2, 2, 
    1, 1, 3, 3, 1, 3, 2, 2, 2, 2, 
    2, 2, 1, 1, 1, 1, 1, 1, 3, 3, 
    3, 3, 3, 3, 1, 1, 3, 3, 1, 3, 
    1, 1, 3, 3, 1, 3, 2, 2, 2, 2, 
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
    3, 3, 1, 1, 3, 1, 3, 3, 3, 3, 
    3, 3, 1, 1, 1, 1, 1, 1, 3, 1, 
    3, 3, 1, 1, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 1, 1, 1, 1, 1, 1, 3, 3, 
    3, 3, 3, 3, 1, 1, 3, 3, 1, 3, 
    1, 1, 3, 3, 1, 3, 3, 1, 3, 3, 
    1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 1, 1, 3, 3, 1, 3, 
    3, 3, 2, 2, 3, 2, 3, 3, 3, 3, 
    3, 3, 2, 2, 2, 2, 2, 2, 3, 2, 
    3, 3, 2, 2, 1, 1, 2, 2, 1, 2, 
    1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 
    2, 2, 1, 2, 1, 1, 2, 2, 3, 3, 
    3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 
    3, 3, 1, 1, 3, 1, 3, 3, 1, 1, 
    3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
    2, 2, 2, 2, 2, 2, 3, 2, 3, 3, 
    2, 2, 1, 2, 1, 1, 2, 2, 3, 3, 
    1, 1, 3, 1, 2, 2, 2, 2, 2, 2, 
};
long long ans;

int cal(char *tmp)
{
    if(tmp[1] == &apos;A&apos; &amp;amp;&amp;amp; tmp[2] == &apos;B&apos;) return 1;
    if(tmp[1] == &apos;A&apos; &amp;amp;&amp;amp; tmp[2] == &apos;C&apos;) return 2;
    if(tmp[1] == &apos;B&apos; &amp;amp;&amp;amp; tmp[2] == &apos;A&apos;) return 3;
    if(tmp[1] == &apos;B&apos; &amp;amp;&amp;amp; tmp[2] == &apos;C&apos;) return 4;
    if(tmp[1] == &apos;C&apos; &amp;amp;&amp;amp; tmp[2] == &apos;A&apos;) return 5;
    if(tmp[1] == &apos;C&apos; &amp;amp;&amp;amp; tmp[2] == &apos;B&apos;) return 6;
}
int cantor(int now[10])
{   //康拓展开求出输入的排列在全排列中排第几
    int cnt = 0, res = 0;
    bool vis[15];
    memset(vis, 0, sizeof(vis));
    for(int i=1; i&amp;lt;=6; i++)
    {
        int small = 0;
        vis[now[i]] = true;
        for(int j=1; j&amp;lt;now[i]; j++)
        {
            if(!vis[j]) small++;
        }
        res += small*p[6-i];
    }
    return res;
}
void solve1()
{
    ans = 1;
    for(int i=1; i&amp;lt;=n; i++)
        ans *= 2;
    ans--;
}
void solve2()
{
    ans = 1;
    for(int i=1; i&amp;lt;n; i++)
        ans *= 3;
}
void solve3()
{
    ans = 1;
    for(int i=1; i&amp;lt;n; i++)
        ans *= 3;
    ans = ans*2 - 1;
}
int main()
{
    scanf(&quot;%d&quot;, &amp;amp;n);
    p[0] = 1;
    for(int i=1; i&amp;lt;=9; i++) p[i] = p[i-1]*i;
    for(int i=1; i&amp;lt;=6; i++)
    {
        char tmp[3];
        scanf(&quot;%s&quot;, tmp+1);
        a[i] = cal(tmp);
    }
    int loc = cantor(a);
    if(mark[loc] == 1) solve1();
    if(mark[loc] == 2) solve2();
    if(mark[loc] == 3) solve3();
    printf(&quot;%lld&quot;, ans);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item></channel></rss>